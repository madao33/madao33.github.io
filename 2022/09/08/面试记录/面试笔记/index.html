

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/avatar/avatar.jpg">
  <link rel="icon" href="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/avatar/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="madao33">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试笔记总结Java后端相关的重要知识点 Java基础基础Java语言的特点 简单易学、有丰富的类库 面向对象 与平台无关性，主要是JVM虚拟机的支持 可靠安全 支持多线程  你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点 Java是面向对象的，比较符合人的认知 Java和C++都是面向对象的，都支持封装、继承和多态 Java不是通过指针">
<meta property="og:type" content="article">
<meta property="og:title" content="面试笔记">
<meta property="og:url" content="http://example.com/2022/09/08/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试笔记总结Java后端相关的重要知识点 Java基础基础Java语言的特点 简单易学、有丰富的类库 面向对象 与平台无关性，主要是JVM虚拟机的支持 可靠安全 支持多线程  你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点 Java是面向对象的，比较符合人的认知 Java和C++都是面向对象的，都支持封装、继承和多态 Java不是通过指针">
<meta property="og:locale">
<meta property="og:image" content="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/post_img/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.jpg">
<meta property="article:published_time" content="2022-09-08T14:00:57.000Z">
<meta property="article:modified_time" content="2022-09-25T12:28:54.461Z">
<meta property="article:author" content="madao33">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="offer">
<meta property="article:tag" content="后端开发">
<meta property="article:tag" content="八股文">
<meta property="article:tag" content="摆烂">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/post_img/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>面试笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>madao33</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://madao33-static.oss-cn-hangzhou.aliyuncs.com/post_img/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="总结一下面试之后不太熟悉的一些东西"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-08 22:00" pubdate>
          September 8, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          72k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          599 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">总结一下面试之后不太熟悉的一些东西</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试笔记"><a href="#面试笔记" class="headerlink" title="面试笔记"></a>面试笔记</h1><p>总结Java后端相关的重要知识点</p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ul>
<li>简单易学、有丰富的类库</li>
<li>面向对象</li>
<li>与平台无关性，主要是JVM虚拟机的支持</li>
<li>可靠安全</li>
<li>支持多线程</li>
</ul>
<h3 id="你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"><a href="#你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点" class="headerlink" title="你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"></a>你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点</h3><ul>
<li>Java是面向对象的，比较符合人的认知</li>
<li>Java和C++都是面向对象的，都支持封装、继承和多态</li>
<li>Java不是通过指针访问内存的，程序的内存自动通过垃圾回收算法回收</li>
<li>Java单继承，C++支持多重继承，虽然Java不可以多继承，但是接口可以多继承</li>
</ul>
<h3 id="说一下Java的八种基本类型"><a href="#说一下Java的八种基本类型" class="headerlink" title="说一下Java的八种基本类型"></a>说一下Java的八种基本类型</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220801221127384.png" srcset="/img/loading.gif" lazyload alt="image-20220801221127384"></p>
<h3 id="讲一下int和Integer的区别"><a href="#讲一下int和Integer的区别" class="headerlink" title="讲一下int和Integer的区别"></a>讲一下int和Integer的区别</h3><ul>
<li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li>
<li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li>
<li>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java 虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素 boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字 节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的 是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="有了解过Java中ArrayList和LinkedList的区别"><a href="#有了解过Java中ArrayList和LinkedList的区别" class="headerlink" title="有了解过Java中ArrayList和LinkedList的区别"></a>有了解过Java中ArrayList和LinkedList的区别</h3><ul>
<li>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有 数据, (因为删除数据以后, 需要把后面所有的数据前移)</li>
<li>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于 ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap底层基于红黑树实现，可以保证在log(n)的时间复杂度内完成containsKey、get、put、remove操作。同时因为其由红黑树构成，也就是说明了能够维持内部元素的有序性，关于⽀持内部元素有序性的集合还有LinkedHashMap。 </p>
<p>部分细节：  </p>
<ol>
<li>红黑树相比于AVL树，牺牲了部分平衡性，以换取删除&#x2F;插⼊操作时少量的旋转次数，整体来说，性能优于AVL<br>树，但是做了性能测试，发现优化了的AVL树和红黑树相比差不了太多。  </li>
<li>AVL树为了维护严苛的平衡条件，在破坏了平衡之后（插⼊、删除），需要执⾏旋转操作。共分为四种：左单<br>旋、先左后右旋、右单旋、先右后左旋。  </li>
<li>TreeMap内部无扩容的概念，因为使⽤的是树的链式存储结构  </li>
<li>⽀持范围查找，查找最近的元素  </li>
<li>以为内部是按照key进⾏排序的，所以不⽀持key为null  </li>
<li>排序依据，根据存放的对象是否实现Comprable接⼝。若实现了，则依据其⾃定义的compareTo⽅法，否者<br>需要⾃定义外部比较器（Comparator），若是都未实现，则报错。</li>
</ol>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先队列，是0个或者多个元素构成的集合，集合中按照某种排序方式（元素⾃身的权重）进⾏排序，不保证内部<br>元素整体有序，但是每次弹出的元素的优先级最高&#x2F;低。 </p>
<p>内部的数据结构是堆，因为堆底层的结构是完全⼆叉树，对于树的存储包含有链式存储或者顺序存储，<br>PriorityQueue使用的是顺序存储，所以使用的是Object[]数组，然后利用完全⼆叉树的性质，解决⽗⼦节点关系问<br>题。 </p>
<p>默认实现是小根堆</p>
<p><strong>实现细节</strong></p>
<ol>
<li>未指定初始化容量⼤小，默认为11，感觉对于底层使用数组实现的集合，默认⼤小的规定好要没有啥规律可<br>循  </li>
<li>扩容比其他集合多了⼀步，在数组长度 &lt; 64 时，扩容为原先的两倍+2，超过64时，扩容为原先的1.5倍，同<br>时做了放溢出处理，⽀持最⼤元素个数Integer.MAX_VALUE;  </li>
<li>删除和插⼊操作均会破坏当前的堆结果，所以每次都需要调用siftUp、siftDown动态调整  </li>
<li>插⼊操作是插⼊当前堆的末尾，调用siftUp，⾃底向上调整  </li>
<li>删除操作弹出堆顶元素，然后将堆最后⼀个元素置于堆顶，调用siftDown，⾃顶向下调整  </li>
<li>同样具有fast-fail机制</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h4><ol>
<li><p>HashMap 底层是⼀个数组  </p>
</li>
<li><p>数组中每个元素是⼀个单向链表（即，采用拉链法解决哈希冲突）</p>
</li>
</ol>
<p>  单链表的节点每个节点是 Node&lt;K, V&gt; 类型（⻅下源码）  </p>
<ol start="3">
<li>同⼀个单链表中所有 Node 的 hash值不⼀定⼀样，但是他们对应的数组下标⼀定⼀样</li>
</ol>
<p>  数组下标利用哈希函数&#x2F;哈希算法根据 hash值计算得到的  </p>
<ol start="4">
<li><p>HashMap 是数组和单链表的结合体  </p>
<ul>
<li>数组查询效率⾼，但是增删元素效率较低  </li>
<li>单链表在随机增删元素方⾯效率较⾼，但是查询效率较低  </li>
<li>HashMap 将⼆者结合起来，充分它们各⾃的优点</li>
</ul>
</li>
<li><p>HashMap 特点  </p>
<ul>
<li>无序、不可重复  </li>
<li>无序：因为不⼀定挂在那个单链表上了</li>
</ul>
</li>
<li><p>为什么不可重复？通过重写 equals 方法保证的</p>
</li>
</ol>
<h4 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="hljs-comment">     * by either of the constructors with arguments.</span><br><span class="hljs-comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The load factor used when none specified in constructor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment">     * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment">     * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment">     * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment">     * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment">     * shrinkage.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment">     * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment">     * between resizing and treeification thresholds.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Basic hash bin node, used for most entries.  (See below for</span><br><span class="hljs-comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br><br>        Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>HashMap默认初始化容量：16</p>
<ul>
<li>必须是2的次幂，主要是为了能够通过位运算获取key的索引位置，提升计算的效率</li>
<li>为了达到散列均匀，以便提高HashMap集合的存取效率</li>
</ul>
</li>
<li><p>HashMap默认加载因子：0.75f</p>
<ul>
<li>数组容量达到 $\frac{3}{4}$ 时，开始扩容</li>
</ul>
</li>
<li><p>扩容操作</p>
<ul>
<li>扩容的哈希表将拥有两倍的原容量，因为计算元素落在哪个位置的时候是 <code>(n-1)&amp;hash</code>，<code>n</code>为数组长度，这样计算更加高效</li>
<li></li>
</ul>
</li>
<li><p>JDK 8 之后，对 HashMap 底层数据结构（单链表）进行了改进</p>
<ul>
<li>如果单链表元素超过8个，则将单链表转变为红黑树，大前提是整个Node数组容量&gt;64；</li>
<li>如果红黑树节点数量小于6时，会将红黑树重新变为单链表</li>
</ul>
</li>
</ul>
<p><strong>put()方法</strong></p>
<ol>
<li><p>先将 key, value 封装到 Node 对象中   </p>
</li>
<li><p>底层会调用 key 的 hashCode() 方法得出 hash 值   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过哈希函数&#x2F;哈希算法，将 hash 值转换为数组的下标</p>
</li>
</ol>
<ul>
<li>如果下标位置上没有任何元素，就把 Node 添加到这个位置上；  </li>
<li>如果下标位置上有但链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进行 equals 比<br>较<ul>
<li>如果所有的 equals 方法返回都是 false，那么这个新节点 Node 将被添加到链表的末尾；  </li>
<li>如果其中有⼀个 equals 返回了 true，那么链表中对应的这个节点的 value 将会被新节点 Node 的<br>value 覆盖。（保证了不可重复）</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>HashMap 中允许 key 和 value 为 null，但是只能有⼀个（不可重复）</li>
<li>HashTable 中 key 和 value 都不允许为 null</li>
</ol>
</blockquote>
<p><strong>get()方法</strong></p>
<ol>
<li>先调用 key 的 hashCode() 方法得出 hash 值  </li>
<li>通过哈希函数&#x2F;哈希算法，将 hash 值转换为数组的下标  </li>
<li>通过数组下标快速定位到数组中的某个位置：</li>
</ol>
<ul>
<li>如果这个位置上什么也没有（没有链表），则返回 null；  </li>
<li>如果这个位置上有单链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进⾏ equals 比<br>较。   <ul>
<li>如果所有的 equals 方法返回都是 false，那么 get 方法返回 null；  </li>
<li>如果其中有⼀个 equals 返回了 true，那么这个节点的 value 便是我们要找的 value，此时 get 方<br>法最终返回这个要找的 value。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>放在 HashMap 中 key 的元素（或者放在 HashSet 中的元素）需要同时重写 hashCode() 和 equals() 方<br>法</li>
<li>重写 hashCode() 方法时要达到散列分布均匀<ul>
<li>如果 hashCode() 方法返回⼀个固定的值，那么 HashMap 底层则变成了⼀个单链表；</li>
<li>如果 hashCode() 方法所有返回的值都不同，此时 HashMap 底层则变成了⼀个数组</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么使用并发编程"><a href="#为什么使用并发编程" class="headerlink" title="为什么使用并发编程"></a>为什么使用并发编程</h3><ul>
<li>可以充分利用CPU的计算能力</li>
<li>方便业务拆分，提升应用性能</li>
</ul>
<h3 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h3><ul>
<li>内存泄露</li>
<li>上下文切换</li>
<li>线程安全</li>
<li>死锁</li>
</ul>
<h3 id="并发编程的三要素"><a href="#并发编程的三要素" class="headerlink" title="并发编程的三要素"></a>并发编程的三要素</h3><ul>
<li>原子性：指的是一个或多个操作要么执行成功，要么全部执行失败</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到</li>
<li>有序性：线程执行的顺序按照代码的先后顺序执行(处理器为了实现指令流水线，可能会对一些执行进行重排序)</li>
</ul>
<h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><ul>
<li>原子性问题：分多线程之间通过synchronized或使用锁lock</li>
<li>缓存导致的可见性问题：synchronized、volatile、LCOK，可以解决可见性问题</li>
<li>编译优化的有序性问题：Happens-Before规则</li>
</ul>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是 同时执行。 </li>
<li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。 </li>
<li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不 安全情况，也就不存在临界区的问题。</li>
</ul>
<h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ul>
<li>进程：一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程 </li>
<li>线程：进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。</li>
</ul>
<p>进程与线程的区别 </p>
<ul>
<li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 </li>
<li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 </li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共 同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 </li>
<li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的 </li>
<li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。 </li>
<li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>什么是线程安全？</strong></p>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>
<p><strong>如何实现线程安全？</strong></p>
<ul>
<li><p>第一种：<strong>互斥同步</strong></p>
<p><code>synchronized</code>锁</p>
<ul>
<li>普通同步方法，锁是当前的实例对象</li>
<li>静态同步方法，锁时当前类的Class对象</li>
<li>同步方法块，锁是<code>Synchronized</code>括号里匹配的对象</li>
</ul>
<p>如何实现：</p>
<p><code>synchronized</code>锁</p>
<ul>
<li><code>synchronized</code>经过编译之后，会在同步块的前后生成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，这两个字节码指令之后有一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。在执行<code>monitorenter</code>指令时，首先会尝试获取对象的锁，如果该对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加一。若获取对象失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放。</li>
<li><code>synchronized</code>用的锁是存放在对象头里面的，在jdk1.6之后，锁一共有四种状态：<ul>
<li><strong>无锁</strong>状态</li>
<li><strong>偏向锁</strong>状态（在对象头和栈帧中的锁记录存储偏向锁的线程id）</li>
<li><strong>轻量级锁</strong>状态（将对象头的markword复制到当前线程的栈帧的锁记录中，使用CAS操作将对象头中的markword指向栈帧的锁记录，如果成功，则线程就拥有了对象的锁。如果两个以上的线程争用一把锁的话，则膨胀为重量级说）</li>
<li><strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>第二种：<strong>JUC包的重入锁</strong></p>
<blockquote>
<p>在使用<code>synchronized</code>的时候，只能有一个线程可以获取对象的锁，其他线程就会进入阻塞状态，阻塞状态就会引起线程的挂起和唤醒，会带来很大的性能问题，所以就出现了非阻塞同步的实现方法</p>
</blockquote>
<p>先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，如果共享数据有争用，就采取补偿措施（不断地重试）。</p>
<p>CAS是实现非阻塞同步的计算机指令，它有三个操作数：内存位置，旧的预期值，新值，在执行CAS操作时，<strong>当且仅当内存地址的值符合旧的预期值的时候</strong>，才会用新值来更新内存地址的值，否则就不执行更新。</p>
<p>使用方法：使用JUC包下的整数原子类<code>decompareAndSet()</code>和<code>getAndIncrement()</code>方法</p>
<p>缺点 ：ABA 问题  版本号来解决</p>
<p>只能保证一个变量的原子操作，解决办法：使用AtomicReference类来保证对象之间的原子性。可以把多个变量放在一个对象里。</p>
</li>
<li><p>第三种：<strong>无同步方法</strong></p>
<p>线程本地存储：将共享数据的可见性范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题</p>
<p>使用<code>ThreadLocal</code>类</p>
<p>常见的使用场景：</p>
<ul>
<li>解决数据库连接</li>
<li><code>Session</code>管理等</li>
</ul>
</li>
</ul>
<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><ul>
<li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的 形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于 一次上下文切换。 </li>
<li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 </li>
<li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 </li>
<li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li>
</ul>
<h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul>
<li>互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等 待，直至占有资源的进程用毕释放。 </li>
<li>占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进 程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 </li>
<li>不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过 来。 </li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在 等B，B在等C，C在等A）</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812152510964.png" srcset="/img/loading.gif" lazyload alt="image-20220812152510964"></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812152523915.png" srcset="/img/loading.gif" lazyload alt="image-20220812152523915"></p>
<h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>CAS是CompareAndSwap的缩写，中文意思是比较并替换。</p>
<p>当要进行CAS操作时，先比较内存地址和原来预期的地址比较，如果相同，表示这块内存地址没有被修改，可以用新地址替换，否则说明该地址被修改了，取消替换操作。</p>
<ul>
<li>它的作用是可以将比较和交换转换为<strong>原子操作</strong>，这个原子操作直接由CPU保证，CAS可以保证共享变量赋值时的原子操作</li>
<li>是一种非阻塞算法的实现，可以在不使用锁的情况下实现多线程安全，是一种无锁算法</li>
</ul>
<p>缺点是：</p>
<ul>
<li>循环时间长开销大（自旋）<ul>
<li>如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能给CPU带来很大的开销</li>
<li>解决办法：破坏掉死循环，当超过一定时间或者一定次数时，退出</li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>当对一个共享变量操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性</li>
<li>解决方法：<ul>
<li>用锁来保证原子性</li>
<li>把多个共享变量合成一个共享变量来操作</li>
<li>封装成对象（JDK1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之前的原子性，可以把多个变量放到一个对象来进行CAS操作</li>
</ul>
</li>
</ul>
</li>
<li>ABA问题<ul>
<li>如果在内存地址V初次读取的值是A，并且在准备赋值的期间可能曾经被改为B，然后又改为A，在赋值前检查到仍然是A，这样CAS就会误认为它从来没有被修改过，这就是ABA问题</li>
<li>解决方法：<ul>
<li>可以使用带有标记的原子引用类<code>AtomicStampedReference</code>，可以通过控制变量值的版本来保证CAS的正确性，即在变量前面添加版本号，每次变量更新的时候把版本+1，这样变化过程A-B-A就变成1A-2B-3A</li>
<li>增加时间戳</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关于Java多线程的synchronized和ThreadLocal有了解过吗"><a href="#关于Java多线程的synchronized和ThreadLocal有了解过吗" class="headerlink" title="关于Java多线程的synchronized和ThreadLocal有了解过吗"></a>关于Java多线程的synchronized和ThreadLocal有了解过吗</h2><p>ThreadLocal<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java多线程同步之ThreadLocal与Synchromized](https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142^v39^pc_rank_v37&spm=1018.2226.3001.4187)">[1]</span></a></sup>和Synchronized都是为了解决多线程中相同变量的访问冲突问题，只是二者处理问题的思路和角度不同。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810161243255.png" srcset="/img/loading.gif" lazyload alt="image-20220810161243255"></p>
<p>简单的示例如下：两个线程分表获取了自己线程存放的变量，他们之间变量的获取并不会错乱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocaDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + localVar.get());<br>        <span class="hljs-comment">//清除本地内存中的本地变量</span><br>        localVar.remove();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_A&quot;</span>);<br>                print(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-comment">//打印本地变量</span><br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_B&quot;</span>);<br>                print(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ThreadLocal源码</strong></p>
<p>set()方法</p>
<ul>
<li>首先获取当前线程<code>thread</code>，并获取thread线程中的<code>ThreadLocalMap</code></li>
<li>如果当前线程的<code>ThreadLocalMap</code>不为空，直接更行value值，如果<code>map</code>为空，示例化<code>ThreadLocalMap</code>，并将value值初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">* InheritableThreadLocal.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  t the current thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the map</span><br><span class="hljs-comment">*/</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的<code>ThreadLocalMap</code>是什么，<code>CreateMap</code>又是什么，直接点击查看找到以下代码：</p>
<p>可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value</p>
<p><code>createMap</code>是直接调用<code>ThreadLocal</code>的构造方法，构造一个新的<code>ThreadLocalMap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br> <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">         * its main ref field as the key (which is always a</span><br><span class="hljs-comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">         * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">         * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            Object value;<br> <br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">* InheritableThreadLocal.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Construct a new map initially containing (firstKey, firstValue).</span><br><span class="hljs-comment">* ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="hljs-comment">* one when we have at least one entry to put in it.</span><br><span class="hljs-comment">*/</span><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>get()方法</p>
<ul>
<li>get方法同样和set方法一样，首先需要获取当前线程thread-t， 然后获取当前线程的threadlocals变量(ThreadLocalMap)</li>
<li>如果当前theadlocals变量不为空，将当前线程的引用this(ThreadLocal)作为键值获取value</li>
<li>如果当前threadlocals变量为空，需要对当前线程的threadlocals变量进行初始化，然后返回初始化值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns the value in the current thread&#x27;s copy of this</span><br><span class="hljs-comment">* thread-local variable.  If the variable has no value for the</span><br><span class="hljs-comment">* current thread, it is first initialized to the value returned</span><br><span class="hljs-comment">* by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the current thread&#x27;s value of this thread-local</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Variant of set() to establish initialValue. Used instead</span><br><span class="hljs-comment">* of set() in case user has overridden the set() method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the initial value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get the entry associated with key.  This method</span><br><span class="hljs-comment">* itself handles only the fast path: a direct hit of existing</span><br><span class="hljs-comment">* key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="hljs-comment">* designed to maximize performance for direct hits, in part</span><br><span class="hljs-comment">* by making this method readily inlinable.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p> remove方法</p>
<p>该方法就是将<code>ThreadLocal</code>对应的值从当前<code>Thread</code>中的<code>ThreadLocalMap</code>中删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Removes the current thread&#x27;s value for this thread-local</span><br><span class="hljs-comment">* variable.  If this thread-local variable is subsequently</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span><br><span class="hljs-comment">* reinitialized by invoking its &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method,</span><br><span class="hljs-comment">* unless its value is &#123;<span class="hljs-doctag">@linkplain</span> #set set&#125; by the current thread</span><br><span class="hljs-comment">* in the interim.  This may result in multiple invocations of the</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@code</span> initialValue&#125; method in the current thread.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p>ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。</p>
</blockquote>
<p>ThreadLocal常见使用场景</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望被多线程共享</li>
</ul>
<p>例如</p>
<ul>
<li><p>存储用户Session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadSession</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InfrastructureException &#123;<br>        <span class="hljs-type">Session</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Session) threadSession.get();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>                s = getSessionFactory().openSession();<br>                threadSession.set(s);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (HibernateException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfrastructureException</span>(ex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>数据跨层传输</p>
</li>
</ul>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Java中的synchronized，通过使⽤内置锁，来实现对共享变量的同步操作，进⽽解决了对共享变量操作的原⼦性、<br>保证了其他线程对共享变量的可⻅性、有序性，从⽽确保了并发情况下的线程安全。 同时synchronized是可重⼊的锁，避免了同⼀个线程重复请求⾃身已经获取的锁时出现死锁问题（请求于保持、不可剥夺感觉都有体现）</p>
<h4 id="Synchronized的三种用法"><a href="#Synchronized的三种用法" class="headerlink" title="Synchronized的三种用法"></a>Synchronized的三种用法</h4><p><strong>1 普通方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        &#125;<br>        System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        SynchronizedTest t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        SynchronizedTest t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t1.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面这个代码我们new了两个不同的对象。打印结果如下。线程2并没有等线程1执行完成后才执行，说明对于普通方法，如果是不同的对象实例锁是不起作用的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程2开始执行<br>线程2执行完毕<br>线程1执行完毕<br></code></pre></td></tr></table></figure>

<p>将代码改为一个实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        &#125;<br>        System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        SynchronizedTest t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程1执行完毕<br>线程2开始执行<br>线程2执行完毕<br></code></pre></td></tr></table></figure>

<p>可以看到同一个对象实例的时候，第二个线程只等第一个线程执行完成后才开始执行</p>
<p><strong>2 静态同步方法</strong></p>
<p>对于静态同步方法来说，锁的是<strong>当前类的<code>Class</code>对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        &#125;<br>        System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                SynchronizedTest.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                SynchronizedTest.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程1执行完毕<br>线程2开始执行<br>线程2执行完毕<br></code></pre></td></tr></table></figure>

<p>只用第一个线程执行完成后才开始执行第二个线程</p>
<p><strong>3 同步方法块</strong></p>
<p>对于同步方法块来说，锁的是<code>synchronized</code>括号里配置的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>       Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span>(o.getClass())&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        SynchronizedTest t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        SynchronizedTest t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t1.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程1执行完毕<br>线程2开始执行<br>线程2执行完毕<br></code></pre></td></tr></table></figure>

<p>第一个线程执行完成后才开始执行第二个线程</p>
<h4 id="Synchronized是一个重量级锁"><a href="#Synchronized是一个重量级锁" class="headerlink" title="Synchronized是一个重量级锁"></a>Synchronized是一个重量级锁</h4><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现<strong>线程之间的切换需要从用户态转换到核心态</strong>，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。</p>
<h4 id="Synchronized底层实现原理"><a href="#Synchronized底层实现原理" class="headerlink" title="Synchronized底层实现原理"></a>Synchronized底层实现原理</h4><p>同步方法通过<code>ACC_SYNCHRONIZED </code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。</p>
<p>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。每个对象自身维护着一个被加锁次数的计数器，当计数器不为0时，只有获得锁的线程才能再次获得锁</p>
<h4 id="Synchronized锁存储位置"><a href="#Synchronized锁存储位置" class="headerlink" title="Synchronized锁存储位置"></a>Synchronized锁存储位置</h4><p>Synchronized用的锁是存在java的对象头里面的。一个对象在new出来之后再内存中主要分为4个部分：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925143830445.png" srcset="/img/loading.gif" lazyload alt="image-20220925143830445"></p>
<p>Mark Word：存储了对象的hashCode、GC信息、锁信息三部分。这部分占8字节。</p>
<p>Class Pointer：存储了指向类对象信息的指针。在64位JVM上有一个压缩指针选项-ClassPointer指针：-XX:+UseCompressedClassPointers 为4字节 不开启为8字节。默认是开启的。</p>
<p>实例数据(instance data)：记录了对象里面的变量数据。引用类型：-XX:+UseCompressedOops 为4字节 不开启为8字节 Oops Ordinary Object Pointers</p>
<p>Padding：作为对齐使用，对象在64位服务版本中，规定对象内存必须要能被8字节整除，如果不能整除，那么久靠对齐来不。举个例子：new出了一个对象，内存只占用18字节，但是规定要能被8整除，所以padding&#x3D;6</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925145308146.png" srcset="/img/loading.gif" lazyload alt="image-20220925145308146"></p>
<h4 id="Synchronized锁的升级过程"><a href="#Synchronized锁的升级过程" class="headerlink" title="Synchronized锁的升级过程"></a>Synchronized锁的升级过程</h4><p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了 “偏向锁” 和 “轻量级锁”：锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。</p>
<p><strong>偏向锁</strong>：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中记录存储锁偏向的线程ID，以后该线程在进入同步块时先判断对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果存在就直接获取锁。</p>
<p><strong>轻量级锁</strong>：当其他线程尝试竞争偏向锁时，锁升级为轻量级锁。线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，标识其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p><strong>重量级锁</strong>：锁在原地循环等待的时候，是会消耗CPU资源的。所以自旋必须要有一定的条件控制，否则如果一个线程执行同步代码块的时间很长，那么等待锁的线程会不断的循环反而会消耗CPU资源。默认情况下锁自旋的次数是10 次，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。10次后如果还没获取锁，则升级为重量级锁。</p>
<p><strong>内置锁</strong></p>
<p>在Java中，每个对象都有⼀把锁，放置于对象头中，⽤于记录当前对象被哪个线程所持有。<br>相对于实例数据，对象头属于额外开销，所以被设计的极⼩来提⾼效率（⼀个对象在堆中的分布：对象头、实例数<br>据、对⻬填充）。<br>对象头中的markword更加体现了这⼀点。markword⾮结构化的，这样在不同的锁状态下，能够复⽤相同的bit<br>位。markword中就有存储锁的信息的部分。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810155913925.png" srcset="/img/loading.gif" lazyload alt="image-20220810155913925"></p>
<p>Synchronized是Java保留关键字，通过线程等待，牺牲时间来解决访问冲突。依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程的访问变量，此时被用作锁机制的变量被多个线程共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlConnectionUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlPool instance=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SqlConnection <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>            instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPool</span>();<br>        <span class="hljs-keyword">return</span> instance.getSqlConnection();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="ThreadLocal和Synchronized的区别"><a href="#ThreadLocal和Synchronized的区别" class="headerlink" title="ThreadLocal和Synchronized的区别"></a>ThreadLocal和Synchronized的区别</h3><p>ThreadLocal<T>其实是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。</p>
<p>但是ThreadLocal与synchronized有本质的区别：</p>
<p>1、Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p>
<p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</p>
<p>而ThreadLoal却正好相反，它用于在多个线程间通信时能够获得数据共享。</p>
<blockquote>
<p>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</p>
</blockquote>
<h3 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁(ReentrantLock)"></a>可重入锁(ReentrantLock)</h3><p>ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型</p>
<p><strong>公平锁</strong></p>
<p>可重入锁：就是一个线程在获取了锁之后，再次去获取同一个锁，这时候仅仅是把状态值进行累加</p>
<p>如果线程释放了一次锁，状态值减1。只有线程完全释放锁，状态值减到0，其他线程才有机会获取锁。</p>
<ul>
<li>状态：<code>volatile int state</code></li>
<li>获取锁线程：<code>Thread</code></li>
<li>排队队列：<code>Node</code>双向队列</li>
</ul>
<p><strong>非公平锁</strong></p>
<p>非公平锁时要唤醒阻塞的线程时，其他的线程抢占锁，阻塞的线程只能继续休眠</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池优点"><a href="#线程池优点" class="headerlink" title="线程池优点"></a>线程池优点</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。 </p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用‘</li>
</ul>
<h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入 不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Creates a new &#123;<span class="hljs-doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span><br><span class="hljs-comment">* parameters and default thread factory and rejected execution handler.</span><br><span class="hljs-comment">* It may be more convenient to use one of the &#123;<span class="hljs-doctag">@link</span> Executors&#125; factory</span><br><span class="hljs-comment">* methods instead of this general purpose constructor.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span><br><span class="hljs-comment">*        if they are idle, unless &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span><br><span class="hljs-comment">*        pool</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> keepAliveTime when the number of threads is greater than</span><br><span class="hljs-comment">*        the core, this is the maximum time that excess idle threads</span><br><span class="hljs-comment">*        will wait for new tasks before terminating.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> unit the time unit for the &#123;<span class="hljs-doctag">@code</span> keepAliveTime&#125; argument</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> workQueue the queue to use for holding tasks before they are</span><br><span class="hljs-comment">*        executed.  This queue will hold only the &#123;<span class="hljs-doctag">@code</span> Runnable&#125;</span><br><span class="hljs-comment">*        tasks submitted by the &#123;<span class="hljs-doctag">@code</span> execute&#125; method.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> workQueue&#125; is null</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>    <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相关参数的说明</p>
<ul>
<li>corePoolSize 核心线程数量 </li>
<li>maximumPoolSize 最大线程数量 </li>
<li>keepAliveTime 线程保持时间，N个时间单位 unit 时间单位（比如秒，分） </li>
<li>workQueue 阻塞队列 </li>
<li>threadFactory 线程工厂 </li>
<li>handler 线程池拒绝策略</li>
</ul>
<h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p>提交一个任务到线程池中，线程池的处理流程如下：</p>
<ul>
<li>判断<strong>线程池里的核心线程</strong>是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li>
<li>线程池判断<strong>工作队列</strong>是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925145950776.png" srcset="/img/loading.gif" lazyload alt="image-20220925145950776"></p>
<h3 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h3><p><strong>execute方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//由它可以获取到当前有效的线程数和线程池的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 1.获取当前正在运行线程数是否小于核心线程池，是则新创建一个线程执行任务，否则将任务放到任务队列中</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="hljs-comment">// 标识行 &lt;------</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>)) <span class="hljs-comment">//在addWorker中创建工作线程执行任务</span><br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 2.当前核心线程池中全部线程都在运行workerCountOf(c) &gt;= corePoolSize，所以此时将线程放到任务队列中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    		<span class="hljs-comment">//线程池是否处于运行状态，且是否任务插入任务队列成功</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            <span class="hljs-comment">//线程池是否处于运行状态，如果不是则使刚刚的任务出队</span><br>            reject(command); <span class="hljs-comment">//抛出RejectedExceptionException异常</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    <span class="hljs-comment">// 3.插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常</span><br>        reject(command);<span class="hljs-comment">//抛出RejectedExceptionException异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>addWorker方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br><span class="hljs-comment">/*首先会再次检查线程池是否处于运行状态，核心线程池中是否还有空闲线程，都满足条件过后则会调用compareAndIncrementWorkerCount先将正在运行的线程数+1，数量自增成功则跳出循环，自增失败则继续从头继续循环*/</span><br>　　...<br>　　<span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>　　　　<span class="hljs-keyword">break</span> retry;<br>　　...<br><span class="hljs-comment">/*正在运行的线程数自增成功后则将线程封装成工作线程Worker*/</span><br>　　<span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　　<span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　　<span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>　　<span class="hljs-keyword">try</span> &#123;<br>　　　　<span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;        <span class="hljs-comment">//全局锁</span><br>　　　　w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woker</span>(firstTask);        <span class="hljs-comment">//将线程封装为Worker工作线程</span><br>　　　　<span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>　　　　<span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>　　　　　　mainLock.lock();    <span class="hljs-comment">//获取全局锁</span><br><span class="hljs-comment">/*当持有了全局锁的时候，还需要再次检查线程池的运行状态等*/</span><br>　　　　　　<span class="hljs-keyword">try</span> &#123;<br>　　　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> clt.get();<br>　　　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);        <span class="hljs-comment">//线程池运行状态</span><br>　　　　　　　　<span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>))&#123;        <span class="hljs-comment">//线程池处于运行状态，或者线程池关闭且任务线程为空</span><br>　　　　　　　　　　<span class="hljs-keyword">if</span> (t.isAlive())    <span class="hljs-comment">//线程处于活跃状态，即线程已经开始执行或者还未死亡，正确的应线程在这里应该是还未开始执行的</span><br>　　　　　　　　　　　　<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>　　　　　　　　　　workers.add(w);    <span class="hljs-comment">//private final HashSet&lt;Worker&gt; wokers = new HashSet&lt;Worker&gt;();包含线程池中所有的工作线程，只有在获取了全局的时候才能访问它。将新构造的工作线程加入到工作线程集合中</span><br>　　　　　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> worker.size();    <span class="hljs-comment">//工作线程数量</span><br>　　　　　　　　　　<span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>　　　　　　　　　　　　largestPoolSize = s;<br>　　　　　　　　　　workerAdded = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//新构造的工作线程加入成功</span><br>　　　　　　　　&#125;<br>　　　　　　&#125; <span class="hljs-keyword">finally</span> &#123;<br>　　　　　　　　mainLock.unlock();<br>　　　　　　&#125;<br>　　 　　　　<span class="hljs-keyword">if</span> (workerAdded) &#123;<br>　　　　　　　　t.start();    <span class="hljs-comment">//在被构造为Worker工作线程，且被加入到工作线程集合中后，执行线程任务，注意这里的start实际上执行Worker中run方法，所以接下来分析Worker的run方法</span><br>　　　　　　　　workerStarted = <span class="hljs-literal">true</span>;<br>　　　　　　&#125;<br>　　　　&#125;<br>　　&#125; <span class="hljs-keyword">finally</span> &#123;<br>　　　　<span class="hljs-keyword">if</span> (!workerStarted)    <span class="hljs-comment">//未能成功创建执行工作线程</span><br>　　　　　　addWorkerFailed(w);    <span class="hljs-comment">//在启动工作线程失败后，将工作线程从集合中移除</span><br>　　&#125;<br>　　<span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Worker</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ThreadPoolExecutor$Worker，它继承了AQS，同时实现了Runnable，所以它具备了这两者的所有特性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>　　<span class="hljs-keyword">final</span> Thread thread;<br>　　Runnable firstTask;<br>　　<span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable firstTask)</span> &#123;<br>　　　　setState(-<span class="hljs-number">1</span>);    <br>　　　　<span class="hljs-comment">//设置AQS的同步状态为-1，禁止中断，直到调用runWorker</span><br>　　　　<span class="hljs-built_in">this</span>.firstTask = firstTask;<br>　　　　<span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);   <br>　　　　 <span class="hljs-comment">//通过线程工厂来创建一个线程，将自身作为Runnable传递传递</span><br>　　&#125;<br>　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>　　　　runWorker(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">//运行工作线程</span><br>　　&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>worker</code>在执行完任务后，还会通过<code>getTask</code>方法循环获取工作队里的任务来执行</p>
</blockquote>
<h2 id="线程池案例"><a href="#线程池案例" class="headerlink" title="线程池案例"></a>线程池案例</h2><p><strong>创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingDeque;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedBlockingDeque&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">10</span>,<br>                <span class="hljs-number">60</span>,<br>                TimeUnit.SECONDS,<br>                queue<br>        );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExample</span>(), <span class="hljs-string">&quot;Thread&quot;</span> + i));<br>            System.out.println(<span class="hljs-string">&quot;线程中活跃的线程数：&quot;</span> + threadPool.getPoolSize());<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----&gt;队伍中阻塞的线程数：&quot;</span> + queue.size());<br>            &#125;<br>        &#125;<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行的结果是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">线程中活跃的线程数：1<br>线程中活跃的线程数：2<br>线程中活跃的线程数：3<br>线程中活跃的线程数：4<br>线程中活跃的线程数：5<br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：1</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：2</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：3</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：4</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：6<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：7<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：8<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：9<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：10<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@5cad8086[Running, pool size = 10, active threads = 10, queued tasks = 5, completed tasks = 0]<br>	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)<br>	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)<br>	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)<br>	at com.madao33.ThreadPoolExample.main(ThreadPoolExample.java:27)<br><br></code></pre></td></tr></table></figure>

<p>从结果可以观察出：</p>
<ul>
<li>创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。</li>
<li>我们通过queue.size()的方法来获取工作队列中的任务数。</li>
<li>刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。</li>
</ul>
<p>当然，为了达到需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放</p>
<p><strong>饱和策略</strong></p>
<p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是<code>AbortPolicy</code>，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：</p>
<ul>
<li><code>AbortPolicy</code>：直接抛出异常</li>
<li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li><code>DiscardPolicy</code>：不处理，丢弃掉。</li>
</ul>
<p>我们现在用第四种策略来处理上面的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingDeque;<br><span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionHandler;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedBlockingDeque&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy();<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">10</span>,<br>                <span class="hljs-number">60</span>,<br>                TimeUnit.SECONDS,<br>                queue,<br>                handler<br>        );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExample</span>(), <span class="hljs-string">&quot;Thread&quot;</span> + i));<br>            System.out.println(<span class="hljs-string">&quot;线程中活跃的线程数：&quot;</span> + threadPool.getPoolSize());<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----&gt;队伍中阻塞的线程数：&quot;</span> + queue.size());<br>            &#125;<br>        &#125;<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里采用了丢弃策略后，就没有再抛出异常，而是直接丢弃。在某些重要的场景下，可以采用记录日志或者存储到数据库中，而不应该直接丢弃。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">线程中活跃的线程数：1<br>线程中活跃的线程数：2<br>线程中活跃的线程数：3<br>线程中活跃的线程数：4<br>线程中活跃的线程数：5<br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：1</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：2</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：3</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：4</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：6<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：7<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：8<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：9<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：10<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：10<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br><br>Process finished with exit code 0<br><br></code></pre></td></tr></table></figure>

<p><strong>Callable、Future、FutureTash</strong></p>
<p><code>Callable</code>与<code>Future</code>是在JAVA的后续版本中引入进来的，<code>Callable</code>类似于<code>Runnable</code>接口，实现<code>Callable</code>接口的类与实现<code>Runnable</code>的类都是可以被线程执行的任务</p>
<ul>
<li><code>Callable</code>是<code>Runnable</code>封装的异步运算任务。</li>
<li><code>Future</code>用来保存<code>Callable</code>异步运算的结果</li>
<li><code>FutureTask</code>封装<code>Future</code>的实体类</li>
</ul>
<p><code>Callable</code>与<code>Runnbale</code>的区别：</p>
<ul>
<li><code>Callable</code>定义的方法是call，而<code>Runnable</code>定义的方法是run<code>。</code></li>
<li><code>call</code>方法有返回值，而<code>run</code>方法是没有返回值的。</li>
<li><code>call</code>方法可以抛出异常，而<code>run</code>方法不能抛出异常。</li>
</ul>
<p><strong>Future</strong></p>
<p>future表示异步计算的结果，提供了以下方法，主要是判断任务是否完成，中断任务，获取任务执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>FutureTask</strong></p>
<p>可取消的异步计算，此类提供了对Future的基本实现，仅在计算完成时才能获取结果，如果计算尚未完成，则阻塞get方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt;<br></code></pre></td></tr></table></figure>

<p>FutureTask不仅实现了Future接口，还实现了Runnable接口，所以不仅可以将FutureTask当成一个任务交给Executor来执行，还可以通过Thread来创建一个线程。</p>
<p><strong>Callable与FutureTask案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;callable do something&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallableTask</span>();<br>        FutureTask&lt;Integer&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(callable);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(future);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//尝试取消对此任务的执行</span><br>        future.cancel(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//判断是否在任务正常完成前取消</span><br>        System.out.println(<span class="hljs-string">&quot;future is cancel:&quot;</span> + future.isCancelled());<br>        <span class="hljs-keyword">if</span>(!future.isCancelled())<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;future is cancelled&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//判断任务是否已完成</span><br>        System.out.println(<span class="hljs-string">&quot;future is done:&quot;</span> + future.isDone());<br>        <span class="hljs-keyword">if</span>(!future.isDone())<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;future get=&quot;</span> + future.get());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//任务已完成</span><br>            System.out.println(<span class="hljs-string">&quot;task is done&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">callable do something<br>future is cancel:true<br>future is done:true<br>task is done<br></code></pre></td></tr></table></figure>

<p><strong>Callable与Future</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;进入call方法，开始休眠，休眠时间为： &quot;</span> + System.currentTimeMillis());<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;今天停电&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableThread</span>();<br>        Future&lt;String&gt; fu = es.submit(call);<br>        es.shutdown();<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">&quot;主线程休眠5秒，当前时间&quot;</span> + System.currentTimeMillis());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> fu.get();<br>        System.out.println(<span class="hljs-string">&quot;Future已拿到数据，str=&quot;</span> + str + <span class="hljs-string">&quot;;当前时间为：&quot;</span> + System.currentTimeMillis());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行的结果是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">进入call方法，开始休眠，休眠时间为： 1664097924448<br>主线程休眠5秒，当前时间1664097929462<br>Future已拿到数据，str=今天停电;当前时间为：1664097934459<br></code></pre></td></tr></table></figure>

<p>这里的future是直接扔到线程池里面去执行的。由于要打印任务的执行结果，所以从执行结果来看，主线程虽然休眠了5s，但是从Call方法执行到拿到任务的结果，这中间的时间差正好是10s，说明get方法会阻塞当前线程直到任务完成。</p>
<p>通过FutureTask也可以达到同样的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>      Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableThread</span>();<br>      FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(call);<br>      es.submit(task);<br>      es.shutdown();<br>      Thread.sleep(<span class="hljs-number">5000</span>);<br>      System.out.println(<span class="hljs-string">&quot;主线程等待5秒，当前时间为：&quot;</span> + System.currentTimeMillis());<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> task.get();<br>      System.out.println(<span class="hljs-string">&quot;Future已拿到数据，str=&quot;</span> + str + <span class="hljs-string">&quot;;当前时间为：&quot;</span> + System.currentTimeMillis());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以通过以上代码的组合，得到这样一个应用场景</p>
<p>如有一种场景中，方法A返回一个数据需要10s,A方法后面的代码运行需要20s，但是这20s的执行过程中，只有后面10s依赖于方法A执行的结果。如果与以往一样采用同步的方式，势必会有10s的时间被浪费，如果采用前面两种组合，则效率会提高：</p>
<ul>
<li>先把A方法的内容放到Callable实现类的call()方法中</li>
<li>在主线程中通过线程池执行A任务</li>
<li>执行后面方法中10秒不依赖方法A运行结果的代码</li>
<li>获取方法A的运行结果，执行后面方法中10秒依赖方法A运行结果的代码</li>
</ul>
<p>这样代码执行效率一下子就提高了，程序不必卡在A方法处。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="说一下你对Java虚拟机的理解"><a href="#说一下你对Java虚拟机的理解" class="headerlink" title="说一下你对Java虚拟机的理解"></a>说一下你对Java虚拟机的理解</h2><h3 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802212445262.png" srcset="/img/loading.gif" lazyload></p>
<p>方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p>
<ul>
<li>Java堆（Heap），是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li>
<li>方法区（Method Area），方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li>
<li>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li>
</ul>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811130946227.png" srcset="/img/loading.gif" lazyload alt="image-20220811130946227"></p>
<ul>
<li>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li>
<li>加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。</li>
<li>最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ul>
<p>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811131032798.png" srcset="/img/loading.gif" lazyload alt="image-20220811131032798"></p>
<ul>
<li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li>
<li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li>
<li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、ParallelScavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802213622688.png" srcset="/img/loading.gif" lazyload alt="image-20220802213622688"></p>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
<li>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<ul>
<li>优点：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小。</li>
<li>缺点：浮动垃圾目前使用的非常少，真正普及还是需要写时间的。</li>
</ul>
</li>
</ul>
<p><strong>新生代收集器</strong>：Serial、ParNew、Parallel Scavenge</p>
<p><strong>老年代收集器</strong>：CMS、Serial Old、Parallel Old</p>
<p><strong>整堆收集器</strong>：G1，ZGC(因为不涉年代不在图中)。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>是最基础的收集器，在JDK1.3.1之前是HotSpot虚拟机新生代收集器的唯一选择。他是一个单线程工作的收集器，其单线程的意义不是说它只会使用一个处理器或者一条收集线程去完成垃圾手机工作，更重要的腔调它在进行垃圾收集的时候，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220919171855626.png" srcset="/img/loading.gif" lazyload alt="image-20220919171855626"></p>
<ul>
<li>在客户端模式下的<strong>默认新生代收集器</strong>，简单高效</li>
<li>在内存有限的情况下，是所有收集器里<strong>额外内存消耗最小</strong>的</li>
<li>单核处理器中或者处理器核心数较少的环境中，<strong>没有线程交互的开销</strong></li>
</ul>
<blockquote>
<p>Stop The World：垃圾回收算法在进行垃圾回收的时候暂停用户线程，导致的卡顿，感觉就像世界停止了一样</p>
</blockquote>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的<strong>多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：<code>-XX：SurvivorRatio</code>、<code>-XX：PretenureSizeThreshold</code>、<code>-XX：HandlePromotionFailure</code>等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220919173206845.png" srcset="/img/loading.gif" lazyload alt="image-20220919173206845"></p>
<p>除了支持新生代多线程并行收集外，和Serial收集器没有太多创新之处，但是是不少运行在服务端的HotSpot虚拟机，尤其是JDK7之前首选的新生代收集器</p>
<p>同时，ParNew也可以和CMS收集器配合工作，CMS是一个老年代收集器，<strong>CMS激活后默认的新生代收集器就是ParNew收集器</strong></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器也是一款<strong>新生代收集器</strong>，它同样是基于<strong>标记-复制</strong>算法实现的收集器，也是能够并行收集的多线程收集器，它的目标是达到一个可控制的吞吐量（Throughtput)，所谓的吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值<br>$$<br>吞吐量&#x3D;\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}<br>$$<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是</p>
<ul>
<li>控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数</li>
<li>设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220920155351376.png" srcset="/img/loading.gif" lazyload alt="image-20220920155351376"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的<strong>老年代</strong>版本，支持多线程并发收集，基于<strong>标记-整理</strong>算法实现</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220920155540697.png" srcset="/img/loading.gif" lazyload alt="image-20220920155540697"></p>
<p>配合新生代Parallel Scavenge收集器使用，在注重吞吐量或者处理器资源较为稀缺的组合，可以优先考虑Parallel Scavenge</p>
<h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是基于<strong>标记-清除</strong>算法实现的，只会回收老年代和永久代，整个过程包含四个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220920203116064.png" srcset="/img/loading.gif" lazyload alt="image-20220920203116064">其中<strong>初始标记、重新标记</strong>这两个步骤仍然需要“Stop The World”。</p>
<ul>
<li><strong>初始标记</strong>仅仅只是标记一下<strong>GCRoots能直接关联</strong>到的对象，速度很快；</li>
<li><strong>并发标记</strong>阶段就是<strong>从GC Roots的直接关联对象开始遍历整个对象图</strong>的过程，这个过程<strong>耗时较长</strong>但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li>而<strong>重新标记</strong>阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</li>
<li>最后是<strong>并发清除</strong>阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
<blockquote>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</p>
</blockquote>
<p>虽说CMS有：<strong>并发收集、低停顿</strong>的优点，但是还是有一些缺点：</p>
<ul>
<li>首先，CMS收集器<strong>对处理器资源非常敏感</strong>。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）&#x2F;4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。</li>
<li>然后，由于<strong>CMS收集器无法处理“浮动垃圾”（Floating Garbage）</strong>，有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li>
<li>因为是基于<strong>标记-清除</strong>算法实现的收集器，所以收集结束会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC。</li>
</ul>
<h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式</p>
<p>G1是一款主要面向服务端应用的垃圾收集器。</p>
<p>G1开创的基于Region的堆内存布局，G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个<strong>大小相等的独立区域（Region）</strong>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够<strong>对扮演不同角色的Region采用不同的策略去处理</strong>，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p>
<p>Region中还有一类<strong>特殊的Humongous区域，专门用来存储大对象</strong>。G1认为只要大小<strong>超过了一个Region容量一半</strong>的对象即可判定为大对象。</p>
<p>Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定，取值范围为1MB～32MB，且应为2的N次幂</p>
<p>超过了整个Region容量的超级大对象，将会被<strong>存放在N个连续的Humongous Region之中</strong>，G1的大多数行为都把Humongous Region<strong>作为老年代</strong>的一部分来进行看待</p>
<p>具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台<strong>维护一个优先级列表</strong>，每次根据用户设定<strong>允许的收集停顿时间</strong>（使用参数<code>-XX：MaxGCPauseMillis</code>指定，默认值是200毫秒），<strong>优先处理回收价值收益最大的那些Region</strong>，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220922112100355.png" srcset="/img/loading.gif" lazyload alt="image-20220922112100355"></p>
<ul>
<li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记（Final Marking）</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<blockquote>
<ul>
<li>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，它的目标是在延迟可控的情况下获得尽可能高的吞吐量</li>
<li>在<strong>小内存应用上CMS的表现大概率仍然要会优于G1</strong>，而在<strong>大内存应用上G1则大多能发挥其优势</strong>，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</li>
</ul>
</blockquote>
<h3 id="ZGC垃圾回收器"><a href="#ZGC垃圾回收器" class="headerlink" title="ZGC垃圾回收器"></a>ZGC垃圾回收器</h3><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="排序算法了解过吗，可以详细介绍一下吗"><a href="#排序算法了解过吗，可以详细介绍一下吗" class="headerlink" title="排序算法了解过吗，可以详细介绍一下吗"></a>排序算法了解过吗，可以详细介绍一下吗</h2><p>了解过一点，例如冒泡排序和选择排序</p>
<ul>
<li><p>冒泡排序：每一轮循环都是和相邻的元素比较，然后一步步的将最小的元素或者最大的元素排在前面，时间复杂度是 $O(n^2)$</p>
</li>
<li><p>选择排序：每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。每一趟通过不断地比较交换来使得首元素为当前最小，交换是一个比较耗时间的操作，我们可以通过设置一个值来记录较小元素的下标，循环结束后存储的就是当前最小元素的下标，这时再进行交换就可以了。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220802214609664.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[a];<br>	arr[a] = arr[b];<br>	arr[b] = tmp;<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">SimpleSelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span><br>&#123;<br>	<span class="hljs-type">int</span> min, len = arr.length;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len - <span class="hljs-number">1</span>;i++)<br>	&#123;<br>		min = i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;j &lt; len;j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (arr[min] &gt; arr[j])<br>			&#123;<br>				min = j;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (min != i)<br>		&#123;<br>			Swap(arr,min,i);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="写一下反转链表的代码，伪代码即可"><a href="#写一下反转链表的代码，伪代码即可" class="headerlink" title="写一下反转链表的代码，伪代码即可"></a>写一下反转链表的代码，伪代码即可</h2><p>了解的链表反转有两种方法：</p>
<ul>
<li>第一种是<strong>递归</strong>，递归的写法是需要明确两个条件：边界条件和递推关系<ul>
<li>先说一下<strong>递推关系</strong>：假设递归的顺序是先调整后面的结点，当前结点的后续结点都已经反转了，只需要反转当前结点和其后继结点的关系，这时候只需要将当前结点的后继结点的后继指向当前结点，即<code>cur.next.next = cur</code>，然后将当前结点的后继变为<code>null</code>，防止循环链表的出现，然后返回反转之后的头结点</li>
<li><strong>边界条件</strong>则是递归到最后一个节点，同时加上判断链表头结点是否为空的判断</li>
</ul>
</li>
<li>另一种就是<strong>双指针</strong>，双指针比起递归来说要更好理解一些<ul>
<li>首先设置两个指针<code>pre, cur</code>，分别表示前一个结点和当前结点</li>
<li>先设置一个临时变量保存当前结点的后继<code>Node temp = cur.next</code>，然后将当前结点的后继指向前一个结点<code>cur.next = pre</code>，这样实现了后继关系的反转，然后判断下一个，这时候的<code>pre = cur; cur = temp</code></li>
<li>反转结束之后返回<code>pre</code>为反转后链表的头结点</li>
</ul>
</li>
</ul>
<p>具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduInterview</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归实现链表反转</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 链表头结点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回反转后链表的头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newroot</span> <span class="hljs-operator">=</span> reverseLinkedList(root.next);<br>        root.next.next = root;<br>        root.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newroot;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList2</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过数组构建链表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> head 链表头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">constructLinkedList</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(num);<br>            temp.next = <span class="hljs-literal">null</span>;<br>            cur.next = temp;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> constructLinkedList(nums);<br><span class="hljs-comment">//        Node reversed2 = reverseLinkedList(root);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">reversed3</span> <span class="hljs-operator">=</span> reverseLinkedList2(root);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义链表结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">public</span> Node next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79980618)">[5]</span></a></sup>，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:</p>
<ol>
<li>每个节点都有红色或黑色</li>
<li>树的根始终是黑色的 (黑土地孕育黑树根， )</li>
<li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，<strong>并没有说不能出现连续的黑色节点</strong>）</li>
<li>从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</li>
</ol>
<p>一棵典型的红黑树如下图所示</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803220406437.png" srcset="/img/loading.gif" lazyload alt="image-20220803220406437"></p>
<p>关于红黑树的左旋右旋操作过多，后续再来详细记载，可以先查看这篇文章</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014454538/article/details/120120216">红黑树详解_晓之木初的博客-CSDN博客_红黑树</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="有了解过Java的设计模式吗，手写一个单例模式"><a href="#有了解过Java的设计模式吗，手写一个单例模式" class="headerlink" title="有了解过Java的设计模式吗，手写一个单例模式"></a>有了解过Java的设计模式吗，手写一个单例模式</h2><p>了解过一些，设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它<br>不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>单例模式、代理模式、模板方法模式、装饰器模式、工厂模式、责任链模式、观察者模式、原型模<br>式。</p>
<p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。<br>优点：不会频繁地创建和销毁对象，浪费系统资源。</p>
<p>单例模式有很多种的写法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[我给面试官讲解了单例模式后，他对我竖起了大拇指！](https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142^v39^pc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187)">[2]</span></a></sup>：</p>
<ul>
<li><p><strong>饿汉式单例模式</strong>的写法：线程安全</p>
<p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创建</strong>。</p>
<p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220803141933702.png" srcset="/img/loading.gif" lazyload alt="image-20220803141933702"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>懒汉式单例模式</strong>的写法：非线程安全</p>
<p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象，否则则先执行实例化操作。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803141920683.png" srcset="/img/loading.gif" lazyload alt="image-20220803141920683"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个单例模式是较为简单的写法，写完之后，面试官问如果在多线程的任务下，很多线程请求，可能会出现线程不安全的情况，都到达<code>if(singleton == null)</code>，可能会有复数个线程创建了不同的实例</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803142100572.png" srcset="/img/loading.gif" lazyload alt="image-20220803142100572"></p>
<p>如何解决这个问题，这个时候需要考虑加锁，也就是下面这个方式</p>
</li>
<li><p><strong>双检锁单例模式</strong>的写法：线程安全</p>
<p>一般在懒汉单例非线程的代码上进行修改有两种简便的方式：一种是给对象加锁，一种是给方法加锁</p>
<ul>
<li><p><strong>对象上锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方法加锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></li>
<li>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</li>
</ul>
</blockquote>
<p>直接在方法上加锁的方式被废除掉了，这种方式无论如何都需要先获取锁，所以在对象加锁代码的基础上进行优化</p>
<p>优化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>        <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码已经完美地解决了并发安全+性能低效问题：</p>
<ul>
<li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li>
<li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li>
<li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li>
<li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li>
</ul>
<p>上面这段代码已经近似完美了，但是还存在最后一个问题：<strong>指令重排</strong>，这个时候可以使用<code>volatile</code>防止指令重排</p>
<p>创建一个对象，在JVM中会经过三步：</p>
<ul>
<li><p>为singleton分配内存空间</p>
</li>
<li><p>初始化singleton对象</p>
</li>
<li><p>将singleton指向分配好的内存空间</p>
</li>
</ul>
<p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p>
<p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803143240854.png" srcset="/img/loading.gif" lazyload alt="image-20220803143240854"></p>
<p>使用volatile关键字可以<strong>防止指令重排序</strong>，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了</p>
<blockquote>
<p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p>
</blockquote>
<p>最终的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>拓展的方式，<strong>枚举实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是枚举类型的单例模式！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举实现的优点：</p>
<ul>
<li>对比饿汉和懒汉式来说，更加简洁</li>
<li>不需要做任何额外的操作去保证对象单一性与线程安全性</li>
<li>使用枚举可以防止调用者使用<strong>反射、序列化和反序列化</strong>机制强制生成多个单例对象，以此破坏单例模式</li>
</ul>
<blockquote>
<ul>
<li>单例模式常见的写法有两种：懒汉式、饿汉式</li>
<li>懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</li>
<li>饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</li>
<li>在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</li>
<li>如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</li>
<li>为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加volatile关键字防止指令重排序</li>
<li>最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</li>
</ul>
</blockquote>
<h2 id="有在项目中用到过这种设计模式吗"><a href="#有在项目中用到过这种设计模式吗" class="headerlink" title="有在项目中用到过这种设计模式吗"></a>有在项目中用到过这种设计模式吗</h2><p>在个人网站的开发过程中，每一个页面设置了一个head-img，使用的是枚举的单例模式实现的，在每一篇文章和每一个页面加载的时候创建图片的实例，并获取实例，为了加速访问数据，还将对应图片的路径&#x2F;链接保存在redis数据库中</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>知网掩码又叫网络掩码、地址掩码、子网络遮罩，是一个应用于TCP&#x2F;IP网络的32位二进制值。它可以屏蔽IP地址中的一部分，从而分离出IP地址中的网络部分与主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。它必须结合IP地址一起使用。</p>
<p><strong>如何通过子网掩码得到网络和主机地址</strong></p>
<ul>
<li>网络地址：二进制形式的IP地址与子网掩码的二进制做<strong>与</strong>运算，将结果转换为十进制就是网络地址</li>
<li>主机地址：将<strong>取反</strong>的子网掩码与IP地址做<strong>与</strong>，将结果转换为十进制得到主机地址</li>
</ul>
<p>例如：</p>
<p>ip地址：192.168.0.1  子网掩码：255.255.255.0</p>
<p>ip二进制：    11000000.10101000.00000000.00000001</p>
<p>子网二进制：11111111.11111111.11111111.00000000</p>
<p>网络地址：    11000000.10101000.00000000.00000000   192.168.0.0</p>
<p>主机地址：    00000000.00000000.00000000.00000001    0.0.0.1</p>
<h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>HTTP<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HTTP 和 HTTPS 的区别（面试常考题）](https://blog.csdn.net/qq_36667170/article/details/121656279)">[3]</span></a></sup>：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
<p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803144740620.png" srcset="/img/loading.gif" lazyload alt="image-20220803144740620"></p>
<p>简要概括一下两者的区别就是：</p>
<p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p>
<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>
<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<h2 id="说一下加密算法，即https如何实现加密传输的"><a href="#说一下加密算法，即https如何实现加密传输的" class="headerlink" title="说一下加密算法，即https如何实现加密传输的"></a>说一下加密算法，即https如何实现加密传输的</h2><p>加密方法：SSL采用一种叫作公开秘钥加密的加密处理方式，近代的加密方法中加密算法是公开的，而秘钥是保密的，通过这种方式可以保持加密方法的安全性。</p>
<p>共享秘钥加密：加密和解密使用同一个秘钥的方式，在加密时必须要将秘钥也发给对方，在互联网转发秘钥时，如果通信被监听那么秘钥就可能会落入攻击者之手，同时也失去了加密的意义。</p>
<p>使用两把秘钥的公开秘钥加密：公开秘钥加密使用一堆非对称的秘钥，一把叫做私有秘钥，另一把叫做公开秘钥；发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有秘钥进行解密，利用这种方式，不需要发送用来解密的私有秘钥，也不必担心秘钥被攻击者窃听而盗走；但是他的处理速度相对共享秘钥来说很慢。</p>
<p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p>
<p>https采用对称加密与非对称加密的混合加密方式</p>
<p>混合加密方式原理：</p>
<ol>
<li>服务端将非对称加密的公钥发送给客户端；</li>
<li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li>
<li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li>
<li>二者利用对称加密的key对需要传输的消息做加解密传输。</li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>数据库有四个隔离级别：</p>
<ul>
<li><p><strong>读未提交（Read uncommitted)</strong></p>
<p>这种隔离级别下，可以读取还未提交的数据，并发最高，但是可能导致<strong>脏读</strong></p>
</li>
<li><p><strong>读已提交（Read committed）</strong></p>
<p>可以读取已经提交的数据，可以避免脏读，但是仍然存在<strong>不可重复读</strong>和<strong>幻读</strong>的现象</p>
</li>
<li><p><strong>可重复读（Repeated read)</strong></p>
<p>MySQL默认隔离级别，可以避免脏读，不可重复读的现象，但是仍然存在<strong>幻读</strong>的想想</p>
</li>
<li><p><strong>串行化（Serializable)</strong></p>
<p>可以避免幻读、不可重复读、幻读的发生</p>
</li>
</ul>
<blockquote>
<ul>
<li>脏读：一个事务在处理数据的过程中，读取到另一个未提交事务的数据</li>
<li>不可重复读：对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另一个事务修改并提交了，针对的是行级别的数据修改</li>
<li>幻读：对于同一查询，两次返回的数据统计不一致，针对的是表级别的新增数据，重点在于新增或者删除</li>
</ul>
</blockquote>
<h2 id="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"><a href="#有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗" class="headerlink" title="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"></a>有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗</h2><p>官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[一文搞懂MySQL索引所有知识点（建议收藏）](https://blog.csdn.net/qq_35190492/article/details/109257302)">[4]</span></a></sup>。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li><p>主键索引：索引列中的值必须是唯一的，不允许有空值</p>
</li>
<li><p>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p>
</li>
<li><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</p>
</li>
<li><p>全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。 MyISAM和InnoDB中都可以使用全文索引。</p>
</li>
<li><p>空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p>
</li>
<li><p>前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p>
</li>
<li><p>其他（按照索引列数量分类）</p>
<ul>
<li><p>单列索引</p>
</li>
<li><p>组合索引</p>
<p>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><p>Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803151811292.png" srcset="/img/loading.gif" lazyload alt="image-20220803151811292"></p>
<p>每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。</p>
<p>这个特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这就很难受很不稳定。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋&#x2F;右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。</p>
<p>使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。查询id&#x3D;6，只需要两次IO。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803152915087.png" srcset="/img/loading.gif" lazyload alt="image-20220803152915087"></p>
<p>就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：</p>
<p>时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10&#x3D;0.2s）</p>
<p>平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。</p>
<h4 id="B树：改造二叉树"><a href="#B树：改造二叉树" class="headerlink" title="B树：改造二叉树"></a>B树：改造二叉树</h4><p>MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。</p>
<p>为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k&#x2F;16&#x3D;1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000&#x3D;1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。</p>
<p>这种数据结构我们称为B树，B树是一种多叉平衡查找树，如下图主要特点：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803155515665.png" srcset="/img/loading.gif" lazyload alt="image-20220803155515665"></p>
<ol>
<li>B树的节点中存储着多个元素，每个内节点有多个分叉。</li>
<li>节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。</li>
<li>父节点当中的元素不会出现在子节点中。</li>
<li>所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。</li>
</ol>
<p>在B树中查询数据的例子：</p>
<blockquote>
<p>假如我们查询值等于10的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。</p>
<p>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10&lt;15，走左路，到磁盘寻址磁盘块2。</p>
<p>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;10，到磁盘中寻址定位到磁盘块5。</p>
<p>第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10&#x3D;10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。</p>
<p>相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162233851.png" srcset="/img/loading.gif" lazyload alt="image-20220803162233851"></p>
<p>虽然B树看来已经很理想了，但是仍然存在许多可以优化的地方：</p>
<ul>
<li>B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。</li>
<li>如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</li>
</ul>
</blockquote>
<h4 id="B-树：改造B树"><a href="#B-树：改造B树" class="headerlink" title="B+树：改造B树"></a>B+树：改造B树</h4><p>B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于<strong>非叶子节点是否存储数据</strong>的问题</p>
<ul>
<li>B树：非叶子节点和叶子节点都会存储数据。</li>
<li>B+树：<strong>只有叶子节点才会存储数据</strong>，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162526549.png" srcset="/img/loading.gif" lazyload alt="image-20220803162526549"></p>
<blockquote>
<p>B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟着增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点</p>
</blockquote>
<p><strong>等值查询</strong><br>假如我们查询值等于9的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块6。</p>
<ul>
<li>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，9&lt;15，走左路，到磁盘寻址磁盘块2。</li>
<li>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;9&lt;12，到磁盘中寻址定位到磁盘块6。</li>
<li>第三次磁盘IO：将磁盘块6加载到内存中，在内存中从头遍历比较，在第三个索引中找到9，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。（这里需要区分的是在InnoDB中Data存储的为行数据，而MyIsam中存储的是磁盘地址。）</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162810055.png" srcset="/img/loading.gif" lazyload alt="image-20220803162810055"></p>
<p><strong>范围查询</strong></p>
<p>假如我们想要查找9和26之间的数据。查找路径是磁盘块1-&gt;磁盘块2-&gt;磁盘块6-&gt;磁盘块7。</p>
<ul>
<li>首先查找值等于9的数据，将值等于9的数据缓存到结果集。这一步和前面等值查询流程一样，发生了三次磁盘IO。</li>
<li>查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块6，键值9开始向后遍历筛选所有符合筛选条件的数据。</li>
<li>第四次磁盘IO：根据磁盘6后继指针到磁盘中寻址定位到磁盘块7，将磁盘7加载到内存中，在内存中从头遍历比较，9&lt;25&lt;26，9&lt;26&lt;&#x3D;26，将data缓存到结果集。</li>
<li>主键具备唯一性（后面不会有&lt;&#x3D;26的数据），不需再向后查找，查询终止。将结果集返回给用户。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162902012.png" srcset="/img/loading.gif" lazyload alt="image-20220803162902012"></p>
<p><strong>可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构</strong></p>
<h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><h4 id="MyIsam索引"><a href="#MyIsam索引" class="headerlink" title="MyIsam索引"></a>MyIsam索引</h4><p>以一个简单的user表为例。user表存在两个索引，id列为主键索引，age列为普通索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = MyISAM<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8;<br><br></code></pre></td></tr></table></figure>

<p>MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。</p>
<p>主键索引的B+树如下图所示：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803163454024.png" srcset="/img/loading.gif" lazyload alt="image-20220803163454024"></p>
<p>表user的索引存储在索引文件<code>user.MYI</code>中，数据文件存储在数据文件 <code>user.MYD</code>中</p>
<p><strong>主键等值索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 28;<br></code></pre></td></tr></table></figure>

<ul>
<li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li>
<li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li>
<li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于30的索引项。（1次磁盘IO）</li>
<li>从索引项中获取磁盘地址，然后到数据文件user.MYD中获取对应整行记录。（1次磁盘IO）</li>
<li>将记录返给客户端。</li>
</ul>
<p><strong>磁盘IO次数：3次索引检索+记录数据检索。</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803164712589.png" srcset="/img/loading.gif" lazyload alt="image-20220803164712589"></p>
<p><strong>主键返回查询数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id between 28 and 47;<br></code></pre></td></tr></table></figure>

<ul>
<li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li>
<li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li>
<li>检索到叶节点，将节点加载到内存中遍历比较16&lt;28，18&lt;28，28&#x3D;28&lt;47。查找到值等于28的索引项。</li>
<li>根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li>
<li>我们的查询语句时范围查找，需要向后遍历底层叶子链表，直至到达最后一个不满足筛选条件。</li>
<li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，28&lt;47&#x3D;47，根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li>
<li>最后得到两条符合筛选条件，将查询结果集返给客户端。</li>
</ul>
<p><strong>磁盘IO次数：4次索引检索+记录数据检索</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165338794.png" srcset="/img/loading.gif" lazyload alt="image-20220803165338794"></p>
<blockquote>
<p>在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。</p>
<p>查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。</p>
</blockquote>
<h4 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h4><p>每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：</p>
<ul>
<li>在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。</li>
<li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li>
<li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li>
</ul>
<p>这里以user_innodb为例，user_innodb的id列为主键，age列为普通索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user_innodb`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure>

<p><strong>InnoDB主键索引</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165717554.png" srcset="/img/loading.gif" lazyload alt="image-20220803165717554"></p>
<p><strong>查询等值数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user_innodb where id = 28;<br></code></pre></td></tr></table></figure>

<ul>
<li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li>
<li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li>
<li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205600971.png" srcset="/img/loading.gif" lazyload alt="image-20220803205600971"></p>
<p><strong>辅助索引</strong></p>
<p>除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。</p>
<p>以表user_innodb的age列为例，age索引的索引结果如下图</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205628315.png" srcset="/img/loading.gif" lazyload alt="image-20220803205628315"></p>
<p>底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。</p>
<p>使用辅助索引需要<strong>检索两遍索引</strong>：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记录。</p>
<p><strong>辅助索引等值查询的情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where age=19;<br></code></pre></td></tr></table></figure>

<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205904722.png" srcset="/img/loading.gif" lazyload alt="image-20220803205904722"></p>
<p>根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为<strong>回表</strong>查询。</p>
<p><strong>磁盘IO数：辅助索引3次+获取记录回表3次</strong></p>
<p><strong>组合索引</strong></p>
<p>还是以自己创建的一个表为例：表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `abc_innodb`<br>(<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `a`  int(11)     DEFAULT NULL,<br>  `b`  int(11)     DEFAULT NULL,<br>  `c`  varchar(10) DEFAULT NULL,<br>  `d`  varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_abc` (`a`, `b`, `c`)<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure>

<p>组合索引的数据结构</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210223424.png" srcset="/img/loading.gif" lazyload alt="image-20220803210223424"></p>
<p><strong>组合索引的查询过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from abc_innodb where a = 13 and b = 16 and c = 4;<br></code></pre></td></tr></table></figure>

<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210836339.png" srcset="/img/loading.gif" lazyload alt="image-20220803210836339"></p>
<p><strong>最左匹配原则</strong></p>
<p>最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。</p>
<p>在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。</p>
<p>就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。</p>
<p>可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。、</p>
<p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong></p>
<p><strong>覆盖索引</strong></p>
<p>覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。</p>
<h2 id="可以讲一下如何优化数据库查询吗"><a href="#可以讲一下如何优化数据库查询吗" class="headerlink" title="可以讲一下如何优化数据库查询吗"></a>可以讲一下如何优化数据库查询吗</h2><h3 id="避免回表"><a href="#避免回表" class="headerlink" title="避免回表"></a>避免回表</h3><p>在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？</p>
<p>使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）</p>
<p>如果在一个场景下，<code>select id,name,sex from user where name =&#39;zhangsan&#39;;</code>这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。</p>
<p>这里就是一个典型的使用覆盖索引的优化策略减少回表的情况。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><strong>联合索引</strong>，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。</p>
<p><strong>联合索引的创建原则</strong>，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。</p>
<p><strong>联合索引的使用</strong></p>
<p>考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。<br>当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。</p>
<h2 id="数据库中的锁"><a href="#数据库中的锁" class="headerlink" title="数据库中的锁"></a>数据库中的锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>MySQL大致可归纳为以下3种锁：</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h3 id="MyIsam锁"><a href="#MyIsam锁" class="headerlink" title="MyIsam锁"></a>MyIsam锁</h3><p>在使用MyIsam时，我们<strong>只可以使用表级锁</strong>，而MySQL的表级锁有两种模式：</p>
<p><strong>表共享锁</strong>（Table Read Lock）和<strong>表独占写锁</strong>（Table Write Lock），他们在工作时表现如下：</p>
<ul>
<li>对某一个表的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</li>
<li>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；</li>
<li>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</li>
</ul>
<p>当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p>
<p>MyISAM在执行<strong>查询语句</strong>（SELECT）前，会自动给涉及的所有表<strong>加读锁</strong>，在<strong>执行更新操作</strong>（UPDATE、DELETE、INSERT等）前，会自动给涉及的表<strong>加写锁</strong>，这个过程并不需要用户干预</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p>
<p>行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>
<h4 id="事务（Transaction）及其ACID属性"><a href="#事务（Transaction）及其ACID属性" class="headerlink" title="事务（Transaction）及其ACID属性"></a>事务（Transaction）及其ACID属性</h4><p>  事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
<ul>
<li><strong>原子性（Actomicity）</strong>：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li><strong>一致性（Consistent）</strong>：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li><strong>持久性（Durable）</strong>：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>  相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
<ul>
<li><p><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</p>
</li>
<li><p><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</p>
</li>
<li><p><strong>不可重复读</strong>（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</p>
</li>
<li><p><strong>幻读</strong></p>
<p>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p>
<ul>
<li>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是<strong>间隙锁(Gap Lock)</strong></li>
</ul>
</li>
</ul>
<h4 id="InnoDB都有哪些锁"><a href="#InnoDB都有哪些锁" class="headerlink" title="InnoDB都有哪些锁"></a>InnoDB都有哪些锁</h4><ol>
<li>行锁<ol>
<li>共享锁（lock in share mode）</li>
<li>排他锁（for update）</li>
</ol>
</li>
<li>意向锁（表级别）<ol>
<li>意向共享锁</li>
<li>意向排他锁</li>
</ol>
</li>
<li>间隙锁</li>
<li>Next-key lock：行锁（排他锁）+间隙锁</li>
</ol>
<h4 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h4><p>InnoDB实现了以下两种类型的行锁。</p>
<ul>
<li><strong>共享锁（s）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。xxx lock in share mode</li>
<li><strong>排他锁（Ｘ）</strong>：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。xxx for update</li>
</ul>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>
<p><strong>意向共享锁（IS）</strong>：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p><strong>意向排他锁（IX）</strong>：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p><strong>InnoDB行锁是通过索引上的索引项来实现的</strong>，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁（如果是RR &#x2F; Serializable 级别，将在主键上使用Next-Key Locks（行锁+间隙锁）来实现锁表的操作）</p>
<blockquote>
<p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
</blockquote>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p> 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB（可重复读、串行化级别下才有效）会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁它通常是一个开区间（xx, xx）。</p>
<p>  InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求</p>
<blockquote>
<p> 很显然，<strong>在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待</strong>。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
</blockquote>
<h4 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h4><p>next-key lock是InnoDB加锁的基本单位，它是一个前开后闭的区间，即行锁+间隙锁</p>
<h4 id="InnoDB加锁规则"><a href="#InnoDB加锁规则" class="headerlink" title="InnoDB加锁规则"></a>InnoDB加锁规则</h4><p><strong>两个“原则”、两个“优化”和一个“bug”：</strong></p>
<ul>
<li>原则1：加锁的基本单位是next-key lock。next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h4 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h4><p> 对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p>
<ul>
<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>
<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>
</ul>
<p><strong>InnoDB加锁方法</strong></p>
<ul>
<li><p>意向锁是 InnoDB 自动加的， 不需用户干预。</p>
</li>
<li><p>对于 <code>UPDATE</code>、 <code>DELETE </code>和 <code>INSERT </code>语句， InnoDB会自动给涉及数据集加排他锁（X)；</p>
</li>
<li><p>对于普通 <code>SELECT </code>语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
</li>
<li><ul>
<li>共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code>。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>排他锁（X)：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code>。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>
</ul>
</li>
</ul>
<p><strong>for update 和 lock in share mode 的区别：</strong></p>
<p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 <code>for update</code> ；后一个是共享锁，多个事务可以同时的对相同数据执行 <code>lock in share mode</code></p>
<h3 id="MySQL乐观锁的实现"><a href="#MySQL乐观锁的实现" class="headerlink" title="MySQL乐观锁的实现"></a>MySQL乐观锁的实现</h3><p><strong>悲观锁</strong>：从字面理解就是很悲观，每次去拿数据的时候都认为别人会修改，所以在每次拿的时候对数据上锁，这样就保证了数据的准确性。比如mysql中的表锁，行锁。</p>
<p><strong>乐观锁</strong>：<strong>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</strong></p>
<p>乐观锁的实现：使用版本控制字段，再使用行锁的特性实现乐观锁</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925191406535.png" srcset="/img/loading.gif" lazyload alt="image-20220925191406535"></p>
<p>如果执行一次，那么版本号就增加一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update order set price = 1, version = version + 1 where id = 1 and version = 0;<br></code></pre></td></tr></table></figure>

<p><strong>死锁的处理</strong></p>
<p>数据库使用乐观锁导致产生死锁</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925191736595.png" srcset="/img/loading.gif" lazyload alt="image-20220925191736595"></p>
<p>假设在两个事务中有以上两个操作，同时修改order表中两条数据</p>
<p>事务A在执行完第一条update的时候，刚好事务B也执行完第一条update</p>
<p>此时， 事务A中order表中的id &#x3D; 1的行被锁住， 事务B中order表中id &#x3D; 2的行被锁住，两个事务继续往下执行</p>
<p>事务A中第二条update执行需要order表中id &#x3D; 2的行数据，而事务B中第二条update执行需要id &#x3D; 1的行数据， 两条update往下执行的条件都需要对方事务中已经被锁住的行，于是陷入无限等待，形成死锁。</p>
<p><strong>解决死锁的方法</strong></p>
<p><strong>指定锁的执行顺序</strong>，比如把以上两事务稍作修改</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925192445700.png" srcset="/img/loading.gif" lazyload alt="image-20220925192445700"></p>
<p>事务A执行第一条update时，id &#x3D; 2 的行被锁住，此时，事务B想修改id &#x3D; 2的行，只能等待事务A执行完成，当事务A执行完成时，事务B再执行， 这样就不会产生死锁了。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h2><ol>
<li>Redis是<strong>纯内存数据库</strong>。</li>
<li>Redis是<strong>单线程数据库</strong>。利用<strong>队列</strong>技术将并发访问变为串行访问。</li>
<li>Redis采用了<strong>多路复用IO技术</strong>：“多路”指多个网络连接；”复用”指复用一个线程；多路复用IO技术<strong>可以让单线程高效的处理多个连接请求</strong>。</li>
</ol>
<h2 id="Redis常用的数据结构"><a href="#Redis常用的数据结构" class="headerlink" title="Redis常用的数据结构"></a>Redis常用的数据结构</h2><ul>
<li>字符串 <code>String</code></li>
<li>列表 <code>list</code></li>
<li>有序集合 <code>zset</code></li>
<li>哈希表 <code>hash</code></li>
<li>集合 <code>set</code></li>
</ul>
<p>其他的一些高级数据结构</p>
<ul>
<li><code>HyperLogLog</code>：通常用于基数统计，使用少量固定大小的内存，来统计集合中唯一元素的数据</li>
<li><code>Geo</code>：可以将用户给定的地理位置信息存储起来，并进行操作</li>
<li><code>BitMap</code>：位图</li>
<li><code>Stream</code>：主要用于消息队列，类似于<code>Kafka</code>。提供了消息的持久化和主从复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证信息不丢失</li>
</ul>
<h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><ul>
<li>缓存</li>
<li>分布式锁</li>
<li>排行榜 <code>zset</code></li>
<li>计数 <code>incrby</code></li>
<li>消息队列 <code>stream</code></li>
<li>地理位置 <code>geo</code></li>
<li>访客统计 <code>hyperloglog</code></li>
</ul>
<h2 id="Redis做异步队列"><a href="#Redis做异步队列" class="headerlink" title="Redis做异步队列"></a>Redis做异步队列</h2><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产信息，<code>lpop</code>消费消息</p>
<p>缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等</p>
<blockquote>
<p>使用<code>pub/sub</code>主题订阅者模式，可以实现<code>1:N</code>的消息队列</p>
</blockquote>
<h2 id="Redis和数据库一致性问题"><a href="#Redis和数据库一致性问题" class="headerlink" title="Redis和数据库一致性问题"></a>Redis和数据库一致性问题</h2><p>更新策略：</p>
<ul>
<li>采用正确的更新策略，先更新数据库，再删除缓存</li>
<li>因为可能存在删除缓存失败的问题，提供一个消息队列作为补偿措施</li>
</ul>
<p>采用延时双删策略：</p>
<ul>
<li>先淘汰缓存</li>
<li>再写数据库</li>
<li>休眠一会，再次淘汰缓存</li>
</ul>
<blockquote>
<p>如果对数据有强一致性要求，不能放缓存</p>
</blockquote>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了或宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。</p>
<p>持久化就是把内存的数据写到磁盘中，防止服务器宕机了，导致内存数据待久。</p>
<p>Redis提供两种持久化机制，分别是RDB和AOF。<strong>Redis服务器默认开启RDB，关闭AOF</strong>；</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB(Redis DataBase)：快照。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923221404554.png" srcset="/img/loading.gif" lazyload alt="image-20220923221404554"></p>
<p>优点：<strong>RDB文件紧凑，体积小，网络传输快，适合全量复制</strong>；<strong>恢复速度比AOF快</strong>。与AOF相比，RDB最重要的优点之一是<strong>对性能的影响相对较小</strong>。</p>
<p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然<strong>做不到实时持久化</strong>，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF(Append Only File)：将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志志中文件恢复数据。</p>
<p>与RDB持久化相对应，AOF的优点在于支持<strong>秒级持久化</strong>、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p>
<p><strong>持久化策略选择</strong></p>
<ul>
<li>如果Redis中的数据完全丢弃也没有关系，那么无论是单机，还是主从架构，都可以不进行任何持久化。</li>
<li>在单机环境下，如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</li>
<li>但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</li>
</ul>
<h2 id="Redis的淘汰策略"><a href="#Redis的淘汰策略" class="headerlink" title="Redis的淘汰策略"></a>Redis的淘汰策略</h2><p>当Redis的内存（maxmemory参数配置）已满时，它会根据淘汰策略（maxmemory-policy参数配置）进行相应的操作。</p>
<ul>
<li><p>不删除策略（no-eviction）<br>no-eviction：不删除策略。Redis默认策略。达到最大内存限制时，若需要更多内存，直接返回错误信息。</p>
</li>
<li><p>最近最少使用策略（lru）</p>
<ul>
<li>allkeys-lru：所有key通用；优先删除最近最少使用的key</li>
<li>volatile-lru：只限于设置了 expire 过期时间的部分；优先删除最近最少使用的key</li>
</ul>
</li>
<li><p>随机策略（random）：</p>
<ul>
<li>allkeys-random：所有key通用；随机删除一部分key。</li>
<li>volatile-random：只限于设置 expire 的部分；随机删除一部分key。</li>
</ul>
</li>
<li><p>剩余时间短策略（ttl）：</p>
<p>volatile-ttl：只限于设置 expire 的部分；优先删除剩余时间短的key。</p>
</li>
<li><p>最不经常使用策略（lfu）:</p>
<p>volatile-lfu：只限于设置 expire 的部分；优先删除最不经常使用的key。</p>
</li>
<li><p>allkeys-lfu：所有key通用；优先删除最不经常使用的key。</p>
</li>
</ul>
<blockquote>
<ul>
<li>volatile-：从已过期时间的数据集中淘汰key。</li>
<li>allkeys-：所有key。</li>
</ul>
</blockquote>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>Redis基于 <strong>Reactor 模式</strong>开发了自己网络事件处理器，它由四部分组成，分别是</p>
<ul>
<li>套接字</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器</li>
</ul>
<p>因为<strong>文件事件分派器队列</strong>的消费是单线程的，所以Redis才叫单线程模型。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923222211570.png" srcset="/img/loading.gif" lazyload alt="image-20220923222211570"></p>
<h2 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h2><p>IO多路复用：”多路”是指多个TCP连接；”复用”是指复用一个或多个线程；可以让单线程高效的处理多个连接请求。</p>
<p>IO多路复用使用两个系统调用(select&#x2F;poll&#x2F;epoll和recvfrom)，阻塞IO只调用了recvfrom；</p>
<p>select&#x2F;poll&#x2F;epoll 核心是可以同时处理多个连接，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好，多路复用模型中，每一个socket，设置为non-blocking，阻塞是被select这个函数阻塞的，而不是被socket阻塞的。</p>
<h3 id="select机制"><a href="#select机制" class="headerlink" title="select机制"></a>select机制</h3><p>原理：客户端操作服务器时会三种文件描述符(简称fd)：writefds(写)、readfds(读)、exceptfds(异常)。select会阻塞监视3类文件描述符，等有数据、可读、可写、出异常或超时，就会返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后进行对应的IO操作。</p>
<p>优点：所有平台都支持，跨平台性好。<br>缺点：</p>
<ul>
<li>由于是采用轮询方式全盘扫描，会随着文件描述符fd数量增多而性能下降。</li>
<li>每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)</li>
<li>默认单个进程打开的fd有限制是1024个，可修改宏定义，但是效率仍然慢。</li>
</ul>
<h3 id="poll机制"><a href="#poll机制" class="headerlink" title="poll机制"></a>poll机制</h3><p>原理：基本原理与select一致，也是轮询+遍历；唯一的区别就是poll没有最大文件描述符限制（使用链表的方式存储fd）。</p>
<h3 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h3><p>原理：epoll也没有fd个数限制，用户态拷贝到内核态只需要一次，使用时间通知机制来触发。通过epoll_ctl注册fd，一旦fd就绪就会通过callback回调机制来激活对应fd，进行相关的io操作。</p>
<p>优点：</p>
<ul>
<li>没有fd限制，所支持的fd上限是操作系统的最大文件句柄数，1G内存大概支持10万个句柄</li>
<li>效率提高，使用回调通知而不是轮询的方式，不会随着FD数目的增加效率下降</li>
<li>内核和用户空间mmap同一块内存实现(mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)</li>
</ul>
<h2 id="Redis异常问题"><a href="#Redis异常问题" class="headerlink" title="Redis异常问题"></a>Redis异常问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>同一时间内大量键过期（失效）</strong>，导致所有请求瞬间都落在了数据库中导致连接异常而崩掉。</p>
<p>如何解决缓存雪崩</p>
<ul>
<li>给缓存数据的过期时间设置随机机，防止同一时间大量数据过期。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，若标记失效，则更新缓存数据。</li>
<li>并发量不大时，可以使用加锁排队。</li>
</ul>
<p>对于”Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：</p>
<ul>
<li><strong>事发前</strong>：实现Redis的高可用（主从架构+Sentinel或者Redis集群），尽量避免Redis挂掉</li>
<li><strong>事发中</strong>：设置本地缓存(ehcache)+限流(hystrix)，尽量避免数据挂掉，保证服务能正常工作</li>
<li><strong>事发后</strong>：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>恶意请求缓存中不存在的数据</strong>，导致所有请求都落在数据库，造成短时间承受大量请求而崩掉</p>
<p><code>采用布隆过滤器</code>，将所有可能存在的数据哈希到一个bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据。<strong>同时读缓存数据没有读到</strong>，导致所有请求都落在数据库，造成过大压力。</p>
<p><strong>缓存雪崩与缓存击穿的区别</strong></p>
<p>与缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期，很多数据都查不到从而查数据库。</p>
<p><strong>如何解决缓存击穿</strong></p>
<ol>
<li><code>设置热点数据永不过期</code>。</li>
<li><code>利用互斥锁</code>：在缓存失效的时，先获取锁，得到锁后再去请求数据库。没有得到锁，则休眠一段时间在重试。</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热指系统上线后，将相关的缓存数据直接加载到Redis中，这样就可以避免在用户请求时，先查询数据库，然后再将数据缓存的问题。</p>
<ol>
<li>直接写个缓存刷新页面，系统上线时手动将缓存数据加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ul>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
<p><strong>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</strong></p>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>事务间相互独立：事务中的所有命令都会序列化，按顺序执行。事务在执行过程中，不会被其他客户端请求的命令中断。</p>
<blockquote>
<p>事务中的命令要么都执行，要么都不执行</p>
</blockquote>
<h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD、WATCH命令实现的。通过MULTI开启事务，然后将请求的命令入队，最后通过EXEC命令依次执行队列中所有的命令。</p>
<p>Redis会将一个事务所有的命令序列化，然后按顺序执行。</p>
<ul>
<li><strong>Redis不支持回滚</strong>。Redis在事务失败时不进行回滚，而是继续执行剩下的命令。</li>
<li><strong>若在一个事务中的命令出现错误，那么所有命令都不会执行</strong>。</li>
<li><strong>若在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li>
</ul>
<p><strong>WATCH命令</strong>：是一个乐观锁，可以为Redis提供CAS操作。可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不执行，监控一直持续到EXEC命令。</p>
<p><strong>MULTI命令</strong>：用于开启事务。MULTI执行后，Client可以继续向服务器发送任意多条命令，这些命令会存放到一个队列中，当EXEC命令调用后，所有队列中的命令才会被执行。</p>
<p><strong>EXEC命令</strong>：执行所有事务块的命令，可以理解为提交事务。按命令的执行顺序，返回事务中所有命令的返回值。当操作被打断时，返回空值（nil）。</p>
<p><strong>DISCARD命令</strong>：用于清空事务队列，并放弃执行事务。Client从事务状态中退出。</p>
<p><strong>UNWATCH命令</strong>：用于取消WATCH命令对所有key的监控。</p>
<blockquote>
<p><strong>事务执行过程中，若服务器收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中</strong></p>
</blockquote>
<h3 id="Redis事务的特性"><a href="#Redis事务的特性" class="headerlink" title="Redis事务的特性"></a>Redis事务的特性</h3><p>就是数据库的ACID特性</p>
<ul>
<li><strong>原子性（Atomicity）</strong></li>
<li><strong>一致性（Consistency）</strong></li>
<li><strong>隔离性（Isolation）</strong></li>
<li><strong>持久性（Durability）</strong></li>
</ul>
<h2 id="Redis分布式问题"><a href="#Redis分布式问题" class="headerlink" title="Redis分布式问题"></a>Redis分布式问题</h2><h3 id="Redis的分布式锁"><a href="#Redis的分布式锁" class="headerlink" title="Redis的分布式锁"></a>Redis的分布式锁</h3><p>Redis是单进程模式，队列技术将并发访问变为串行访问，且多个客户端对Redis的连接并不存在竞争关系，Redis可以使用<code>setnx</code>命令实现分布式锁。</p>
<p><strong>获取锁时调用setnx（setnx若设置值成功，返回1；设置失败，返回0）。锁的value值会随机生成一个UUID，在释放锁时，会通过UUID进行判断是否为对应的锁，若是该锁，则释放该锁；可以使用 <code>expire </code>命令为锁添加一个超时时间，超过该时间则自动释放锁。</strong></p>
<p><code>setnx key value</code>：只有在 key 不存在时，才将key设置为value值。</p>
<h3 id="Redis的并发竞争key问题"><a href="#Redis的并发竞争key问题" class="headerlink" title="Redis的并发竞争key问题"></a>Redis的并发竞争key问题</h3><p>多个系统同时对一个key进行操作，最后执行的顺序和我们期望的顺序不同，导致结果不同。</p>
<p>如何解决并发竞争问题</p>
<ul>
<li><strong>Redis实现分布式锁</strong>：通过Redis中setnx命令可以实现分布式锁。当获取锁时，调用setnx加锁。锁的value值会随机生成一个UUID。在释放锁时，通过UUID进行判断是否为对应的锁，若是则释放锁。使用expire命令为锁添加一个超时时间，若超过该时间则自动释放锁。</li>
<li>Zookeeper实现分布式锁：通过Zookeeper临时有序节点可以实现分布式锁。每个Client对某个方法加锁时，在Zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。通过判断有序节点中，序号是否为最小来获取锁；当释放锁时，只需要删除瞬时有序节点。</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵（Sentinel） 是 Redis 的高可用性解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925140736236.png" srcset="/img/loading.gif" lazyload alt="image-20220925140736236"></p>
<p><strong>哨兵的作用</strong></p>
<ul>
<li>监控redis主、从数据库是否正常运行</li>
<li>主数据库出现故障自动将从数据库转换为主数据库</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要3个实例，来保证自己的健壮性</li>
<li>哨兵+redis主从的部署架构，是不保证数据零丢失的，<strong>只能保证redis集群的高可用性</strong></li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
<li>配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</li>
</ul>
<h2 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a>Redis的主从复制</h2><p>当从数据库启动时，会向主数据库发送<code>sync</code>命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。复制初始化结束。之后，主数据库每收到1个命令就同步发送给从数据库。 当出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库。增量复制。<code>213  c</code></p>
<p>主从复制是乐观复制，当客户端发送写执行给主数据库，主数据库执行完立即将结果返回客户端，并异步的把命令发送给从数据库，从而不影响性能。</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring的IOC和AOP吗"><a href="#Spring的IOC和AOP吗" class="headerlink" title="Spring的IOC和AOP吗"></a>Spring的IOC和AOP吗</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（面向切面）是一种编程范式，提供从另一个角度来考虑程序结构以完善面向对象编程（OOP）。<br>AOP为开发者提供了一种描述横切关注点的机制，并能够自动将横切关注点织入到面向对象的软件系统中，从而实现了横切关注点的模块化。<br>AOP能够将那些与业务无关，却为业务模块所共同调用的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E6%88%96&spm=1001.2101.3001.7020">逻辑或</a>责任，例如事务处理、日志管理、权限控制等，封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p><strong>使用AOP的好处</strong></p>
<ul>
<li>降低模块的耦合度</li>
<li>使系统容易扩展</li>
<li>提高代码复用性</li>
</ul>
<p><strong>AOP的基本概念</strong></p>
<ul>
<li>连接点（JoinPoint）：需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点。</li>
<li>切入点（Pointcut）：一组相关连接点的集合。</li>
<li>通知（Advice）：在连接点上执行的行为，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置增强（before advice）、后置增强 (after advice)、环绕增强 （around advice）。</li>
<li>切面（Aspect）：通知和切入点的结合。</li>
<li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</li>
<li>代理（Proxy）：通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</li>
<li>目标对象（Target）：需要被织入关注点的对象。即被代理的对象。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803214934226.png" srcset="/img/loading.gif" lazyload alt="image-20220803214934226"></p>
<p>实现AOP的主要设计模式就是动态代理。</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（控制反转）就是依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。<br>Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是<strong>工厂模式</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803215056912.png" srcset="/img/loading.gif" lazyload alt="image-20220803215056912"></p>
<p><strong>使用IOC的好处</strong></p>
<ul>
<li>集中管理，实现类的可配置和易管理。</li>
<li>降低了类与类之间的耦合度</li>
</ul>
<h1 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h1><p>Tomcat 服务器<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[学习Tomcat这一篇就够了](http://t.csdn.cn/cQSkN)">[7]</span></a></sup>是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<h2 id="Tomcat的缺省端口"><a href="#Tomcat的缺省端口" class="headerlink" title="Tomcat的缺省端口"></a>Tomcat的缺省端口</h2><p>Tomcat目录下的conf文件夹下的server.xml文件中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">uriEncoding</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP&#x2F;IP协议来传递数据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端和服务器之间的通信格式。它的整个过程如下图所示：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907213344213.png" srcset="/img/loading.gif" lazyload alt="image-20220907213344213"></p>
<ol>
<li>用户通过浏览器进行了一个操作，比如输入网址并回车，或者是点击链接，接着浏览器获取了这个事件。</li>
<li>浏览器向服务端发出TCP连接请求。</li>
<li>服务程序接受浏览器的连接请求并经过TCP三次握手建立连接。</li>
<li>浏览器将请求数据打包成一个HTTP协议格式的数据包。</li>
<li>浏览器将该数据包推入网络，数据包经过网络传输，最终达到端服务程序。</li>
<li>服务端程序拿到这个数据包后，同样以HTTP协议格式解包，获取到客户端的意图。</li>
<li>得知客户端意图后进行处理，比如提供静态文件或者调用服务端程序获得动态结果。</li>
<li>服务器将响应结果（可能是HTML或者图片等）按照HTTP协议格式打包。</li>
<li>服务器将响应数据包推入网络，数据包经过网络传输最终达到到浏览器。</li>
<li>浏览器拿到数据包后，以HTTP协议的格式解包，然后解析数据，假设这里的数据是 HTML。</li>
<li>浏览器将HTML文件展示在页面上。</li>
</ol>
<h2 id="Tomcat整体架构"><a href="#Tomcat整体架构" class="headerlink" title="Tomcat整体架构"></a>Tomcat整体架构</h2><p>Tomcat要实现两个核心功能：</p>
<ol>
<li>处理Socket连接，负责网络字节流与Request和Response对象的转化。</li>
<li>加载和管理Servlet，以及具体处理Request请求。</li>
</ol>
<p>因此Tomcat设计了两个核心组件</p>
<ul>
<li><strong>连接器（Connector）</strong>：负责对外交流</li>
<li><strong>容器（Container）</strong>：负责内部处理</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907214254671.png" srcset="/img/loading.gif" lazyload alt="image-20220907214254671"></p>
<h3 id="Coyote连接器架构"><a href="#Coyote连接器架构" class="headerlink" title="Coyote连接器架构"></a>Coyote连接器架构</h3><p>Coyote是Tomcat的连接器框架的名称 , 是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受响应 。</p>
<p>Coyote封装了底层的网络通信（Socket请求及响应处理），为Catalina容器提供了统一的接口，使Catalina容器与具体的请求协议及IO操作方式完全解耦。Coyote 将Socket输入转换封装为Request对象，交由Catalina容器进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流 。</p>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>布隆过滤器（Bloom Filter）<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/94433082)">[6]</span></a></sup>是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。</p>
<p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p>
<p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p>
<p>根据定义，布隆过滤器可以检查值是 <strong>“可能在集合中”</strong> 还是 <strong>“绝对不在集合中”</strong>。“可能” 表示有一定的概率，也就是说可能存在一定为误判率。那为什么会存在误判呢？下面我们来分析一下具体的原因。</p>
<p>布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，如下图所示。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221423444.png" srcset="/img/loading.gif" lazyload alt="image-20220803221423444"></p>
<p>为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221528106.png" srcset="/img/loading.gif" lazyload alt="image-20220803221528106"></p>
<p>如上图所示，当输入 “semlinker” 时，预设的 3 个哈希函数将输出 2、4、6，我们把相应位置 1。假设另一个输入 ”kakuqo“，哈希函数输出 3、4 和 7。你可能已经注意到，索引位 4 已经被先前的 “semlinker” 标记了。此时，我们已经使用 “semlinker” 和 ”kakuqo“ 两个输入值，填充了位向量。当前位向量的标记状态为：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221601391.png" srcset="/img/loading.gif" lazyload alt="image-20220803221601391"></p>
<p>当对值进行搜索时，与哈希表类似，我们将使用 3 个哈希函数对 ”搜索的值“ 进行哈希运算，并查看其生成的索引值。假设，当我们搜索 ”fullstack“ 时，3 个哈希函数输出的 3 个索引值分别是 2、3 和 7：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221742464.png" srcset="/img/loading.gif" lazyload alt="image-20220803221742464"></p>
<p>从上图可以看出，相应的索引位都被置为 1，这意味着我们可以说 ”fullstack“ 可能已经插入到集合中。事实上这是误报的情形，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。幸运的是，布隆过滤器有一个可预测的误判率（FPP）：<br>$$<br>P_{fpp} \approx (1-e^{-\frac{kn}{m}})^k<br>$$</p>
<ul>
<li>n 是已经添加元素的数量；</li>
<li>k 哈希的次数；</li>
<li>m 布隆过滤器的长度（如比特数组的大小）；</li>
</ul>
<p><strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在实际工作中，布隆过滤器常见的应用场景如下：</p>
<ul>
<li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li>
<li>Google Chrome 使用布隆过滤器识别恶意 URL；</li>
<li>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</li>
<li>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。 除了上述的应用场景之外，布隆过滤器还有一个应用场景就是解决缓存穿透的问题。所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。</li>
</ul>
<p>利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>可以创建一个Maven项目，在pom文件中引入以下坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.0-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后创建一个测试代码，初始化一百万条数据到过滤器中，然后在原有的基础上增加一万条数据，并且判断这些数据是否存在布隆过滤器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Charsets;<br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 总数量</span><br>        BloomFilter&lt;CharSequence&gt; bf = <br>          BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total);<br>        <span class="hljs-comment">// 初始化 1000000 条数据到过滤器中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total; i++) &#123;<br>            bf.put(<span class="hljs-string">&quot;&quot;</span> + i);<br>        &#125;<br>        <span class="hljs-comment">// 判断值是否存在过滤器中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total + <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bf.mightContain(<span class="hljs-string">&quot;&quot;</span> + i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;已匹配数量 &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得到的结果是</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">已匹配数量 <span class="hljs-number">1000309</span><br></code></pre></td></tr></table></figure>

<p>上述结果出现了五宝，误报率比预期多了309个元素<br>$$<br>\frac{309}{1000000+10000} \times 100% \approx 3.059%<br>$$</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142%5Ev39%5Epc_rank_v37&spm=1018.2226.3001.4187">Java多线程同步之ThreadLocal与Synchromized</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142%5Ev39%5Epc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187">我给面试官讲解了单例模式后，他对我竖起了大拇指！</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36667170/article/details/121656279">HTTP 和 HTTPS 的区别（面试常考题）</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190492/article/details/109257302">一文搞懂MySQL索引所有知识点（建议收藏）</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79980618">红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)</a>
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94433082">5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)</a>
<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a target="_blank" rel="noopener" href="http://t.csdn.cn/cQSkN">学习Tomcat这一篇就够了</a>
<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/offer/">#offer</a>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">#后端开发</a>
      
        <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">#八股文</a>
      
        <a href="/tags/%E6%91%86%E7%83%82/">#摆烂</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试笔记</div>
      <div>http://example.com/2022/09/08/面试记录/面试笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>madao33</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>September 8, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95-%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%880914%E5%A4%8D%E7%9B%98/" title="华为笔试-通用软件开发工程师-0914复盘">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">华为笔试-通用软件开发工程师-0914复盘</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/08/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="华为机试练习汇总记录">
                        <span class="hidden-mobile">华为机试练习汇总记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

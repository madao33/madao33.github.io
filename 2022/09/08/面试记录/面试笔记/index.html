

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/avatar/avatar.jpg">
  <link rel="icon" href="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/avatar/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="madao33">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试笔记总结Java后端相关的重要知识点 Java基础基础Java语言的特点 简单易学、有丰富的类库 面向对象 与平台无关性，主要是JVM虚拟机的支持 可靠安全 支持多线程  你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点 Java是面向对象的，比较符合人的认知 Java和C++都是面向对象的，都支持封装、继承和多态 Java不是通过指针">
<meta property="og:type" content="article">
<meta property="og:title" content="面试笔记">
<meta property="og:url" content="http://example.com/2022/09/08/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试笔记总结Java后端相关的重要知识点 Java基础基础Java语言的特点 简单易学、有丰富的类库 面向对象 与平台无关性，主要是JVM虚拟机的支持 可靠安全 支持多线程  你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点 Java是面向对象的，比较符合人的认知 Java和C++都是面向对象的，都支持封装、继承和多态 Java不是通过指针">
<meta property="og:locale">
<meta property="og:image" content="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/post_img/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.jpg">
<meta property="article:published_time" content="2022-09-08T14:00:57.000Z">
<meta property="article:modified_time" content="2022-09-08T14:01:28.067Z">
<meta property="article:author" content="madao33">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="offer">
<meta property="article:tag" content="后端开发">
<meta property="article:tag" content="八股文">
<meta property="article:tag" content="摆烂">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/post_img/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>面试笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>madao33</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://madao33-static.oss-cn-hangzhou.aliyuncs.com/post_img/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="总结一下面试之后不太熟悉的一些东西"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-08 22:00" pubdate>
          September 8, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          44k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          367 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">总结一下面试之后不太熟悉的一些东西</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试笔记"><a href="#面试笔记" class="headerlink" title="面试笔记"></a>面试笔记</h1><p>总结Java后端相关的重要知识点</p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ul>
<li>简单易学、有丰富的类库</li>
<li>面向对象</li>
<li>与平台无关性，主要是JVM虚拟机的支持</li>
<li>可靠安全</li>
<li>支持多线程</li>
</ul>
<h3 id="你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"><a href="#你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点" class="headerlink" title="你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"></a>你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点</h3><ul>
<li>Java是面向对象的，比较符合人的认知</li>
<li>Java和C++都是面向对象的，都支持封装、继承和多态</li>
<li>Java不是通过指针访问内存的，程序的内存自动通过垃圾回收算法回收</li>
<li>Java单继承，C++支持多重继承，虽然Java不可以多继承，但是接口可以多继承</li>
</ul>
<h3 id="说一下Java的八种基本类型"><a href="#说一下Java的八种基本类型" class="headerlink" title="说一下Java的八种基本类型"></a>说一下Java的八种基本类型</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220801221127384.png" srcset="/img/loading.gif" lazyload alt="image-20220801221127384"></p>
<h3 id="讲一下int和Integer的区别"><a href="#讲一下int和Integer的区别" class="headerlink" title="讲一下int和Integer的区别"></a>讲一下int和Integer的区别</h3><ul>
<li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li>
<li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li>
<li>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java 虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素 boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字 节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的 是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="有了解过Java中ArrayList和LinkedList的区别"><a href="#有了解过Java中ArrayList和LinkedList的区别" class="headerlink" title="有了解过Java中ArrayList和LinkedList的区别"></a>有了解过Java中ArrayList和LinkedList的区别</h3><ul>
<li>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有 数据, (因为删除数据以后, 需要把后面所有的数据前移)</li>
<li>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于 ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap底层基于红黑树实现，可以保证在log(n)的时间复杂度内完成containsKey、get、put、remove操作。同时因为其由红黑树构成，也就是说明了能够维持内部元素的有序性，关于⽀持内部元素有序性的集合还有LinkedHashMap。 </p>
<p>部分细节：  </p>
<ol>
<li>红黑树相比于AVL树，牺牲了部分平衡性，以换取删除&#x2F;插⼊操作时少量的旋转次数，整体来说，性能优于AVL<br>树，但是做了性能测试，发现优化了的AVL树和红黑树相比差不了太多。  </li>
<li>AVL树为了维护严苛的平衡条件，在破坏了平衡之后（插⼊、删除），需要执⾏旋转操作。共分为四种：左单<br>旋、先左后右旋、右单旋、先右后左旋。  </li>
<li>TreeMap内部无扩容的概念，因为使⽤的是树的链式存储结构  </li>
<li>⽀持范围查找，查找最近的元素  </li>
<li>以为内部是按照key进⾏排序的，所以不⽀持key为null  </li>
<li>排序依据，根据存放的对象是否实现Comprable接⼝。若实现了，则依据其⾃定义的compareTo⽅法，否者<br>需要⾃定义外部比较器（Comparator），若是都未实现，则报错。</li>
</ol>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先队列，是0个或者多个元素构成的集合，集合中按照某种排序方式（元素⾃身的权重）进⾏排序，不保证内部<br>元素整体有序，但是每次弹出的元素的优先级最高&#x2F;低。 </p>
<p>内部的数据结构是堆，因为堆底层的结构是完全⼆叉树，对于树的存储包含有链式存储或者顺序存储，<br>PriorityQueue使用的是顺序存储，所以使用的是Object[]数组，然后利用完全⼆叉树的性质，解决⽗⼦节点关系问<br>题。 </p>
<p>默认实现是小根堆</p>
<p><strong>实现细节</strong></p>
<ol>
<li>未指定初始化容量⼤小，默认为11，感觉对于底层使用数组实现的集合，默认⼤小的规定好要没有啥规律可<br>循  </li>
<li>扩容比其他集合多了⼀步，在数组长度 &lt; 64 时，扩容为原先的两倍+2，超过64时，扩容为原先的1.5倍，同<br>时做了放溢出处理，⽀持最⼤元素个数Integer.MAX_VALUE;  </li>
<li>删除和插⼊操作均会破坏当前的堆结果，所以每次都需要调用siftUp、siftDown动态调整  </li>
<li>插⼊操作是插⼊当前堆的末尾，调用siftUp，⾃底向上调整  </li>
<li>删除操作弹出堆顶元素，然后将堆最后⼀个元素置于堆顶，调用siftDown，⾃顶向下调整  </li>
<li>同样具有fast-fail机制</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h4><ol>
<li><p>HashMap 底层是⼀个数组  </p>
</li>
<li><p>数组中每个元素是⼀个单向链表（即，采用拉链法解决哈希冲突）</p>
</li>
</ol>
<p>  单链表的节点每个节点是 Node&lt;K, V&gt; 类型（⻅下源码）  </p>
<ol start="3">
<li>同⼀个单链表中所有 Node 的 hash值不⼀定⼀样，但是他们对应的数组下标⼀定⼀样</li>
</ol>
<p>  数组下标利用哈希函数&#x2F;哈希算法根据 hash值计算得到的  </p>
<ol start="4">
<li><p>HashMap 是数组和单链表的结合体  </p>
<ul>
<li>数组查询效率⾼，但是增删元素效率较低  </li>
<li>单链表在随机增删元素方⾯效率较⾼，但是查询效率较低  </li>
<li>HashMap 将⼆者结合起来，充分它们各⾃的优点</li>
</ul>
</li>
<li><p>HashMap 特点  </p>
<ul>
<li>无序、不可重复  </li>
<li>无序：因为不⼀定挂在那个单链表上了</li>
</ul>
</li>
<li><p>为什么不可重复？通过重写 equals 方法保证的</p>
</li>
</ol>
<h4 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="hljs-comment">     * by either of the constructors with arguments.</span><br><span class="hljs-comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The load factor used when none specified in constructor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment">     * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment">     * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment">     * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment">     * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment">     * shrinkage.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment">     * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment">     * between resizing and treeification thresholds.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Basic hash bin node, used for most entries.  (See below for</span><br><span class="hljs-comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br><br>        Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>HashMap默认初始化容量：16</p>
<ul>
<li>必须是2的次幂，主要是为了能够通过位运算获取key的索引位置，提升计算的效率</li>
<li>为了达到散列均匀，以便提高HashMap集合的存取效率</li>
</ul>
</li>
<li><p>HashMap默认加载因子：0.75f</p>
<ul>
<li>数组容量达到 $\frac{3}{4}$ 时，开始扩容</li>
</ul>
</li>
<li><p>扩容操作</p>
<ul>
<li>扩容的哈希表将拥有两倍的原容量，因为计算元素落在哪个位置的时候是 <code>(n-1)&amp;hash</code>，<code>n</code>为数组长度，这样计算更加高效</li>
<li></li>
</ul>
</li>
<li><p>JDK 8 之后，对 HashMap 底层数据结构（单链表）进行了改进</p>
<ul>
<li>如果单链表元素超过8个，则将单链表转变为红黑树，大前提是整个Node数组容量&gt;64；</li>
<li>如果红黑树节点数量小于6时，会将红黑树重新变为单链表</li>
</ul>
</li>
</ul>
<p><strong>put()方法</strong></p>
<ol>
<li><p>先将 key, value 封装到 Node 对象中   </p>
</li>
<li><p>底层会调用 key 的 hashCode() 方法得出 hash 值   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过哈希函数&#x2F;哈希算法，将 hash 值转换为数组的下标</p>
</li>
</ol>
<ul>
<li>如果下标位置上没有任何元素，就把 Node 添加到这个位置上；  </li>
<li>如果下标位置上有但链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进行 equals 比<br>较<ul>
<li>如果所有的 equals 方法返回都是 false，那么这个新节点 Node 将被添加到链表的末尾；  </li>
<li>如果其中有⼀个 equals 返回了 true，那么链表中对应的这个节点的 value 将会被新节点 Node 的<br>value 覆盖。（保证了不可重复）</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>HashMap 中允许 key 和 value 为 null，但是只能有⼀个（不可重复）</li>
<li>HashTable 中 key 和 value 都不允许为 null</li>
</ol>
</blockquote>
<p><strong>get()方法</strong></p>
<ol>
<li>先调用 key 的 hashCode() 方法得出 hash 值  </li>
<li>通过哈希函数&#x2F;哈希算法，将 hash 值转换为数组的下标  </li>
<li>通过数组下标快速定位到数组中的某个位置：</li>
</ol>
<ul>
<li>如果这个位置上什么也没有（没有链表），则返回 null；  </li>
<li>如果这个位置上有单链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进⾏ equals 比<br>较。   <ul>
<li>如果所有的 equals 方法返回都是 false，那么 get 方法返回 null；  </li>
<li>如果其中有⼀个 equals 返回了 true，那么这个节点的 value 便是我们要找的 value，此时 get 方<br>法最终返回这个要找的 value。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>放在 HashMap 中 key 的元素（或者放在 HashSet 中的元素）需要同时重写 hashCode() 和 equals() 方<br>法</li>
<li>重写 hashCode() 方法时要达到散列分布均匀<ul>
<li>如果 hashCode() 方法返回⼀个固定的值，那么 HashMap 底层则变成了⼀个单链表；</li>
<li>如果 hashCode() 方法所有返回的值都不同，此时 HashMap 底层则变成了⼀个数组</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么使用并发编程"><a href="#为什么使用并发编程" class="headerlink" title="为什么使用并发编程"></a>为什么使用并发编程</h3><ul>
<li>可以充分利用CPU的计算能力</li>
<li>方便业务拆分，提升应用性能</li>
</ul>
<h3 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h3><ul>
<li>内存泄露</li>
<li>上下文切换</li>
<li>线程安全</li>
<li>死锁</li>
</ul>
<h3 id="并发编程的三要素"><a href="#并发编程的三要素" class="headerlink" title="并发编程的三要素"></a>并发编程的三要素</h3><ul>
<li>原子性：指的是一个或多个操作要么执行成功，要么全部执行失败</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到</li>
<li>有序性：线程执行的顺序按照代码的先后顺序执行(处理器为了实现指令流水线，可能会对一些执行进行重排序)</li>
</ul>
<h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><ul>
<li>原子性问题：分多线程之间通过synchronized或使用锁lock</li>
<li>缓存导致的可见性问题：synchronized、volatile、LCOK，可以解决可见性问题</li>
<li>编译优化的有序性问题：Happens-Before规则</li>
</ul>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是 同时执行。 </li>
<li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。 </li>
<li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不 安全情况，也就不存在临界区的问题。</li>
</ul>
<h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ul>
<li>进程：一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程 </li>
<li>线程：进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。</li>
</ul>
<p>进程与线程的区别 </p>
<ul>
<li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 </li>
<li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 </li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共 同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 </li>
<li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的 </li>
<li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。 </li>
<li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li>
</ul>
<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><ul>
<li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的 形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于 一次上下文切换。 </li>
<li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 </li>
<li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 </li>
<li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li>
</ul>
<h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul>
<li>互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等 待，直至占有资源的进程用毕释放。 </li>
<li>占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进 程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 </li>
<li>不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过 来。 </li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在 等B，B在等C，C在等A）</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812152510964.png" srcset="/img/loading.gif" lazyload alt="image-20220812152510964"></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812152523915.png" srcset="/img/loading.gif" lazyload alt="image-20220812152523915"></p>
<h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>CAS是CompareAndSwap的缩写，中文意思是比较并替换。</p>
<p>当要进行CAS操作时，先比较内存地址和原来预期的地址比较，如果相同，表示这块内存地址没有被修改，可以用新地址替换，否则说明该地址被修改了，取消替换操作。</p>
<ul>
<li>它的作用是可以将比较和交换转换为<strong>原子操作</strong>，这个原子操作直接由CPU保证，CAS可以保证共享变量赋值时的原子操作</li>
<li>是一种非阻塞算法的实现，可以在不使用锁的情况下实现多线程安全，是一种无锁算法</li>
</ul>
<p>缺点是：</p>
<ul>
<li>循环时间长开销大（自旋）<ul>
<li>如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能给CPU带来很大的开销</li>
<li>解决办法：破坏掉死循环，当超过一定时间或者一定次数时，退出</li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>当对一个共享变量操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性</li>
<li>解决方法：<ul>
<li>用锁来保证原子性</li>
<li>把多个共享变量合成一个共享变量来操作</li>
<li>封装成对象（JDK1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之前的原子性，可以把多个变量放到一个对象来进行CAS操作</li>
</ul>
</li>
</ul>
</li>
<li>ABA问题<ul>
<li>如果在内存地址V初次读取的值是A，并且在准备赋值的期间可能曾经被改为B，然后又改为A，在赋值前检查到仍然是A，这样CAS就会误认为它从来没有被修改过，这就是ABA问题</li>
<li>解决方法：<ul>
<li>可以使用带有标记的原子引用类<code>AtomicStampedReference</code>，可以通过控制变量值的版本来保证CAS的正确性，即在变量前面添加版本号，每次变量更新的时候把版本+1，这样变化过程A-B-A就变成1A-2B-3A</li>
<li>增加时间戳</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关于Java多线程的synchronized和ThreadLocal有了解过吗"><a href="#关于Java多线程的synchronized和ThreadLocal有了解过吗" class="headerlink" title="关于Java多线程的synchronized和ThreadLocal有了解过吗"></a>关于Java多线程的synchronized和ThreadLocal有了解过吗</h2><p>ThreadLocal<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java多线程同步之ThreadLocal与Synchromized](https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142^v39^pc_rank_v37&spm=1018.2226.3001.4187)">[1]</span></a></sup>和Synchronized都是为了解决多线程中相同变量的访问冲突问题，只是二者处理问题的思路和角度不同。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810161243255.png" srcset="/img/loading.gif" lazyload alt="image-20220810161243255"></p>
<p>简单的示例如下：两个线程分表获取了自己线程存放的变量，他们之间变量的获取并不会错乱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocaDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + localVar.get());<br>        <span class="hljs-comment">//清除本地内存中的本地变量</span><br>        localVar.remove();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_A&quot;</span>);<br>                print(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-comment">//打印本地变量</span><br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_B&quot;</span>);<br>                print(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ThreadLocal源码</strong></p>
<p>set()方法</p>
<ul>
<li>首先获取当前线程<code>thread</code>，并获取thread线程中的<code>ThreadLocalMap</code></li>
<li>如果当前线程的<code>ThreadLocalMap</code>不为空，直接更行value值，如果<code>map</code>为空，示例化<code>ThreadLocalMap</code>，并将value值初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">* InheritableThreadLocal.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  t the current thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the map</span><br><span class="hljs-comment">*/</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的<code>ThreadLocalMap</code>是什么，<code>CreateMap</code>又是什么，直接点击查看找到以下代码：</p>
<p>可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value</p>
<p><code>createMap</code>是直接调用<code>ThreadLocal</code>的构造方法，构造一个新的<code>ThreadLocalMap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br> <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">         * its main ref field as the key (which is always a</span><br><span class="hljs-comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">         * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">         * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            Object value;<br> <br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">* InheritableThreadLocal.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Construct a new map initially containing (firstKey, firstValue).</span><br><span class="hljs-comment">* ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="hljs-comment">* one when we have at least one entry to put in it.</span><br><span class="hljs-comment">*/</span><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>get()方法</p>
<ul>
<li>get方法同样和set方法一样，首先需要获取当前线程thread-t， 然后获取当前线程的threadlocals变量(ThreadLocalMap)</li>
<li>如果当前theadlocals变量不为空，将当前线程的引用this(ThreadLocal)作为键值获取value</li>
<li>如果当前threadlocals变量为空，需要对当前线程的threadlocals变量进行初始化，然后返回初始化值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns the value in the current thread&#x27;s copy of this</span><br><span class="hljs-comment">* thread-local variable.  If the variable has no value for the</span><br><span class="hljs-comment">* current thread, it is first initialized to the value returned</span><br><span class="hljs-comment">* by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the current thread&#x27;s value of this thread-local</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Variant of set() to establish initialValue. Used instead</span><br><span class="hljs-comment">* of set() in case user has overridden the set() method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the initial value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get the entry associated with key.  This method</span><br><span class="hljs-comment">* itself handles only the fast path: a direct hit of existing</span><br><span class="hljs-comment">* key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="hljs-comment">* designed to maximize performance for direct hits, in part</span><br><span class="hljs-comment">* by making this method readily inlinable.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p> remove方法</p>
<p>该方法就是将<code>ThreadLocal</code>对应的值从当前<code>Thread</code>中的<code>ThreadLocalMap</code>中删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Removes the current thread&#x27;s value for this thread-local</span><br><span class="hljs-comment">* variable.  If this thread-local variable is subsequently</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span><br><span class="hljs-comment">* reinitialized by invoking its &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method,</span><br><span class="hljs-comment">* unless its value is &#123;<span class="hljs-doctag">@linkplain</span> #set set&#125; by the current thread</span><br><span class="hljs-comment">* in the interim.  This may result in multiple invocations of the</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@code</span> initialValue&#125; method in the current thread.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p>ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。</p>
</blockquote>
<p>ThreadLocal常见使用场景</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望被多线程共享</li>
</ul>
<p>例如</p>
<ul>
<li><p>存储用户Session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadSession</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InfrastructureException &#123;<br>        <span class="hljs-type">Session</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Session) threadSession.get();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>                s = getSessionFactory().openSession();<br>                threadSession.set(s);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (HibernateException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfrastructureException</span>(ex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>数据跨层传输</p>
</li>
</ul>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Java中的synchronized，通过使⽤内置锁，来实现对共享变量的同步操作，进⽽解决了对共享变量操作的原⼦性、<br>保证了其他线程对共享变量的可⻅性、有序性，从⽽确保了并发情况下的线程安全。<br>同时synchronized是可重⼊的锁，避免了同⼀个线程重复请求⾃身已经获取的锁时出现死锁问题（请求于保持、不<br>可剥夺感觉都有体现）</p>
<p><strong>用法</strong>：普通同步⽅法、静态同步⽅法、同步代码块</p>
<p><strong>内置锁</strong></p>
<p>在Java中，每个对象都有⼀把锁，放置于对象头中，⽤于记录当前对象被哪个线程所持有。<br>相对于实例数据，对象头属于额外开销，所以被设计的极⼩来提⾼效率（⼀个对象在堆中的分布：对象头、实例数<br>据、对⻬填充）。<br>对象头中的markword更加体现了这⼀点。markword⾮结构化的，这样在不同的锁状态下，能够复⽤相同的bit<br>位。markword中就有存储锁的信息的部分。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810155913925.png" srcset="/img/loading.gif" lazyload alt="image-20220810155913925"></p>
<p>Synchronized是Java保留关键字，通过线程等待，牺牲时间来解决访问冲突。依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程的访问变量，此时被用作锁机制的变量被多个线程共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlConnectionUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlPool instance=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SqlConnection <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>            instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPool</span>();<br>        <span class="hljs-keyword">return</span> instance.getSqlConnection();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="ThreadLocal和Synchronized的区别"><a href="#ThreadLocal和Synchronized的区别" class="headerlink" title="ThreadLocal和Synchronized的区别"></a>ThreadLocal和Synchronized的区别</h3><p>ThreadLocal<T>其实是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。</p>
<p>但是ThreadLocal与synchronized有本质的区别：</p>
<p>1、Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p>
<p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</p>
<p>而ThreadLoal却正好相反，它用于在多个线程间通信时能够获得数据共享。</p>
<blockquote>
<p>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</p>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。 </p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用</li>
</ul>
<p>ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入 不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Creates a new &#123;<span class="hljs-doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span><br><span class="hljs-comment">* parameters and default thread factory and rejected execution handler.</span><br><span class="hljs-comment">* It may be more convenient to use one of the &#123;<span class="hljs-doctag">@link</span> Executors&#125; factory</span><br><span class="hljs-comment">* methods instead of this general purpose constructor.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span><br><span class="hljs-comment">*        if they are idle, unless &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span><br><span class="hljs-comment">*        pool</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> keepAliveTime when the number of threads is greater than</span><br><span class="hljs-comment">*        the core, this is the maximum time that excess idle threads</span><br><span class="hljs-comment">*        will wait for new tasks before terminating.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> unit the time unit for the &#123;<span class="hljs-doctag">@code</span> keepAliveTime&#125; argument</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> workQueue the queue to use for holding tasks before they are</span><br><span class="hljs-comment">*        executed.  This queue will hold only the &#123;<span class="hljs-doctag">@code</span> Runnable&#125;</span><br><span class="hljs-comment">*        tasks submitted by the &#123;<span class="hljs-doctag">@code</span> execute&#125; method.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> workQueue&#125; is null</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>    <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相关参数的说明</p>
<ul>
<li>corePoolSize 核心线程数量 </li>
<li>maximumPoolSize 最大线程数量 </li>
<li>keepAliveTime 线程保持时间，N个时间单位 unit 时间单位（比如秒，分） </li>
<li>workQueue 阻塞队列 </li>
<li>threadFactory 线程工厂 </li>
<li>handler 线程池拒绝策略</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="说一下你对Java虚拟机的理解"><a href="#说一下你对Java虚拟机的理解" class="headerlink" title="说一下你对Java虚拟机的理解"></a>说一下你对Java虚拟机的理解</h2><h3 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802212445262.png" srcset="/img/loading.gif" lazyload></p>
<p>方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p>
<ul>
<li>Java堆（Heap），是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li>
<li>方法区（Method Area），方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li>
<li>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li>
</ul>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811130946227.png" srcset="/img/loading.gif" lazyload alt="image-20220811130946227"></p>
<ul>
<li>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li>
<li>加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。</li>
<li>最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ul>
<p>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811131032798.png" srcset="/img/loading.gif" lazyload alt="image-20220811131032798"></p>
<ul>
<li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li>
<li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li>
<li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、ParallelScavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802213622688.png" srcset="/img/loading.gif" lazyload alt="image-20220802213622688"></p>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
<li>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<ul>
<li>优点：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小。</li>
<li>缺点：浮动垃圾目前使用的非常少，真正普及还是需要写时间的。</li>
</ul>
</li>
</ul>
<p><strong>新生代收集器</strong>：Serial、ParNew、Parallel Scavenge</p>
<p><strong>老年代收集器</strong>：CMS、Serial Old、Parallel Old</p>
<p><strong>整堆收集器</strong>：G1，ZGC(因为不涉年代不在图中)。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="排序算法了解过吗，可以详细介绍一下吗"><a href="#排序算法了解过吗，可以详细介绍一下吗" class="headerlink" title="排序算法了解过吗，可以详细介绍一下吗"></a>排序算法了解过吗，可以详细介绍一下吗</h2><p>了解过一点，例如冒泡排序和选择排序</p>
<ul>
<li><p>冒泡排序：每一轮循环都是和相邻的元素比较，然后一步步的将最小的元素或者最大的元素排在前面，时间复杂度是 $O(n^2)$</p>
</li>
<li><p>选择排序：每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。每一趟通过不断地比较交换来使得首元素为当前最小，交换是一个比较耗时间的操作，我们可以通过设置一个值来记录较小元素的下标，循环结束后存储的就是当前最小元素的下标，这时再进行交换就可以了。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220802214609664.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[a];<br>	arr[a] = arr[b];<br>	arr[b] = tmp;<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">SimpleSelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span><br>&#123;<br>	<span class="hljs-type">int</span> min, len = arr.length;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len - <span class="hljs-number">1</span>;i++)<br>	&#123;<br>		min = i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;j &lt; len;j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (arr[min] &gt; arr[j])<br>			&#123;<br>				min = j;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (min != i)<br>		&#123;<br>			Swap(arr,min,i);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="写一下反转链表的代码，伪代码即可"><a href="#写一下反转链表的代码，伪代码即可" class="headerlink" title="写一下反转链表的代码，伪代码即可"></a>写一下反转链表的代码，伪代码即可</h2><p>了解的链表反转有两种方法：</p>
<ul>
<li>第一种是<strong>递归</strong>，递归的写法是需要明确两个条件：边界条件和递推关系<ul>
<li>先说一下<strong>递推关系</strong>：假设递归的顺序是先调整后面的结点，当前结点的后续结点都已经反转了，只需要反转当前结点和其后继结点的关系，这时候只需要将当前结点的后继结点的后继指向当前结点，即<code>cur.next.next = cur</code>，然后将当前结点的后继变为<code>null</code>，防止循环链表的出现，然后返回反转之后的头结点</li>
<li><strong>边界条件</strong>则是递归到最后一个节点，同时加上判断链表头结点是否为空的判断</li>
</ul>
</li>
<li>另一种就是<strong>双指针</strong>，双指针比起递归来说要更好理解一些<ul>
<li>首先设置两个指针<code>pre, cur</code>，分别表示前一个结点和当前结点</li>
<li>先设置一个临时变量保存当前结点的后继<code>Node temp = cur.next</code>，然后将当前结点的后继指向前一个结点<code>cur.next = pre</code>，这样实现了后继关系的反转，然后判断下一个，这时候的<code>pre = cur; cur = temp</code></li>
<li>反转结束之后返回<code>pre</code>为反转后链表的头结点</li>
</ul>
</li>
</ul>
<p>具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduInterview</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归实现链表反转</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 链表头结点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回反转后链表的头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newroot</span> <span class="hljs-operator">=</span> reverseLinkedList(root.next);<br>        root.next.next = root;<br>        root.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newroot;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList2</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过数组构建链表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> head 链表头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">constructLinkedList</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(num);<br>            temp.next = <span class="hljs-literal">null</span>;<br>            cur.next = temp;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> constructLinkedList(nums);<br><span class="hljs-comment">//        Node reversed2 = reverseLinkedList(root);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">reversed3</span> <span class="hljs-operator">=</span> reverseLinkedList2(root);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义链表结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">public</span> Node next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79980618)">[5]</span></a></sup>，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:</p>
<ol>
<li>每个节点都有红色或黑色</li>
<li>树的根始终是黑色的 (黑土地孕育黑树根， )</li>
<li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，<strong>并没有说不能出现连续的黑色节点</strong>）</li>
<li>从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</li>
</ol>
<p>一棵典型的红黑树如下图所示</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803220406437.png" srcset="/img/loading.gif" lazyload alt="image-20220803220406437"></p>
<p>关于红黑树的左旋右旋操作过多，后续再来详细记载，可以先查看这篇文章</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014454538/article/details/120120216">红黑树详解_晓之木初的博客-CSDN博客_红黑树</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="有了解过Java的设计模式吗，手写一个单例模式"><a href="#有了解过Java的设计模式吗，手写一个单例模式" class="headerlink" title="有了解过Java的设计模式吗，手写一个单例模式"></a>有了解过Java的设计模式吗，手写一个单例模式</h2><p>了解过一些，设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它<br>不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>单例模式、代理模式、模板方法模式、装饰器模式、工厂模式、责任链模式、观察者模式、原型模<br>式。</p>
<p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。<br>优点：不会频繁地创建和销毁对象，浪费系统资源。</p>
<p>单例模式有很多种的写法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[我给面试官讲解了单例模式后，他对我竖起了大拇指！](https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142^v39^pc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187)">[2]</span></a></sup>：</p>
<ul>
<li><p><strong>饿汉式单例模式</strong>的写法：线程安全</p>
<p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创建</strong>。</p>
<p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220803141933702.png" srcset="/img/loading.gif" lazyload alt="image-20220803141933702"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>懒汉式单例模式</strong>的写法：非线程安全</p>
<p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象，否则则先执行实例化操作。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803141920683.png" srcset="/img/loading.gif" lazyload alt="image-20220803141920683"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个单例模式是较为简单的写法，写完之后，面试官问如果在多线程的任务下，很多线程请求，可能会出现线程不安全的情况，都到达<code>if(singleton == null)</code>，可能会有复数个线程创建了不同的实例</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803142100572.png" srcset="/img/loading.gif" lazyload alt="image-20220803142100572"></p>
<p>如何解决这个问题，这个时候需要考虑加锁，也就是下面这个方式</p>
</li>
<li><p><strong>双检锁单例模式</strong>的写法：线程安全</p>
<p>一般在懒汉单例非线程的代码上进行修改有两种简便的方式：一种是给对象加锁，一种是给方法加锁</p>
<ul>
<li><p><strong>对象上锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方法加锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></li>
<li>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</li>
</ul>
</blockquote>
<p>直接在方法上加锁的方式被废除掉了，这种方式无论如何都需要先获取锁，所以在对象加锁代码的基础上进行优化</p>
<p>优化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>        <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码已经完美地解决了并发安全+性能低效问题：</p>
<ul>
<li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li>
<li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li>
<li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li>
<li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li>
</ul>
<p>上面这段代码已经近似完美了，但是还存在最后一个问题：<strong>指令重排</strong>，这个时候可以使用<code>volatile</code>防止指令重排</p>
<p>创建一个对象，在JVM中会经过三步：</p>
<ul>
<li><p>为singleton分配内存空间</p>
</li>
<li><p>初始化singleton对象</p>
</li>
<li><p>将singleton指向分配好的内存空间</p>
</li>
</ul>
<p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p>
<p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803143240854.png" srcset="/img/loading.gif" lazyload alt="image-20220803143240854"></p>
<p>使用volatile关键字可以<strong>防止指令重排序</strong>，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了</p>
<blockquote>
<p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p>
</blockquote>
<p>最终的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>拓展的方式，<strong>枚举实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是枚举类型的单例模式！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举实现的优点：</p>
<ul>
<li>对比饿汉和懒汉式来说，更加简洁</li>
<li>不需要做任何额外的操作去保证对象单一性与线程安全性</li>
<li>使用枚举可以防止调用者使用<strong>反射、序列化和反序列化</strong>机制强制生成多个单例对象，以此破坏单例模式</li>
</ul>
<blockquote>
<ul>
<li>单例模式常见的写法有两种：懒汉式、饿汉式</li>
<li>懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</li>
<li>饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</li>
<li>在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</li>
<li>如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</li>
<li>为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加volatile关键字防止指令重排序</li>
<li>最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</li>
</ul>
</blockquote>
<h2 id="有在项目中用到过这种设计模式吗"><a href="#有在项目中用到过这种设计模式吗" class="headerlink" title="有在项目中用到过这种设计模式吗"></a>有在项目中用到过这种设计模式吗</h2><p>在个人网站的开发过程中，每一个页面设置了一个head-img，使用的是枚举的单例模式实现的，在每一篇文章和每一个页面加载的时候创建图片的实例，并获取实例，为了加速访问数据，还将对应图片的路径&#x2F;链接保存在redis数据库中</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>HTTP<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HTTP 和 HTTPS 的区别（面试常考题）](https://blog.csdn.net/qq_36667170/article/details/121656279)">[3]</span></a></sup>：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
<p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803144740620.png" srcset="/img/loading.gif" lazyload alt="image-20220803144740620"></p>
<p>简要概括一下两者的区别就是：</p>
<p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p>
<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>
<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<h2 id="说一下加密算法，即https如何实现加密传输的"><a href="#说一下加密算法，即https如何实现加密传输的" class="headerlink" title="说一下加密算法，即https如何实现加密传输的"></a>说一下加密算法，即https如何实现加密传输的</h2><p>加密方法：SSL采用一种叫作公开秘钥加密的加密处理方式，近代的加密方法中加密算法是公开的，而秘钥是保密的，通过这种方式可以保持加密方法的安全性。</p>
<p>共享秘钥加密：加密和解密使用同一个秘钥的方式，在加密时必须要将秘钥也发给对方，在互联网转发秘钥时，如果通信被监听那么秘钥就可能会落入攻击者之手，同时也失去了加密的意义。</p>
<p>使用两把秘钥的公开秘钥加密：公开秘钥加密使用一堆非对称的秘钥，一把叫做私有秘钥，另一把叫做公开秘钥；发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有秘钥进行解密，利用这种方式，不需要发送用来解密的私有秘钥，也不必担心秘钥被攻击者窃听而盗走；但是他的处理速度相对共享秘钥来说很慢。</p>
<p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p>
<p>https采用对称加密与非对称加密的混合加密方式</p>
<p>混合加密方式原理：</p>
<ol>
<li>服务端将非对称加密的公钥发送给客户端；</li>
<li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li>
<li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li>
<li>二者利用对称加密的key对需要传输的消息做加解密传输。</li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>数据库有四个隔离级别：</p>
<ul>
<li><p><strong>读未提交（Read uncommitted)</strong></p>
<p>这种隔离级别下，可以读取还未提交的数据，并发最高，但是可能导致<strong>脏读</strong></p>
</li>
<li><p><strong>读已提交（Read committed）</strong></p>
<p>可以读取已经提交的数据，可以避免脏读，但是仍然存在<strong>不可重复读</strong>和<strong>幻读</strong>的现象</p>
</li>
<li><p><strong>可重复读（Repeated read)</strong></p>
<p>MySQL默认隔离级别，可以避免脏读，不可重复读的现象，但是仍然存在<strong>幻读</strong>的想想</p>
</li>
<li><p><strong>串行化（Serializable)</strong></p>
<p>可以避免幻读、不可重复读、幻读的发生</p>
</li>
</ul>
<blockquote>
<ul>
<li>脏读：一个事务在处理数据的过程中，读取到另一个未提交事务的数据</li>
<li>不可重复读：对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另一个事务修改并提交了，针对的是行级别的数据修改</li>
<li>幻读：对于同一查询，两次返回的数据统计不一致，针对的是表级别的新增数据，重点在于新增或者删除</li>
</ul>
</blockquote>
<h2 id="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"><a href="#有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗" class="headerlink" title="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"></a>有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗</h2><p>官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[一文搞懂MySQL索引所有知识点（建议收藏）](https://blog.csdn.net/qq_35190492/article/details/109257302)">[4]</span></a></sup>。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li><p>主键索引：索引列中的值必须是唯一的，不允许有空值</p>
</li>
<li><p>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p>
</li>
<li><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</p>
</li>
<li><p>全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。 MyISAM和InnoDB中都可以使用全文索引。</p>
</li>
<li><p>空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p>
</li>
<li><p>前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p>
</li>
<li><p>其他（按照索引列数量分类）</p>
<ul>
<li><p>单列索引</p>
</li>
<li><p>组合索引</p>
<p>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><p>Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803151811292.png" srcset="/img/loading.gif" lazyload alt="image-20220803151811292"></p>
<p>每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。</p>
<p>这个特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这就很难受很不稳定。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋&#x2F;右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。</p>
<p>使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。查询id&#x3D;6，只需要两次IO。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803152915087.png" srcset="/img/loading.gif" lazyload alt="image-20220803152915087"></p>
<p>就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：</p>
<p>时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10&#x3D;0.2s）</p>
<p>平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。</p>
<h4 id="B树：改造二叉树"><a href="#B树：改造二叉树" class="headerlink" title="B树：改造二叉树"></a>B树：改造二叉树</h4><p>MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。</p>
<p>为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k&#x2F;16&#x3D;1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000&#x3D;1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。</p>
<p>这种数据结构我们称为B树，B树是一种多叉平衡查找树，如下图主要特点：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803155515665.png" srcset="/img/loading.gif" lazyload alt="image-20220803155515665"></p>
<ol>
<li>B树的节点中存储着多个元素，每个内节点有多个分叉。</li>
<li>节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。</li>
<li>父节点当中的元素不会出现在子节点中。</li>
<li>所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。</li>
</ol>
<p>在B树中查询数据的例子：</p>
<blockquote>
<p>假如我们查询值等于10的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。</p>
<p>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10&lt;15，走左路，到磁盘寻址磁盘块2。</p>
<p>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;10，到磁盘中寻址定位到磁盘块5。</p>
<p>第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10&#x3D;10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。</p>
<p>相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162233851.png" srcset="/img/loading.gif" lazyload alt="image-20220803162233851"></p>
<p>虽然B树看来已经很理想了，但是仍然存在许多可以优化的地方：</p>
<ul>
<li>B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。</li>
<li>如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</li>
</ul>
</blockquote>
<h4 id="B-树：改造B树"><a href="#B-树：改造B树" class="headerlink" title="B+树：改造B树"></a>B+树：改造B树</h4><p>B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于<strong>非叶子节点是否存储数据</strong>的问题</p>
<ul>
<li>B树：非叶子节点和叶子节点都会存储数据。</li>
<li>B+树：<strong>只有叶子节点才会存储数据</strong>，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162526549.png" srcset="/img/loading.gif" lazyload alt="image-20220803162526549"></p>
<blockquote>
<p>B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟着增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点</p>
</blockquote>
<p><strong>等值查询</strong><br>假如我们查询值等于9的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块6。</p>
<ul>
<li>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，9&lt;15，走左路，到磁盘寻址磁盘块2。</li>
<li>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;9&lt;12，到磁盘中寻址定位到磁盘块6。</li>
<li>第三次磁盘IO：将磁盘块6加载到内存中，在内存中从头遍历比较，在第三个索引中找到9，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。（这里需要区分的是在InnoDB中Data存储的为行数据，而MyIsam中存储的是磁盘地址。）</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162810055.png" srcset="/img/loading.gif" lazyload alt="image-20220803162810055"></p>
<p><strong>范围查询</strong></p>
<p>假如我们想要查找9和26之间的数据。查找路径是磁盘块1-&gt;磁盘块2-&gt;磁盘块6-&gt;磁盘块7。</p>
<ul>
<li>首先查找值等于9的数据，将值等于9的数据缓存到结果集。这一步和前面等值查询流程一样，发生了三次磁盘IO。</li>
<li>查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块6，键值9开始向后遍历筛选所有符合筛选条件的数据。</li>
<li>第四次磁盘IO：根据磁盘6后继指针到磁盘中寻址定位到磁盘块7，将磁盘7加载到内存中，在内存中从头遍历比较，9&lt;25&lt;26，9&lt;26&lt;&#x3D;26，将data缓存到结果集。</li>
<li>主键具备唯一性（后面不会有&lt;&#x3D;26的数据），不需再向后查找，查询终止。将结果集返回给用户。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162902012.png" srcset="/img/loading.gif" lazyload alt="image-20220803162902012"></p>
<p><strong>可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构</strong></p>
<h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><h4 id="MyIsam索引"><a href="#MyIsam索引" class="headerlink" title="MyIsam索引"></a>MyIsam索引</h4><p>以一个简单的user表为例。user表存在两个索引，id列为主键索引，age列为普通索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = MyISAM<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8;<br><br></code></pre></td></tr></table></figure>

<p>MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。</p>
<p>主键索引的B+树如下图所示：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803163454024.png" srcset="/img/loading.gif" lazyload alt="image-20220803163454024"></p>
<p>表user的索引存储在索引文件<code>user.MYI</code>中，数据文件存储在数据文件 <code>user.MYD</code>中</p>
<p><strong>主键等值索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 28;<br></code></pre></td></tr></table></figure>

<ul>
<li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li>
<li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li>
<li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于30的索引项。（1次磁盘IO）</li>
<li>从索引项中获取磁盘地址，然后到数据文件user.MYD中获取对应整行记录。（1次磁盘IO）</li>
<li>将记录返给客户端。</li>
</ul>
<p><strong>磁盘IO次数：3次索引检索+记录数据检索。</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803164712589.png" srcset="/img/loading.gif" lazyload alt="image-20220803164712589"></p>
<p><strong>主键返回查询数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id between 28 and 47;<br></code></pre></td></tr></table></figure>

<ul>
<li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li>
<li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li>
<li>检索到叶节点，将节点加载到内存中遍历比较16&lt;28，18&lt;28，28&#x3D;28&lt;47。查找到值等于28的索引项。</li>
<li>根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li>
<li>我们的查询语句时范围查找，需要向后遍历底层叶子链表，直至到达最后一个不满足筛选条件。</li>
<li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，28&lt;47&#x3D;47，根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li>
<li>最后得到两条符合筛选条件，将查询结果集返给客户端。</li>
</ul>
<p><strong>磁盘IO次数：4次索引检索+记录数据检索</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165338794.png" srcset="/img/loading.gif" lazyload alt="image-20220803165338794"></p>
<blockquote>
<p>在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。</p>
<p>查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。</p>
</blockquote>
<h4 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h4><p>每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：</p>
<ul>
<li>在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。</li>
<li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li>
<li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li>
</ul>
<p>这里以user_innodb为例，user_innodb的id列为主键，age列为普通索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user_innodb`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure>

<p><strong>InnoDB主键索引</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165717554.png" srcset="/img/loading.gif" lazyload alt="image-20220803165717554"></p>
<p><strong>查询等值数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user_innodb where id = 28;<br></code></pre></td></tr></table></figure>

<ul>
<li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li>
<li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li>
<li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205600971.png" srcset="/img/loading.gif" lazyload alt="image-20220803205600971"></p>
<p><strong>辅助索引</strong></p>
<p>除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。</p>
<p>以表user_innodb的age列为例，age索引的索引结果如下图</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205628315.png" srcset="/img/loading.gif" lazyload alt="image-20220803205628315"></p>
<p>底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。</p>
<p>使用辅助索引需要<strong>检索两遍索引</strong>：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记录。</p>
<p><strong>辅助索引等值查询的情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where age=19;<br></code></pre></td></tr></table></figure>

<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205904722.png" srcset="/img/loading.gif" lazyload alt="image-20220803205904722"></p>
<p>根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为<strong>回表</strong>查询。</p>
<p><strong>磁盘IO数：辅助索引3次+获取记录回表3次</strong></p>
<p><strong>组合索引</strong></p>
<p>还是以自己创建的一个表为例：表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `abc_innodb`<br>(<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `a`  int(11)     DEFAULT NULL,<br>  `b`  int(11)     DEFAULT NULL,<br>  `c`  varchar(10) DEFAULT NULL,<br>  `d`  varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_abc` (`a`, `b`, `c`)<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure>

<p>组合索引的数据结构</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210223424.png" srcset="/img/loading.gif" lazyload alt="image-20220803210223424"></p>
<p><strong>组合索引的查询过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from abc_innodb where a = 13 and b = 16 and c = 4;<br></code></pre></td></tr></table></figure>

<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210836339.png" srcset="/img/loading.gif" lazyload alt="image-20220803210836339"></p>
<p><strong>最左匹配原则</strong></p>
<p>最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。</p>
<p>在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。</p>
<p>就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。</p>
<p>可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。、</p>
<p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong></p>
<p><strong>覆盖索引</strong></p>
<p>覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。</p>
<h2 id="可以讲一下如何优化数据库查询吗"><a href="#可以讲一下如何优化数据库查询吗" class="headerlink" title="可以讲一下如何优化数据库查询吗"></a>可以讲一下如何优化数据库查询吗</h2><h3 id="避免回表"><a href="#避免回表" class="headerlink" title="避免回表"></a>避免回表</h3><p>在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？</p>
<p>使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）</p>
<p>如果在一个场景下，<code>select id,name,sex from user where name =&#39;zhangsan&#39;;</code>这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。</p>
<p>这里就是一个典型的使用覆盖索引的优化策略减少回表的情况。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><strong>联合索引</strong>，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。</p>
<p><strong>联合索引的创建原则</strong>，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。</p>
<p><strong>联合索引的使用</strong></p>
<p>考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。<br>当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。</p>
<h2 id="数据库中的锁"><a href="#数据库中的锁" class="headerlink" title="数据库中的锁"></a>数据库中的锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>MySQL大致可归纳为以下3种锁：</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h3 id="MyIsam锁"><a href="#MyIsam锁" class="headerlink" title="MyIsam锁"></a>MyIsam锁</h3><p>在使用MyIsam时，我们<strong>只可以使用表级锁</strong>，而MySQL的表级锁有两种模式：</p>
<p><strong>表共享锁</strong>（Table Read Lock）和<strong>表独占写锁</strong>（Table Write Lock），他们在工作时表现如下：</p>
<ul>
<li>对某一个表的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</li>
<li>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；</li>
<li>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</li>
</ul>
<p>当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p>
<p>MyISAM在执行<strong>查询语句</strong>（SELECT）前，会自动给涉及的所有表<strong>加读锁</strong>，在<strong>执行更新操作</strong>（UPDATE、DELETE、INSERT等）前，会自动给涉及的表<strong>加写锁</strong>，这个过程并不需要用户干预</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p>
<p>行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>
<h4 id="事务（Transaction）及其ACID属性"><a href="#事务（Transaction）及其ACID属性" class="headerlink" title="事务（Transaction）及其ACID属性"></a>事务（Transaction）及其ACID属性</h4><p>  事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
<ul>
<li><strong>原子性（Actomicity）</strong>：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li><strong>一致性（Consistent）</strong>：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li><strong>持久性（Durable）</strong>：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>  相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
<ul>
<li><p><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</p>
</li>
<li><p><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</p>
</li>
<li><p><strong>不可重复读</strong>（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</p>
</li>
<li><p><strong>幻读</strong></p>
<p>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p>
<ul>
<li>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是<strong>间隙锁(Gap Lock)</strong></li>
</ul>
</li>
</ul>
<h4 id="InnoDB都有哪些锁"><a href="#InnoDB都有哪些锁" class="headerlink" title="InnoDB都有哪些锁"></a>InnoDB都有哪些锁</h4><ol>
<li>行锁<ol>
<li>共享锁（lock in share mode）</li>
<li>排他锁（for update）</li>
</ol>
</li>
<li>意向锁（表级别）<ol>
<li>意向共享锁</li>
<li>意向排他锁</li>
</ol>
</li>
<li>间隙锁</li>
<li>Next-key lock：行锁（排他锁）+间隙锁</li>
</ol>
<h4 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h4><p>InnoDB实现了以下两种类型的行锁。</p>
<ul>
<li><strong>共享锁（s）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。xxx lock in share mode</li>
<li><strong>排他锁（Ｘ）</strong>：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。xxx for update</li>
</ul>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>
<p><strong>意向共享锁（IS）</strong>：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p><strong>意向排他锁（IX）</strong>：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p><strong>InnoDB行锁是通过索引上的索引项来实现的</strong>，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁（如果是RR &#x2F; Serializable 级别，将在主键上使用Next-Key Locks（行锁+间隙锁）来实现锁表的操作）</p>
<blockquote>
<p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
</blockquote>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p> 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB（可重复读、串行化级别下才有效）会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁它通常是一个开区间（xx, xx）。</p>
<p>  InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求</p>
<blockquote>
<p> 很显然，<strong>在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待</strong>。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
</blockquote>
<h4 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h4><p>next-key lock是InnoDB加锁的基本单位，它是一个前开后闭的区间，即行锁+间隙锁</p>
<h4 id="InnoDB加锁规则"><a href="#InnoDB加锁规则" class="headerlink" title="InnoDB加锁规则"></a>InnoDB加锁规则</h4><p><strong>两个“原则”、两个“优化”和一个“bug”：</strong></p>
<ul>
<li>原则1：加锁的基本单位是next-key lock。next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h4 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h4><p> 对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p>
<ul>
<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>
<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>
</ul>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring的IOC和AOP吗"><a href="#Spring的IOC和AOP吗" class="headerlink" title="Spring的IOC和AOP吗"></a>Spring的IOC和AOP吗</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（面向切面）是一种编程范式，提供从另一个角度来考虑程序结构以完善面向对象编程（OOP）。<br>AOP为开发者提供了一种描述横切关注点的机制，并能够自动将横切关注点织入到面向对象的软件系统中，从而实现了横切关注点的模块化。<br>AOP能够将那些与业务无关，却为业务模块所共同调用的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E6%88%96&spm=1001.2101.3001.7020">逻辑或</a>责任，例如事务处理、日志管理、权限控制等，封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p><strong>使用AOP的好处</strong></p>
<ul>
<li>降低模块的耦合度</li>
<li>使系统容易扩展</li>
<li>提高代码复用性</li>
</ul>
<p><strong>AOP的基本概念</strong></p>
<ul>
<li>连接点（JoinPoint）：需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点。</li>
<li>切入点（Pointcut）：一组相关连接点的集合。</li>
<li>通知（Advice）：在连接点上执行的行为，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置增强（before advice）、后置增强 (after advice)、环绕增强 （around advice）。</li>
<li>切面（Aspect）：通知和切入点的结合。</li>
<li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</li>
<li>代理（Proxy）：通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</li>
<li>目标对象（Target）：需要被织入关注点的对象。即被代理的对象。</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803214934226.png" srcset="/img/loading.gif" lazyload alt="image-20220803214934226"></p>
<p>实现AOP的主要设计模式就是动态代理。</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（控制反转）就是依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。<br>Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是<strong>工厂模式</strong></p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803215056912.png" srcset="/img/loading.gif" lazyload alt="image-20220803215056912"></p>
<p><strong>使用IOC的好处</strong></p>
<ul>
<li>集中管理，实现类的可配置和易管理。</li>
<li>降低了类与类之间的耦合度</li>
</ul>
<h1 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h1><p>Tomcat 服务器<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[学习Tomcat这一篇就够了](http://t.csdn.cn/cQSkN)">[7]</span></a></sup>是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<h2 id="Tomcat的缺省端口"><a href="#Tomcat的缺省端口" class="headerlink" title="Tomcat的缺省端口"></a>Tomcat的缺省端口</h2><p>Tomcat目录下的conf文件夹下的server.xml文件中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">uriEncoding</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP&#x2F;IP协议来传递数据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端和服务器之间的通信格式。它的整个过程如下图所示：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907213344213.png" srcset="/img/loading.gif" lazyload alt="image-20220907213344213"></p>
<ol>
<li>用户通过浏览器进行了一个操作，比如输入网址并回车，或者是点击链接，接着浏览器获取了这个事件。</li>
<li>浏览器向服务端发出TCP连接请求。</li>
<li>服务程序接受浏览器的连接请求并经过TCP三次握手建立连接。</li>
<li>浏览器将请求数据打包成一个HTTP协议格式的数据包。</li>
<li>浏览器将该数据包推入网络，数据包经过网络传输，最终达到端服务程序。</li>
<li>服务端程序拿到这个数据包后，同样以HTTP协议格式解包，获取到客户端的意图。</li>
<li>得知客户端意图后进行处理，比如提供静态文件或者调用服务端程序获得动态结果。</li>
<li>服务器将响应结果（可能是HTML或者图片等）按照HTTP协议格式打包。</li>
<li>服务器将响应数据包推入网络，数据包经过网络传输最终达到到浏览器。</li>
<li>浏览器拿到数据包后，以HTTP协议的格式解包，然后解析数据，假设这里的数据是 HTML。</li>
<li>浏览器将HTML文件展示在页面上。</li>
</ol>
<h2 id="Tomcat整体架构"><a href="#Tomcat整体架构" class="headerlink" title="Tomcat整体架构"></a>Tomcat整体架构</h2><p>Tomcat要实现两个核心功能：</p>
<ol>
<li>处理Socket连接，负责网络字节流与Request和Response对象的转化。</li>
<li>加载和管理Servlet，以及具体处理Request请求。</li>
</ol>
<p>因此Tomcat设计了两个核心组件</p>
<ul>
<li><strong>连接器（Connector）</strong>：负责对外交流</li>
<li><strong>容器（Container）</strong>：负责内部处理</li>
</ul>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907214254671.png" srcset="/img/loading.gif" lazyload alt="image-20220907214254671"></p>
<h3 id="Coyote连接器架构"><a href="#Coyote连接器架构" class="headerlink" title="Coyote连接器架构"></a>Coyote连接器架构</h3><p>Coyote是Tomcat的连接器框架的名称 , 是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受响应 。</p>
<p>Coyote封装了底层的网络通信（Socket请求及响应处理），为Catalina容器提供了统一的接口，使Catalina容器与具体的请求协议及IO操作方式完全解耦。Coyote 将Socket输入转换封装为Request对象，交由Catalina容器进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流 。</p>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>布隆过滤器（Bloom Filter）<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/94433082)">[6]</span></a></sup>是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。</p>
<p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p>
<p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p>
<p>根据定义，布隆过滤器可以检查值是 <strong>“可能在集合中”</strong> 还是 <strong>“绝对不在集合中”</strong>。“可能” 表示有一定的概率，也就是说可能存在一定为误判率。那为什么会存在误判呢？下面我们来分析一下具体的原因。</p>
<p>布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，如下图所示。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221423444.png" srcset="/img/loading.gif" lazyload alt="image-20220803221423444"></p>
<p>为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221528106.png" srcset="/img/loading.gif" lazyload alt="image-20220803221528106"></p>
<p>如上图所示，当输入 “semlinker” 时，预设的 3 个哈希函数将输出 2、4、6，我们把相应位置 1。假设另一个输入 ”kakuqo“，哈希函数输出 3、4 和 7。你可能已经注意到，索引位 4 已经被先前的 “semlinker” 标记了。此时，我们已经使用 “semlinker” 和 ”kakuqo“ 两个输入值，填充了位向量。当前位向量的标记状态为：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221601391.png" srcset="/img/loading.gif" lazyload alt="image-20220803221601391"></p>
<p>当对值进行搜索时，与哈希表类似，我们将使用 3 个哈希函数对 ”搜索的值“ 进行哈希运算，并查看其生成的索引值。假设，当我们搜索 ”fullstack“ 时，3 个哈希函数输出的 3 个索引值分别是 2、3 和 7：</p>
<p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221742464.png" srcset="/img/loading.gif" lazyload alt="image-20220803221742464"></p>
<p>从上图可以看出，相应的索引位都被置为 1，这意味着我们可以说 ”fullstack“ 可能已经插入到集合中。事实上这是误报的情形，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。幸运的是，布隆过滤器有一个可预测的误判率（FPP）：<br>$$<br>P_{fpp} \approx (1-e^{-\frac{kn}{m}})^k<br>$$</p>
<ul>
<li>n 是已经添加元素的数量；</li>
<li>k 哈希的次数；</li>
<li>m 布隆过滤器的长度（如比特数组的大小）；</li>
</ul>
<p><strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在实际工作中，布隆过滤器常见的应用场景如下：</p>
<ul>
<li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li>
<li>Google Chrome 使用布隆过滤器识别恶意 URL；</li>
<li>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</li>
<li>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。 除了上述的应用场景之外，布隆过滤器还有一个应用场景就是解决缓存穿透的问题。所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。</li>
</ul>
<p>利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>可以创建一个Maven项目，在pom文件中引入以下坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.0-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后创建一个测试代码，初始化一百万条数据到过滤器中，然后在原有的基础上增加一万条数据，并且判断这些数据是否存在布隆过滤器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Charsets;<br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 总数量</span><br>        BloomFilter&lt;CharSequence&gt; bf = <br>          BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total);<br>        <span class="hljs-comment">// 初始化 1000000 条数据到过滤器中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total; i++) &#123;<br>            bf.put(<span class="hljs-string">&quot;&quot;</span> + i);<br>        &#125;<br>        <span class="hljs-comment">// 判断值是否存在过滤器中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total + <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bf.mightContain(<span class="hljs-string">&quot;&quot;</span> + i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;已匹配数量 &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得到的结果是</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">已匹配数量 <span class="hljs-number">1000309</span><br></code></pre></td></tr></table></figure>

<p>上述结果出现了五宝，误报率比预期多了309个元素<br>$$<br>\frac{309}{1000000+10000} \times 100% \approx 3.059%<br>$$</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142%5Ev39%5Epc_rank_v37&spm=1018.2226.3001.4187">Java多线程同步之ThreadLocal与Synchromized</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142%5Ev39%5Epc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187">我给面试官讲解了单例模式后，他对我竖起了大拇指！</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36667170/article/details/121656279">HTTP 和 HTTPS 的区别（面试常考题）</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190492/article/details/109257302">一文搞懂MySQL索引所有知识点（建议收藏）</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79980618">红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)</a>
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94433082">5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)</a>
<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a target="_blank" rel="noopener" href="http://t.csdn.cn/cQSkN">学习Tomcat这一篇就够了</a>
<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/offer/">#offer</a>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">#后端开发</a>
      
        <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">#八股文</a>
      
        <a href="/tags/%E6%91%86%E7%83%82/">#摆烂</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试笔记</div>
      <div>http://example.com/2022/09/08/面试记录/面试笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>madao33</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>September 8, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95-%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%880914%E5%A4%8D%E7%9B%98/" title="华为笔试-通用软件开发工程师-0914复盘">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">华为笔试-通用软件开发工程师-0914复盘</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/08/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="华为机试练习汇总记录">
                        <span class="hidden-mobile">华为机试练习汇总记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试突击刷题笔记</title>
    <link href="/2022/09/25/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/25/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode突击面试刷题"><a href="#LeetCode突击面试刷题" class="headerlink" title="LeetCode突击面试刷题"></a>LeetCode突击面试刷题</h1><h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>难度中等2229</p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/remove_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>题解</strong></p><p>首先设置一个指针<code>cur</code>，先往后走<code>n</code>步</p><p>再设置一个指针<code>pre</code>，初始化为<code>head</code></p><p>两个指针<code>cur</code>和<code>pre</code>同时向后移动，直到<code>cur.next==null</code>，这时候<code>pre</code>指向的就是倒数第k个结点的前驱，直接删除即可</p><blockquote><p>注意一个特殊情况：<code>n</code>等于链表长度的时候，就是删除第一个结点，直接返回</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">// 删除最后一个节点</span><br>        <span class="hljs-keyword">if</span> (cur.next == <span class="hljs-literal">null</span> &amp;&amp; n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> head.next;<br>        <br>        <span class="hljs-comment">// 找到删除节点的前驱结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 删除第k个结点</span><br>        pre.next = pre.next.next;<br>        <span class="hljs-keyword">return</span> head;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923182024626.png" alt="image-20220923182024626"></p><h2 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a><a href="https://leetcode.cn/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h2><p>难度简单266</p><p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong> 的连续子数组，并输出该最大平均数。</p><p>任何误差小于 <code>10-5</code> 的答案都将被视为正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,12,<span class="hljs-string">-5</span>,<span class="hljs-string">-6</span>,50,3], k = 4<br>输出：12.75<br>解释：最大平均数 (12<span class="hljs-string">-5</span><span class="hljs-string">-6</span><span class="hljs-string">+50</span>)/4 = 51/4 = 12.75<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">5</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= k &lt;= n &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>题解</strong></p><p><strong>前缀和+滑动窗口</strong></p><p>首先计算一下前缀和，然后利用滑动窗口计算对应区间的子数组和，并统计其中最大的区间和，最后输出与<code>k</code>的商</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMaxAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum[i+<span class="hljs-number">1</span>] = sum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i + k;<br>            <span class="hljs-keyword">if</span> (right &lt; n + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sum[right] - sum[i];<br>                ans = Math.max(ans, temp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans * <span class="hljs-number">1.0</span> / k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923203827589.png" alt="image-20220923203827589"></p><p><strong>直接滑动窗口</strong></p><p>直接通过滑动窗口计算滑动窗口中子数组的和，每次移动的时候减去上一个窗口左边界的值，加上下一个窗口右边界的值，记录其中窗口中的最大和，然后返回最大平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMaxAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = k - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            ans = Math.max(ans, sum);<br>            sum -= nums[left++];<br>            <span class="hljs-keyword">if</span> (right &gt;= n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            sum += nums[++right];<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans * <span class="hljs-number">1.0</span> / k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923204823308.png" alt="image-20220923204823308"></p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253. 会议室 II"></a><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></h2><p>难度中等474收藏分享切换为英文接收动态反馈</p><p>给你一个会议时间安排的数组 <code>intervals</code> ，每个会议时间都会包括开始和结束的时间 <code>intervals[i] = [starti, endi]</code> ，返回 <em>所需会议室的最小数量</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[0,30],[5,10],[15,20]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[7,10],[2,4]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>0 &lt;= starti &lt; endi &lt;= 106</code></li></ul><p>通过次数56,832</p><p>提交次数109,355</p><p><strong>题解</strong></p><p>考虑先将会议按照开始时间排序，需要多少会议室可以转换为同一时间在进行的最多有多少会议</p><ul><li>使用优先队列记录每个会议室的最晚结束的会议的结束时间</li><li>新来的会议如果开始时间比现有最早结束会议的结束时间早，那么就会存在冲突，必须开辟新的会议，并将这个新的会议的结束时间添加到优先队列</li><li>否则，则跳过，不用添加新的会议室</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b)-&gt;a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<br>            pq.offer(intervals[i][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; pq.peek()) &#123;<br>                ans++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pq.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923125740865.png" alt="image-20220923125740865"></p><h2 id="1057-校园自行车分配"><a href="#1057-校园自行车分配" class="headerlink" title="1057. 校园自行车分配"></a><a href="https://leetcode.cn/problems/campus-bikes/">1057. 校园自行车分配</a></h2><p>难度中等92收藏分享切换为英文接收动态反馈</p><p>在 X-Y 平面上表示的校园中，有 <code>n</code> 名工人和 <code>m</code> 辆自行车，其中 <code>n &lt;= m</code>。</p><p>给定一个长度为 <code>n</code> 的数组 <code>workers</code> ，其中 <code>worker [i] = [xi, yi]</code> 表示第 <code>i</code> 个工人的位置。你也得到一个长度为 <code>m</code> 的自行车数组 <code>bikers</code> ，其中 <code>bikes[j] = [xj, yj]</code> 是第 <code>j</code> 辆自行车的位置。所有给定的位置都是 <strong>唯一</strong> 的。</p><p>我们需要为每位工人分配一辆自行车。在所有可用的自行车和工人中，我们选取彼此之间 <strong>曼哈顿距离</strong> 最短的工人自行车对 <code>(workeri, bikej)</code> ，并将其中的自行车分配給工人。</p><p>如果有多个 <code>(workeri, bikej)</code> 对之间的 <strong>曼哈顿距离</strong> 相同，那么我们选择 <strong>工人索引最小</strong> 的那对。类似地，如果有多种不同的分配方法，则选择 <strong>自行车索引最小</strong> 的一对。不断重复这一过程，直到所有工人都分配到自行车为止。</p><p>返回长度为 <code>n</code> 的向量 <code>answer</code>，其中 <code>answer[i]</code> 是第 <code>i</code> 位工人分配到的自行车的索引（<strong>从 0 开始</strong>）。</p><p>给定两点 <code>p1</code> 和 <code>p2</code> 之间的 <strong>曼哈顿距离</strong> 为 <code>Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/1261_example_1_v2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：workers = <span class="hljs-string">[[0,0],[2,1]]</span>, bikes = <span class="hljs-string">[[1,2],[3,3]]</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>解释：工人 <span class="hljs-number">1</span> 分配到自行车 <span class="hljs-number">0</span>，因为他们最接近且不存在冲突，工人 <span class="hljs-number">0</span> 分配到自行车 <span class="hljs-number">1</span> 。所以输出是 [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/1261_example_2_v2.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：workers = <span class="hljs-comment">[<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[2,0]</span>]</span>, bikes = <span class="hljs-comment">[<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[2,1]</span>]</span><br>输出：<span class="hljs-comment">[0,2,1]</span><br>解释：工人 0 首先分配到自行车 0 。工人 1 和工人 2 与自行车 2 距离相同，因此工人 1 分配到自行车 2，工人 2 将分配到自行车 1 。因此输出为 <span class="hljs-comment">[0,2,1]</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == workers.length</code></li><li><code>m == bikes.length</code></li><li><code>1 &lt;= n &lt;= m &lt;= 1000</code></li><li><code>workers[i].length == bikes[j].length == 2</code></li><li><code>0 &lt;= xi, yi &lt; 1000</code></li><li><code>0 &lt;= xj, yj &lt; 1000</code></li><li>所有工人和自行车的位置都<strong>不相同</strong></li></ul><p><strong>题解</strong></p><p>可以直接将<code>worker</code>编号和<code>bike</code>编号以及距离<code>distance</code>组成三元组放在优先队列中，然后根据题目意思设置优先队列排序条件</p><p>然后遍历优先队列，获取分配情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] assignBikes(<span class="hljs-type">int</span>[][] workers, <span class="hljs-type">int</span>[][] bikes) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[workers.length];<br><br>        PriorityQueue&lt;Pair&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b)-&gt;&#123;<br>            <span class="hljs-keyword">if</span> (a.distance != b.distance)<br>                <span class="hljs-keyword">return</span> a.distance - b.distance;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.worker != b.worker)<br>                <span class="hljs-keyword">return</span> a.worker - b.worker;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> a.bike - b.bike;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workers.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bikes.length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> manhattenDistance(workers[i], bikes[j]);<br>                <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(i, j, distance);<br>                pq.offer(pair);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span>[] workered = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[workers.length];<br>        <span class="hljs-type">boolean</span>[] biked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[bikes.length];<br><br>        <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-keyword">if</span> (!workered[pair.worker] &amp;&amp; !biked[pair.bike]) &#123;<br>                ans[pair.worker] = pair.bike;<br>                workered[pair.worker] = <span class="hljs-literal">true</span>;<br>                biked[pair.bike] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">manhattenDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] worker, <span class="hljs-type">int</span>[] bike)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.abs(worker[<span class="hljs-number">0</span>] - bike[<span class="hljs-number">0</span>]) + Math.abs(worker[<span class="hljs-number">1</span>] - bike[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&#123;<br>    <span class="hljs-type">int</span> worker, bike, distance;<br>    Pair(<span class="hljs-type">int</span> worker, <span class="hljs-type">int</span> bike, <span class="hljs-type">int</span> distance) &#123;<br>        <span class="hljs-built_in">this</span>.worker = worker;<br>        <span class="hljs-built_in">this</span>.bike = bike;<br>        <span class="hljs-built_in">this</span>.distance = distance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923133857564.png" alt="image-20220923133857564"></p><h2 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h2><p>难度中等525收藏分享切换为英文接收动态反馈</p><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*)&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*))&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串大小将在 [1，100] 范围内。</li></ol><p><strong>题解</strong></p><p>可以定义左括号的数量上限为<code>l</code>，下限为<code>r</code>，遍历字符串，可能出现三种情况：</p><ul><li>当前字符为<code>(</code>，<code>l++, r++</code></li><li>当前字符为<code>)</code>，<code>l--, r--</code></li><li>当前字符为<code>*</code>，<code>l--, r++</code></li></ul><p>在判断过程中可能出现<code>l&lt;0</code>，重置为0，遍历过程中如果出现<code>l&gt;r</code>，那么括号不合法，直接返回<code>false</code></p><p>最后返回<code>l==0</code>的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                l++; r++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                l--; r--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l--; r++;<br>            &#125;<br>            l = Math.max(<span class="hljs-number">0</span>, l);<br>            <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923145218066.png" alt="image-20220923145218066"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h2><p>难度中等981</p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span>个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><p><strong>题解</strong></p><p>定义 $dp[l][r]$ 表示字符串从<code>l</code>到<code>r</code>这一段是否为回文，可以得到只要<code>dp[l+1][r-1]=true</code>且<code>s[l]=s[r]</code>即可以说<code>dp[l][r]</code>为回文</p><p>初始情况：<code>l=r</code>时，<code>dp[l][r] = true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt;= r; l++) &#123;<br>                <span class="hljs-keyword">if</span> (chars[l] == chars[r] &amp;&amp; (r - l &lt;= <span class="hljs-number">2</span> || dp[l+<span class="hljs-number">1</span>][r-<span class="hljs-number">1</span>])) &#123;<br>                    dp[l][r] = <span class="hljs-literal">true</span>;<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925215546662.png" alt="image-20220925215546662"></p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>难度中等5751</p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p><strong>题解</strong></p><p>同上一道题类似，需要注意一些边界问题的不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> s;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; r; l++) &#123;<br>                <span class="hljs-keyword">if</span> (chars[l] == chars[r] &amp;&amp; (r - l &lt;= <span class="hljs-number">2</span> || dp[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>])) &#123;<br>                    dp[l][r] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                        maxLen = r - l + <span class="hljs-number">1</span>;<br>                        start = l;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925214257338.png" alt="image-20220925214257338"></p><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p>难度中等1355</p><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/minpath.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p><strong>题解</strong></p><p>设置<code>dp[i][j]</code>表示到<code>grid[i][j]</code>的最短路径，可以得到动态转移方程<br>$$<br>dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j]<br>$$<br>注意初始化左上角的网格已经走过的路径为0，为了保证处理过程的问题，初始化dp为<code>Integer.MAX_VALUE</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length, m = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)<br>            Arrays.fill(dp[i], Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) + grid[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925224803941.png" alt="image-20220925224803941"></p><h1 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>难度中等2228</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p><strong>题解</strong></p><p>递归回溯法解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        dfs(<span class="hljs-number">0</span>, n, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(), nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> n, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cnt == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                path.add(nums[i]);<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(cnt + <span class="hljs-number">1</span>, n, path, nums, visited);<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>                visited[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923192716279.png" alt="image-20220923192716279"></p><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h2><p>难度中等1196</p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p><strong>题解</strong></p><p>这道题和全排列的思想类似，需要处理的一点就是去除重复的一点</p><p>可以添加一个判断条件</p><p><code>if (i &gt; 0 &amp;&amp; nums[i] == num[i-1] &amp;&amp; !visited[i-1])</code></p><p>这一个判断条件可以保证相邻元素的填入顺序是</p><ul><li>[未填入，未填入，未填入]</li><li>[填入，未填入，未填入]</li><li>[填入，填入，未填入]</li><li>[填入，填入，填入]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        dfs(<span class="hljs-number">0</span>, n, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(), nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> n, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cnt == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                <span class="hljs-comment">// 去除重复</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i-<span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                path.add(nums[i]);<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(cnt + <span class="hljs-number">1</span>, n, path, nums, visited);<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>                visited[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923201356717.png" alt="image-20220923201356717"></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>八股文</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为笔试-通用软件开发工程师-0914复盘</title>
    <link href="/2022/09/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95-%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%880914%E5%A4%8D%E7%9B%98/"/>
    <url>/2022/09/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95-%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%880914%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>听说华为面试可能会复盘笔试，这三道题属实有点难，一道题都没有AC，还是好好复盘一下，如果能进面试的话，可以留个好印象</p><span id="more"></span><h1 id="编程题1-超级玛丽过吊桥"><a href="#编程题1-超级玛丽过吊桥" class="headerlink" title="编程题1-超级玛丽过吊桥"></a>编程题1-超级玛丽过吊桥</h1><p>相当于青蛙跳台阶的改进版，走一个吊桥，吊桥的尽头是下水管道，其中随机的木板存在缺失，一旦踩到就会死亡，死亡后如果还有剩余的生命将在原地复活且不受模板缺失影响，但会消耗一次生命；如果跨过了管道，将坠入悬崖，通关失败。超级玛丽从起点S开始，可以走到下一个木板（计1），也可以跳着跨过一个块（计2）或两个木板（计3），最终必须刚好走到终点E，现在给定超级玛丽当前的生命数M，吊桥的长度N，缺失的木板数K，以及随机缺失的木板编号数组L，请帮忙计算一下，超级玛丽有多少种方法可以通过此关</p><p><strong>解答要求</strong></p><p>时间限制：C&#x2F;C++ 1000ms，其他语言：2000ms</p><p>内存现在：C&#x2F;C++ 256MB，其他语言：512MB</p><p><strong>输入</strong></p><p>超级玛丽当前生命数：$M(1\leq M \leq5)$ 整数</p><p>吊桥的长度：$N(1 \leq N \leq 32)$ 整数</p><p>缺失木板数：$K(1 \leq K \leq 32)$ 整数</p><p>缺失木板编号数组：$L$ （长度及编号的内容不大于 $N$ 的编号数组，$1 \leq L_i \leq N$，由空格分割的整数数组）</p><p>输入结构：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">M</span> <span class="hljs-built_in">N</span> <span class="hljs-built_in">K</span><br><span class="hljs-variable">L</span><br></code></pre></td></tr></table></figure><blockquote><p>提示：</p><ol><li>输入总是合法，忽略参数校验</li><li>必须从起点开始走</li><li>必须离开吊桥走到终点</li></ol></blockquote><p><strong>输出</strong></p><p>输出通过此关的吊桥走法个数，如果不能通过此关，请输出0</p><p><strong>样例1</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>解释：2个生命，2个木板，缺失1个木板，第二个木板有缺失，一共有四种走法：</p><ol><li>3</li><li>1， 2</li><li>2， 1</li><li>1， 1（复活），1</li></ol><p><strong>样例2</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>类似于这种跳台阶的，一般都可以考虑通过动态规划的方式来解决，和青蛙跳台阶的变化是需要考虑到生命的变化</p><p>定义一个二维矩阵<code>dp[m][i]</code>，表示走到当前<code>i</code>木板生命值为<code>m</code>的走法有多少，那么转移方程可以定义为：</p><ul><li><p>如果i木板不缺失：$dp[m][i] &#x3D; \sum_{k&#x3D;1}^3 dp[m][i-k]$</p></li><li><p>如果i木板缺失：$dp[m-1][i] &#x3D; \sum_{k&#x3D;1}^3 dp[m][i-k]$</p></li></ul><p>初始的起点也就是<code>dp[M][0]=1</code>，最后走到终点的方法为 $\sum_{m&#x3D;1}^M dp[m][N + 1]$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt(), n = scanner.nextInt(), k = scanner.nextInt();<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)<br>            set.add(scanner.nextInt());<br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">2</span>];<br>        dp[m][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lose</span> <span class="hljs-operator">=</span> set.contains(i) ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; x &gt;= Math.max(i - <span class="hljs-number">3</span>, <span class="hljs-number">0</span>); x--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>                    dp[j + lose][i] += dp[j][x];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m + <span class="hljs-number">1</span>; i++)<br>            ans += dp[i][n + <span class="hljs-number">1</span>];<br>        System.out.println(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编程题2-最快传输"><a href="#编程题2-最快传输" class="headerlink" title="编程题2-最快传输"></a>编程题2-最快传输</h1><p>有一批数据包需要传输，每个数据包大小不一样，传输需要不同的时长，现在有N个传输通道，每个通道的大小也不一样，通道只能传输小于等于自己大小的数据包，不同通道可以同时传输数据包，同道中可以缓存多个数据包，当新任务来时，可以先进入缓存队列等待发送，问最短需要多长时间能够传输完成，通道会确保所有数据包都可以传输</p><p><strong>解答要求</strong></p><p>时间限制：C&#x2F;C++ 1500ms，其他语言：3000ms</p><p>内存限制：C&#x2F;C++ 256MS，其他语言：512MB</p><p><strong>输入</strong></p><p>第一行M N，M表示队列长度，N表示传输通道数</p><p>第二行有N个数，表示每个通道的大小P</p><p>第三行有M个数，表示每个数据包的大小Q</p><p>第四行有M个数，表示每个数据包的传输时长S</p><p>$1 \leq M, S, P, Q \leq 10000$</p><p>$1 \leq N \leq 1000$</p><p><strong>输出</strong></p><p>输出传输完所有数据包需要的最短时长</p><p><strong>样例1</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">16<br></code></pre></td></tr></table></figure><p><strong>样例2</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">13</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">11</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">25</span> <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">25<br></code></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这种贪心的题确实有点在我的知识点范围之外，按照牛客网上的大佬的说法是，需要考虑三个贪心条件：</p><ol><li>数据按照传输时间逆序排序，先处理传输时间最长的</li><li>在满足传输条件的所有通道里，优先选取最早空闲的，也就是最早完成自己通道内传输任务的，这样可以最小限度地增加通道的处理时间</li><li>如果最早空闲时间也相同，就选取传输能力最小的，将能力大的留给后面的任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>     <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>     <span class="hljs-comment">// 通道数</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>     <span class="hljs-comment">// [通道传输能力][空闲时间]</span><br>     <span class="hljs-type">int</span>[][] channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>         channels[i][<span class="hljs-number">0</span>] = scanner.nextInt();<br>     &#125;<br>     <span class="hljs-type">int</span>[][] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][<span class="hljs-number">2</span>];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>         <span class="hljs-comment">// 大小</span><br>         data[i][<span class="hljs-number">0</span>] = scanner.nextInt();<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>         <span class="hljs-comment">// 传输时长</span><br>         data[i][<span class="hljs-number">1</span>] = scanner.nextInt();<br>     &#125;<br>     <span class="hljs-comment">// 按传输时长逆序</span><br>     Arrays.sort(data, (a, b) -&gt; &#123;<br>         <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>]) &#123;<br>             <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>         &#125;<br>         <span class="hljs-keyword">return</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>];<br>     &#125;);<br>     <span class="hljs-comment">// 贪心1</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : data) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">minIdleTime</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-comment">// 遍历每个通道</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>             <span class="hljs-comment">// 需要满足传输条件</span><br>             <span class="hljs-keyword">if</span> (channels[i][<span class="hljs-number">0</span>] &gt;= d[<span class="hljs-number">0</span>]) &#123;<br>                 <span class="hljs-comment">// 贪心2</span><br>                 <span class="hljs-keyword">if</span> (channels[i][<span class="hljs-number">1</span>] &lt; minIdleTime) &#123;<br>                     ch = i;<br>                     minIdleTime = channels[i][<span class="hljs-number">1</span>];<br>                 &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channels[i][<span class="hljs-number">1</span>] == minIdleTime &amp;&amp; channels[i][<span class="hljs-number">0</span>] &lt; channels[ch][<span class="hljs-number">0</span>]) &#123;<br>                     <span class="hljs-comment">// 贪心3</span><br>                     ch = i;<br>                 &#125;<br>             &#125;<br>         &#125;<br>         channels[ch][<span class="hljs-number">1</span>] += d[<span class="hljs-number">1</span>];<br>     &#125;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>         max = Math.max(max, channels[i][<span class="hljs-number">1</span>]);<br>     &#125;<br>     System.out.println(max);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编程题3-路由规划"><a href="#编程题3-路由规划" class="headerlink" title="编程题3-路由规划"></a>编程题3-路由规划</h1><p>H公司新结了一个订单，需要帮助客户给一个IP传输网络（该网络由M个路由器组成，每个路由器与其他多个路由器之间物理连接固定）规划路由，使IP报文从起点到终点，传输距离最小。IP报文在传输时，有如下限制：</p><ol><li>IP报文头部有TTL字段表示生存周期。报文从起点经过中间多个路由器转发到终点，每经过一个路由器（包含起点）TTL减1。当TTL减到0时，该报文将不能转发，直接丢弃（若到达终点时TTL为0，则认为正常到达，不丢弃）</li><li>起点的IP报文的TTL为固定值，由输入给定</li></ol><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.svg"></p><p>a. 当IP报文的TTL&#x3D;255时，最短路径为6（经过路由器1-5-6-7，TTL减3），当走该路径到达终点时的TTL为252</p><p>b. 当IP报文的TTL为2时，最短路径为11（经过路由器1-8-7，TTL减2），走该路径到达终点时的TTL为0</p><p>C、当IP报文的TTL&#x3D;1时间，在生存周期内无法到达终点</p><p><strong>解答要求</strong></p><p>时间限制：C&#x2F;C++ 400ms，其他语言：800ms</p><p>内存限制：C&#x2F;C++ 256MB，其他语言：512MB</p><p><strong>输入</strong></p><p>第一行：4个整数，分别表示路由器连接边个数N，起点路由器ID，终点路由器ID，起点IP报文的TTL</p><p>第二行~第N+1行：路由器连接边信息，为3个正整数，分别为两个路由器ID和他们之间的距离L，比如1 5 2表示路由器1和路由器5物理连接在一起，它们之间的距离为2km；</p><p>用例保证输入：</p><ol><li>路由器连接边个数 $N \leq 500$；路由器ID为离散的正整数，其 $\leq 500$；路由器距离 $L \leq 1000$</li><li>两个路由器之间连接边信息唯一，比如不会同时存在1 5 2和1 5 3这种输入</li><li>起点IP报文的TTL $\leq 255$</li><li>起点和终点的路由器ID一定不一样</li></ol><p><strong>输出</strong></p><p>IP报文在生存周期内从起点到终点的最短距离和达到终点时的TTL。如果有多组数据，则输出达到终点时TTL最大的那组数据。如果无法到达终点，则输出-1</p><p><strong>样例1</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">7</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">252</span><br></code></pre></td></tr></table></figure><p><strong>样例2</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">7</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">11 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>样例3</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">255</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>样例4</strong></p><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">255</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">252</span><br></code></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>实在没想到好的办法，直接使用的dfs遍历，但是过了42%，后面提示超时，对于Java语言要求800ms，确实要求很严格，可能要换其他的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">finalPath</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">finalTtl</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(),<br>                start = scanner.nextInt(),<br>                end = scanner.nextInt(),<br>                ttl = scanner.nextInt();<br><br>        <span class="hljs-type">int</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> scanner.nextInt(), id2 = scanner.nextInt(), distance = scanner.nextInt();<br>            edges[id1][id2] = distance;<br>            edges[id2][id1] = distance;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        visited[start] = <span class="hljs-literal">true</span>;<br>        dfs(edges, start, end, <span class="hljs-number">0L</span>, ttl, visited);<br>        <span class="hljs-keyword">if</span> (finalPath == Long.MAX_VALUE) &#123;<br>            System.out.println(-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        System.out.println(finalPath + <span class="hljs-string">&quot; &quot;</span> + finalTtl);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> end, <span class="hljs-type">long</span> path, <span class="hljs-type">int</span> ttl, <span class="hljs-type">boolean</span>[] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ttl &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (cur == end) &#123;<br>            <span class="hljs-keyword">if</span> ((finalPath &gt; path) || (finalPath == path &amp;&amp; finalTtl &lt; ttl)) &#123;<br>                finalPath = path;<br>                finalTtl = ttl;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (edges[cur][i] != <span class="hljs-number">0</span> &amp;&amp; !visited[i]) &#123;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(edges, i, end, path + edges[cur][i], ttl - <span class="hljs-number">1</span>, visited);<br>                visited[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>华为</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试笔记</title>
    <link href="/2022/09/08/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>面试笔记</p><p>总结Java后端相关的重要知识点</p><span id="more"></span><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ul><li>简单易学、有丰富的类库</li><li>面向对象</li><li>与平台无关性，主要是JVM虚拟机的支持</li><li>可靠安全</li><li>支持多线程</li></ul><h3 id="你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"><a href="#你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点" class="headerlink" title="你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"></a>你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点</h3><ul><li>Java是面向对象的，比较符合人的认知</li><li>Java和C++都是面向对象的，都支持封装、继承和多态</li><li>Java不是通过指针访问内存的，程序的内存自动通过垃圾回收算法回收</li><li>Java单继承，C++支持多重继承，虽然Java不可以多继承，但是接口可以多继承</li></ul><h3 id="说一下Java的八种基本类型"><a href="#说一下Java的八种基本类型" class="headerlink" title="说一下Java的八种基本类型"></a>说一下Java的八种基本类型</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220801221127384.png" alt="image-20220801221127384"></p><h3 id="讲一下int和Integer的区别"><a href="#讲一下int和Integer的区别" class="headerlink" title="讲一下int和Integer的区别"></a>讲一下int和Integer的区别</h3><ul><li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li><li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li><li>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java 虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素 boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字 节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的 是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="有了解过Java中ArrayList和LinkedList的区别"><a href="#有了解过Java中ArrayList和LinkedList的区别" class="headerlink" title="有了解过Java中ArrayList和LinkedList的区别"></a>有了解过Java中ArrayList和LinkedList的区别</h3><ul><li>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有 数据, (因为删除数据以后, 需要把后面所有的数据前移)</li><li>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于 ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap底层基于红黑树实现，可以保证在log(n)的时间复杂度内完成containsKey、get、put、remove操作。同时因为其由红黑树构成，也就是说明了能够维持内部元素的有序性，关于⽀持内部元素有序性的集合还有LinkedHashMap。 </p><p>部分细节：  </p><ol><li>红黑树相比于AVL树，牺牲了部分平衡性，以换取删除&#x2F;插⼊操作时少量的旋转次数，整体来说，性能优于AVL<br>树，但是做了性能测试，发现优化了的AVL树和红黑树相比差不了太多。  </li><li>AVL树为了维护严苛的平衡条件，在破坏了平衡之后（插⼊、删除），需要执⾏旋转操作。共分为四种：左单<br>旋、先左后右旋、右单旋、先右后左旋。  </li><li>TreeMap内部无扩容的概念，因为使⽤的是树的链式存储结构  </li><li>⽀持范围查找，查找最近的元素  </li><li>以为内部是按照key进⾏排序的，所以不⽀持key为null  </li><li>排序依据，根据存放的对象是否实现Comprable接⼝。若实现了，则依据其⾃定义的compareTo⽅法，否者<br>需要⾃定义外部比较器（Comparator），若是都未实现，则报错。</li></ol><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先队列，是0个或者多个元素构成的集合，集合中按照某种排序方式（元素⾃身的权重）进⾏排序，不保证内部<br>元素整体有序，但是每次弹出的元素的优先级最高&#x2F;低。 </p><p>内部的数据结构是堆，因为堆底层的结构是完全⼆叉树，对于树的存储包含有链式存储或者顺序存储，<br>PriorityQueue使用的是顺序存储，所以使用的是Object[]数组，然后利用完全⼆叉树的性质，解决⽗⼦节点关系问<br>题。 </p><p>默认实现是小根堆</p><p><strong>实现细节</strong></p><ol><li>未指定初始化容量⼤小，默认为11，感觉对于底层使用数组实现的集合，默认⼤小的规定好要没有啥规律可<br>循  </li><li>扩容比其他集合多了⼀步，在数组长度 &lt; 64 时，扩容为原先的两倍+2，超过64时，扩容为原先的1.5倍，同<br>时做了放溢出处理，⽀持最⼤元素个数Integer.MAX_VALUE;  </li><li>删除和插⼊操作均会破坏当前的堆结果，所以每次都需要调用siftUp、siftDown动态调整  </li><li>插⼊操作是插⼊当前堆的末尾，调用siftUp，⾃底向上调整  </li><li>删除操作弹出堆顶元素，然后将堆最后⼀个元素置于堆顶，调用siftDown，⾃顶向下调整  </li><li>同样具有fast-fail机制</li></ol><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h4><ol><li><p>HashMap 底层是⼀个数组  </p></li><li><p>数组中每个元素是⼀个单向链表（即，采用拉链法解决哈希冲突）</p></li></ol><p>  单链表的节点每个节点是 Node&lt;K, V&gt; 类型（⻅下源码）  </p><ol start="3"><li>同⼀个单链表中所有 Node 的 hash值不⼀定⼀样，但是他们对应的数组下标⼀定⼀样</li></ol><p>  数组下标利用哈希函数&#x2F;哈希算法根据 hash值计算得到的  </p><ol start="4"><li><p>HashMap 是数组和单链表的结合体  </p><ul><li>数组查询效率⾼，但是增删元素效率较低  </li><li>单链表在随机增删元素方⾯效率较⾼，但是查询效率较低  </li><li>HashMap 将⼆者结合起来，充分它们各⾃的优点</li></ul></li><li><p>HashMap 特点  </p><ul><li>无序、不可重复  </li><li>无序：因为不⼀定挂在那个单链表上了</li></ul></li><li><p>为什么不可重复？通过重写 equals 方法保证的</p></li></ol><h4 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="hljs-comment">     * by either of the constructors with arguments.</span><br><span class="hljs-comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The load factor used when none specified in constructor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment">     * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment">     * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment">     * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment">     * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment">     * shrinkage.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment">     * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment">     * between resizing and treeification thresholds.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Basic hash bin node, used for most entries.  (See below for</span><br><span class="hljs-comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br><br>        Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>HashMap默认初始化容量：16</p><ul><li>必须是2的次幂，主要是为了能够通过位运算获取key的索引位置，提升计算的效率</li><li>为了达到散列均匀，以便提高HashMap集合的存取效率</li></ul></li><li><p>HashMap默认加载因子：0.75f</p><ul><li>数组容量达到 $\frac{3}{4}$ 时，开始扩容</li></ul></li><li><p>扩容操作</p><ul><li>扩容的哈希表将拥有两倍的原容量，因为计算元素落在哪个位置的时候是 <code>(n-1)&amp;hash</code>，<code>n</code>为数组长度，这样计算更加高效</li><li></li></ul></li><li><p>JDK 8 之后，对 HashMap 底层数据结构（单链表）进行了改进</p><ul><li>如果单链表元素超过8个，则将单链表转变为红黑树，大前提是整个Node数组容量&gt;64；</li><li>如果红黑树节点数量小于6时，会将红黑树重新变为单链表</li></ul></li></ul><p><strong>put()方法</strong></p><ol><li><p>先将 key, value 封装到 Node 对象中   </p></li><li><p>底层会调用 key 的 hashCode() 方法得出 hash 值   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过哈希函数&#x2F;哈希算法，将 hash 值转换为数组的下标</p></li></ol><ul><li>如果下标位置上没有任何元素，就把 Node 添加到这个位置上；  </li><li>如果下标位置上有但链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进行 equals 比<br>较<ul><li>如果所有的 equals 方法返回都是 false，那么这个新节点 Node 将被添加到链表的末尾；  </li><li>如果其中有⼀个 equals 返回了 true，那么链表中对应的这个节点的 value 将会被新节点 Node 的<br>value 覆盖。（保证了不可重复）</li></ul></li></ul><blockquote><ol><li>HashMap 中允许 key 和 value 为 null，但是只能有⼀个（不可重复）</li><li>HashTable 中 key 和 value 都不允许为 null</li></ol></blockquote><p><strong>get()方法</strong></p><ol><li>先调用 key 的 hashCode() 方法得出 hash 值  </li><li>通过哈希函数&#x2F;哈希算法，将 hash 值转换为数组的下标  </li><li>通过数组下标快速定位到数组中的某个位置：</li></ol><ul><li>如果这个位置上什么也没有（没有链表），则返回 null；  </li><li>如果这个位置上有单链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进⾏ equals 比<br>较。   <ul><li>如果所有的 equals 方法返回都是 false，那么 get 方法返回 null；  </li><li>如果其中有⼀个 equals 返回了 true，那么这个节点的 value 便是我们要找的 value，此时 get 方<br>法最终返回这个要找的 value。</li></ul></li></ul><blockquote><ul><li>放在 HashMap 中 key 的元素（或者放在 HashSet 中的元素）需要同时重写 hashCode() 和 equals() 方<br>法</li><li>重写 hashCode() 方法时要达到散列分布均匀<ul><li>如果 hashCode() 方法返回⼀个固定的值，那么 HashMap 底层则变成了⼀个单链表；</li><li>如果 hashCode() 方法所有返回的值都不同，此时 HashMap 底层则变成了⼀个数组</li></ul></li></ul></blockquote><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么使用并发编程"><a href="#为什么使用并发编程" class="headerlink" title="为什么使用并发编程"></a>为什么使用并发编程</h3><ul><li>可以充分利用CPU的计算能力</li><li>方便业务拆分，提升应用性能</li></ul><h3 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h3><ul><li>内存泄露</li><li>上下文切换</li><li>线程安全</li><li>死锁</li></ul><h3 id="并发编程的三要素"><a href="#并发编程的三要素" class="headerlink" title="并发编程的三要素"></a>并发编程的三要素</h3><ul><li>原子性：指的是一个或多个操作要么执行成功，要么全部执行失败</li><li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到</li><li>有序性：线程执行的顺序按照代码的先后顺序执行(处理器为了实现指令流水线，可能会对一些执行进行重排序)</li></ul><h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><ul><li>原子性问题：分多线程之间通过synchronized或使用锁lock</li><li>缓存导致的可见性问题：synchronized、volatile、LCOK，可以解决可见性问题</li><li>编译优化的有序性问题：Happens-Before规则</li></ul><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是 同时执行。 </li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。 </li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不 安全情况，也就不存在临界区的问题。</li></ul><h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ul><li>进程：一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程 </li><li>线程：进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。</li></ul><p>进程与线程的区别 </p><ul><li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 </li><li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 </li><li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共 同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 </li><li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的 </li><li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。 </li><li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>什么是线程安全？</strong></p><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><p><strong>如何实现线程安全？</strong></p><ul><li><p>第一种：<strong>互斥同步</strong></p><p><code>synchronized</code>锁</p><ul><li>普通同步方法，锁是当前的实例对象</li><li>静态同步方法，锁时当前类的Class对象</li><li>同步方法块，锁是<code>Synchronized</code>括号里匹配的对象</li></ul><p>如何实现：</p><p><code>synchronized</code>锁</p><ul><li><code>synchronized</code>经过编译之后，会在同步块的前后生成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，这两个字节码指令之后有一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。在执行<code>monitorenter</code>指令时，首先会尝试获取对象的锁，如果该对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加一。若获取对象失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放。</li><li><code>synchronized</code>用的锁是存放在对象头里面的，在jdk1.6之后，锁一共有四种状态：<ul><li><strong>无锁</strong>状态</li><li><strong>偏向锁</strong>状态（在对象头和栈帧中的锁记录存储偏向锁的线程id）</li><li><strong>轻量级锁</strong>状态（将对象头的markword复制到当前线程的栈帧的锁记录中，使用CAS操作将对象头中的markword指向栈帧的锁记录，如果成功，则线程就拥有了对象的锁。如果两个以上的线程争用一把锁的话，则膨胀为重量级说）</li><li><strong>重量级锁</strong></li></ul></li></ul></li><li><p>第二种：<strong>JUC包的重入锁</strong></p><blockquote><p>在使用<code>synchronized</code>的时候，只能有一个线程可以获取对象的锁，其他线程就会进入阻塞状态，阻塞状态就会引起线程的挂起和唤醒，会带来很大的性能问题，所以就出现了非阻塞同步的实现方法</p></blockquote><p>先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，如果共享数据有争用，就采取补偿措施（不断地重试）。</p><p>CAS是实现非阻塞同步的计算机指令，它有三个操作数：内存位置，旧的预期值，新值，在执行CAS操作时，<strong>当且仅当内存地址的值符合旧的预期值的时候</strong>，才会用新值来更新内存地址的值，否则就不执行更新。</p><p>使用方法：使用JUC包下的整数原子类<code>decompareAndSet()</code>和<code>getAndIncrement()</code>方法</p><p>缺点 ：ABA 问题  版本号来解决</p><p>只能保证一个变量的原子操作，解决办法：使用AtomicReference类来保证对象之间的原子性。可以把多个变量放在一个对象里。</p></li><li><p>第三种：<strong>无同步方法</strong></p><p>线程本地存储：将共享数据的可见性范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题</p><p>使用<code>ThreadLocal</code>类</p><p>常见的使用场景：</p><ul><li>解决数据库连接</li><li><code>Session</code>管理等</li></ul></li></ul><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><ul><li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的 形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于 一次上下文切换。 </li><li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 </li><li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 </li><li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li></ul><h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul><li>互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等 待，直至占有资源的进程用毕释放。 </li><li>占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进 程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 </li><li>不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过 来。 </li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在 等B，B在等C，C在等A）</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812152510964.png" alt="image-20220812152510964"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812152523915.png" alt="image-20220812152523915"></p><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>CAS是CompareAndSwap的缩写，中文意思是比较并替换。</p><p>当要进行CAS操作时，先比较内存地址和原来预期的地址比较，如果相同，表示这块内存地址没有被修改，可以用新地址替换，否则说明该地址被修改了，取消替换操作。</p><ul><li>它的作用是可以将比较和交换转换为<strong>原子操作</strong>，这个原子操作直接由CPU保证，CAS可以保证共享变量赋值时的原子操作</li><li>是一种非阻塞算法的实现，可以在不使用锁的情况下实现多线程安全，是一种无锁算法</li></ul><p>缺点是：</p><ul><li>循环时间长开销大（自旋）<ul><li>如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能给CPU带来很大的开销</li><li>解决办法：破坏掉死循环，当超过一定时间或者一定次数时，退出</li></ul></li><li>只能保证一个共享变量的原子操作<ul><li>当对一个共享变量操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性</li><li>解决方法：<ul><li>用锁来保证原子性</li><li>把多个共享变量合成一个共享变量来操作</li><li>封装成对象（JDK1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之前的原子性，可以把多个变量放到一个对象来进行CAS操作</li></ul></li></ul></li><li>ABA问题<ul><li>如果在内存地址V初次读取的值是A，并且在准备赋值的期间可能曾经被改为B，然后又改为A，在赋值前检查到仍然是A，这样CAS就会误认为它从来没有被修改过，这就是ABA问题</li><li>解决方法：<ul><li>可以使用带有标记的原子引用类<code>AtomicStampedReference</code>，可以通过控制变量值的版本来保证CAS的正确性，即在变量前面添加版本号，每次变量更新的时候把版本+1，这样变化过程A-B-A就变成1A-2B-3A</li><li>增加时间戳</li></ul></li></ul></li></ul><h2 id="关于Java多线程的synchronized和ThreadLocal有了解过吗"><a href="#关于Java多线程的synchronized和ThreadLocal有了解过吗" class="headerlink" title="关于Java多线程的synchronized和ThreadLocal有了解过吗"></a>关于Java多线程的synchronized和ThreadLocal有了解过吗</h2><p>ThreadLocal<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java多线程同步之ThreadLocal与Synchromized](https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142^v39^pc_rank_v37&spm=1018.2226.3001.4187)">[1]</span></a></sup>和Synchronized都是为了解决多线程中相同变量的访问冲突问题，只是二者处理问题的思路和角度不同。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p><p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810161243255.png" alt="image-20220810161243255"></p><p>简单的示例如下：两个线程分表获取了自己线程存放的变量，他们之间变量的获取并不会错乱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocaDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + localVar.get());<br>        <span class="hljs-comment">//清除本地内存中的本地变量</span><br>        localVar.remove();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_A&quot;</span>);<br>                print(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-comment">//打印本地变量</span><br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_B&quot;</span>);<br>                print(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ThreadLocal源码</strong></p><p>set()方法</p><ul><li>首先获取当前线程<code>thread</code>，并获取thread线程中的<code>ThreadLocalMap</code></li><li>如果当前线程的<code>ThreadLocalMap</code>不为空，直接更行value值，如果<code>map</code>为空，示例化<code>ThreadLocalMap</code>，并将value值初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">* InheritableThreadLocal.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  t the current thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the map</span><br><span class="hljs-comment">*/</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的<code>ThreadLocalMap</code>是什么，<code>CreateMap</code>又是什么，直接点击查看找到以下代码：</p><p>可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value</p><p><code>createMap</code>是直接调用<code>ThreadLocal</code>的构造方法，构造一个新的<code>ThreadLocalMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br> <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">         * its main ref field as the key (which is always a</span><br><span class="hljs-comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">         * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">         * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            Object value;<br> <br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">* InheritableThreadLocal.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Construct a new map initially containing (firstKey, firstValue).</span><br><span class="hljs-comment">* ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="hljs-comment">* one when we have at least one entry to put in it.</span><br><span class="hljs-comment">*/</span><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure><p>get()方法</p><ul><li>get方法同样和set方法一样，首先需要获取当前线程thread-t， 然后获取当前线程的threadlocals变量(ThreadLocalMap)</li><li>如果当前theadlocals变量不为空，将当前线程的引用this(ThreadLocal)作为键值获取value</li><li>如果当前threadlocals变量为空，需要对当前线程的threadlocals变量进行初始化，然后返回初始化值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns the value in the current thread&#x27;s copy of this</span><br><span class="hljs-comment">* thread-local variable.  If the variable has no value for the</span><br><span class="hljs-comment">* current thread, it is first initialized to the value returned</span><br><span class="hljs-comment">* by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the current thread&#x27;s value of this thread-local</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Variant of set() to establish initialValue. Used instead</span><br><span class="hljs-comment">* of set() in case user has overridden the set() method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the initial value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get the entry associated with key.  This method</span><br><span class="hljs-comment">* itself handles only the fast path: a direct hit of existing</span><br><span class="hljs-comment">* key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="hljs-comment">* designed to maximize performance for direct hits, in part</span><br><span class="hljs-comment">* by making this method readily inlinable.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><p> remove方法</p><p>该方法就是将<code>ThreadLocal</code>对应的值从当前<code>Thread</code>中的<code>ThreadLocalMap</code>中删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Removes the current thread&#x27;s value for this thread-local</span><br><span class="hljs-comment">* variable.  If this thread-local variable is subsequently</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span><br><span class="hljs-comment">* reinitialized by invoking its &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method,</span><br><span class="hljs-comment">* unless its value is &#123;<span class="hljs-doctag">@linkplain</span> #set set&#125; by the current thread</span><br><span class="hljs-comment">* in the interim.  This may result in multiple invocations of the</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@code</span> initialValue&#125; method in the current thread.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉</p><p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。</p></blockquote><p>ThreadLocal常见使用场景</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ul><p>例如</p><ul><li><p>存储用户Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadSession</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InfrastructureException &#123;<br>        <span class="hljs-type">Session</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Session) threadSession.get();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>                s = getSessionFactory().openSession();<br>                threadSession.set(s);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (HibernateException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfrastructureException</span>(ex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>数据跨层传输</p></li></ul><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Java中的synchronized，通过使⽤内置锁，来实现对共享变量的同步操作，进⽽解决了对共享变量操作的原⼦性、<br>保证了其他线程对共享变量的可⻅性、有序性，从⽽确保了并发情况下的线程安全。 同时synchronized是可重⼊的锁，避免了同⼀个线程重复请求⾃身已经获取的锁时出现死锁问题（请求于保持、不可剥夺感觉都有体现）</p><h4 id="Synchronized的三种用法"><a href="#Synchronized的三种用法" class="headerlink" title="Synchronized的三种用法"></a>Synchronized的三种用法</h4><p><strong>1 普通方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        &#125;<br>        System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        SynchronizedTest t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        SynchronizedTest t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t1.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面这个代码我们new了两个不同的对象。打印结果如下。线程2并没有等线程1执行完成后才执行，说明对于普通方法，如果是不同的对象实例锁是不起作用的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程2开始执行<br>线程2执行完毕<br>线程1执行完毕<br></code></pre></td></tr></table></figure><p>将代码改为一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        &#125;<br>        System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        SynchronizedTest t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程1执行完毕<br>线程2开始执行<br>线程2执行完毕<br></code></pre></td></tr></table></figure><p>可以看到同一个对象实例的时候，第二个线程只等第一个线程执行完成后才开始执行</p><p><strong>2 静态同步方法</strong></p><p>对于静态同步方法来说，锁的是<strong>当前类的<code>Class</code>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        &#125;<br>        System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                SynchronizedTest.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                SynchronizedTest.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程1执行完毕<br>线程2开始执行<br>线程2执行完毕<br></code></pre></td></tr></table></figure><p>只用第一个线程执行完成后才开始执行第二个线程</p><p><strong>3 同步方法块</strong></p><p>对于同步方法块来说，锁的是<code>synchronized</code>括号里配置的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>       Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span>(o.getClass())&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(name+<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        SynchronizedTest t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t.test(<span class="hljs-string">&quot;线程1&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        SynchronizedTest t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                t1.test(<span class="hljs-string">&quot;线程2&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">线程1开始执行<br>线程1执行完毕<br>线程2开始执行<br>线程2执行完毕<br></code></pre></td></tr></table></figure><p>第一个线程执行完成后才开始执行第二个线程</p><h4 id="Synchronized是一个重量级锁"><a href="#Synchronized是一个重量级锁" class="headerlink" title="Synchronized是一个重量级锁"></a>Synchronized是一个重量级锁</h4><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现<strong>线程之间的切换需要从用户态转换到核心态</strong>，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。</p><h4 id="Synchronized底层实现原理"><a href="#Synchronized底层实现原理" class="headerlink" title="Synchronized底层实现原理"></a>Synchronized底层实现原理</h4><p>同步方法通过<code>ACC_SYNCHRONIZED </code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。</p><p>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。每个对象自身维护着一个被加锁次数的计数器，当计数器不为0时，只有获得锁的线程才能再次获得锁</p><h4 id="Synchronized锁存储位置"><a href="#Synchronized锁存储位置" class="headerlink" title="Synchronized锁存储位置"></a>Synchronized锁存储位置</h4><p>Synchronized用的锁是存在java的对象头里面的。一个对象在new出来之后再内存中主要分为4个部分：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925143830445.png" alt="image-20220925143830445"></p><p>Mark Word：存储了对象的hashCode、GC信息、锁信息三部分。这部分占8字节。</p><p>Class Pointer：存储了指向类对象信息的指针。在64位JVM上有一个压缩指针选项-ClassPointer指针：-XX:+UseCompressedClassPointers 为4字节 不开启为8字节。默认是开启的。</p><p>实例数据(instance data)：记录了对象里面的变量数据。引用类型：-XX:+UseCompressedOops 为4字节 不开启为8字节 Oops Ordinary Object Pointers</p><p>Padding：作为对齐使用，对象在64位服务版本中，规定对象内存必须要能被8字节整除，如果不能整除，那么久靠对齐来不。举个例子：new出了一个对象，内存只占用18字节，但是规定要能被8整除，所以padding&#x3D;6</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925145308146.png" alt="image-20220925145308146"></p><h4 id="Synchronized锁的升级过程"><a href="#Synchronized锁的升级过程" class="headerlink" title="Synchronized锁的升级过程"></a>Synchronized锁的升级过程</h4><p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了 “偏向锁” 和 “轻量级锁”：锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。</p><p><strong>偏向锁</strong>：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中记录存储锁偏向的线程ID，以后该线程在进入同步块时先判断对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果存在就直接获取锁。</p><p><strong>轻量级锁</strong>：当其他线程尝试竞争偏向锁时，锁升级为轻量级锁。线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，标识其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p><strong>重量级锁</strong>：锁在原地循环等待的时候，是会消耗CPU资源的。所以自旋必须要有一定的条件控制，否则如果一个线程执行同步代码块的时间很长，那么等待锁的线程会不断的循环反而会消耗CPU资源。默认情况下锁自旋的次数是10 次，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。10次后如果还没获取锁，则升级为重量级锁。</p><p><strong>内置锁</strong></p><p>在Java中，每个对象都有⼀把锁，放置于对象头中，⽤于记录当前对象被哪个线程所持有。<br>相对于实例数据，对象头属于额外开销，所以被设计的极⼩来提⾼效率（⼀个对象在堆中的分布：对象头、实例数<br>据、对⻬填充）。<br>对象头中的markword更加体现了这⼀点。markword⾮结构化的，这样在不同的锁状态下，能够复⽤相同的bit<br>位。markword中就有存储锁的信息的部分。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810155913925.png" alt="image-20220810155913925"></p><p>Synchronized是Java保留关键字，通过线程等待，牺牲时间来解决访问冲突。依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程的访问变量，此时被用作锁机制的变量被多个线程共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlConnectionUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlPool instance=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SqlConnection <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>            instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPool</span>();<br>        <span class="hljs-keyword">return</span> instance.getSqlConnection();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal和Synchronized的区别"><a href="#ThreadLocal和Synchronized的区别" class="headerlink" title="ThreadLocal和Synchronized的区别"></a>ThreadLocal和Synchronized的区别</h3><p>ThreadLocal<T>其实是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。</p><p>但是ThreadLocal与synchronized有本质的区别：</p><p>1、Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p><p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</p><p>而ThreadLoal却正好相反，它用于在多个线程间通信时能够获得数据共享。</p><blockquote><p>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</p></blockquote><h3 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁(ReentrantLock)"></a>可重入锁(ReentrantLock)</h3><p>ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型</p><p><strong>公平锁</strong></p><p>可重入锁：就是一个线程在获取了锁之后，再次去获取同一个锁，这时候仅仅是把状态值进行累加</p><p>如果线程释放了一次锁，状态值减1。只有线程完全释放锁，状态值减到0，其他线程才有机会获取锁。</p><ul><li>状态：<code>volatile int state</code></li><li>获取锁线程：<code>Thread</code></li><li>排队队列：<code>Node</code>双向队列</li></ul><p><strong>非公平锁</strong></p><p>非公平锁时要唤醒阻塞的线程时，其他的线程抢占锁，阻塞的线程只能继续休眠</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池优点"><a href="#线程池优点" class="headerlink" title="线程池优点"></a>线程池优点</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。 </p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li><li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用‘</li></ul><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入 不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Creates a new &#123;<span class="hljs-doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span><br><span class="hljs-comment">* parameters and default thread factory and rejected execution handler.</span><br><span class="hljs-comment">* It may be more convenient to use one of the &#123;<span class="hljs-doctag">@link</span> Executors&#125; factory</span><br><span class="hljs-comment">* methods instead of this general purpose constructor.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span><br><span class="hljs-comment">*        if they are idle, unless &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span><br><span class="hljs-comment">*        pool</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> keepAliveTime when the number of threads is greater than</span><br><span class="hljs-comment">*        the core, this is the maximum time that excess idle threads</span><br><span class="hljs-comment">*        will wait for new tasks before terminating.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> unit the time unit for the &#123;<span class="hljs-doctag">@code</span> keepAliveTime&#125; argument</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> workQueue the queue to use for holding tasks before they are</span><br><span class="hljs-comment">*        executed.  This queue will hold only the &#123;<span class="hljs-doctag">@code</span> Runnable&#125;</span><br><span class="hljs-comment">*        tasks submitted by the &#123;<span class="hljs-doctag">@code</span> execute&#125; method.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">*         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> workQueue&#125; is null</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>    <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure><p>相关参数的说明</p><ul><li>corePoolSize 核心线程数量 </li><li>maximumPoolSize 最大线程数量 </li><li>keepAliveTime 线程保持时间，N个时间单位 unit 时间单位（比如秒，分） </li><li>workQueue 阻塞队列 </li><li>threadFactory 线程工厂 </li><li>handler 线程池拒绝策略</li></ul><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p>提交一个任务到线程池中，线程池的处理流程如下：</p><ul><li>判断<strong>线程池里的核心线程</strong>是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li><li>线程池判断<strong>工作队列</strong>是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925145950776.png" alt="image-20220925145950776"></p><h3 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h3><p><strong>execute方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//由它可以获取到当前有效的线程数和线程池的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 1.获取当前正在运行线程数是否小于核心线程池，是则新创建一个线程执行任务，否则将任务放到任务队列中</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="hljs-comment">// 标识行 &lt;------</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>)) <span class="hljs-comment">//在addWorker中创建工作线程执行任务</span><br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 2.当前核心线程池中全部线程都在运行workerCountOf(c) &gt;= corePoolSize，所以此时将线程放到任务队列中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    <span class="hljs-comment">//线程池是否处于运行状态，且是否任务插入任务队列成功</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            <span class="hljs-comment">//线程池是否处于运行状态，如果不是则使刚刚的任务出队</span><br>            reject(command); <span class="hljs-comment">//抛出RejectedExceptionException异常</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    <span class="hljs-comment">// 3.插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常</span><br>        reject(command);<span class="hljs-comment">//抛出RejectedExceptionException异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>addWorker方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br><span class="hljs-comment">/*首先会再次检查线程池是否处于运行状态，核心线程池中是否还有空闲线程，都满足条件过后则会调用compareAndIncrementWorkerCount先将正在运行的线程数+1，数量自增成功则跳出循环，自增失败则继续从头继续循环*/</span><br>　　...<br>　　<span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>　　　　<span class="hljs-keyword">break</span> retry;<br>　　...<br><span class="hljs-comment">/*正在运行的线程数自增成功后则将线程封装成工作线程Worker*/</span><br>　　<span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　　<span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　　<span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>　　<span class="hljs-keyword">try</span> &#123;<br>　　　　<span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;        <span class="hljs-comment">//全局锁</span><br>　　　　w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woker</span>(firstTask);        <span class="hljs-comment">//将线程封装为Worker工作线程</span><br>　　　　<span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>　　　　<span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>　　　　　　mainLock.lock();    <span class="hljs-comment">//获取全局锁</span><br><span class="hljs-comment">/*当持有了全局锁的时候，还需要再次检查线程池的运行状态等*/</span><br>　　　　　　<span class="hljs-keyword">try</span> &#123;<br>　　　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> clt.get();<br>　　　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);        <span class="hljs-comment">//线程池运行状态</span><br>　　　　　　　　<span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>))&#123;        <span class="hljs-comment">//线程池处于运行状态，或者线程池关闭且任务线程为空</span><br>　　　　　　　　　　<span class="hljs-keyword">if</span> (t.isAlive())    <span class="hljs-comment">//线程处于活跃状态，即线程已经开始执行或者还未死亡，正确的应线程在这里应该是还未开始执行的</span><br>　　　　　　　　　　　　<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>　　　　　　　　　　workers.add(w);    <span class="hljs-comment">//private final HashSet&lt;Worker&gt; wokers = new HashSet&lt;Worker&gt;();包含线程池中所有的工作线程，只有在获取了全局的时候才能访问它。将新构造的工作线程加入到工作线程集合中</span><br>　　　　　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> worker.size();    <span class="hljs-comment">//工作线程数量</span><br>　　　　　　　　　　<span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>　　　　　　　　　　　　largestPoolSize = s;<br>　　　　　　　　　　workerAdded = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//新构造的工作线程加入成功</span><br>　　　　　　　　&#125;<br>　　　　　　&#125; <span class="hljs-keyword">finally</span> &#123;<br>　　　　　　　　mainLock.unlock();<br>　　　　　　&#125;<br>　　 　　　　<span class="hljs-keyword">if</span> (workerAdded) &#123;<br>　　　　　　　　t.start();    <span class="hljs-comment">//在被构造为Worker工作线程，且被加入到工作线程集合中后，执行线程任务，注意这里的start实际上执行Worker中run方法，所以接下来分析Worker的run方法</span><br>　　　　　　　　workerStarted = <span class="hljs-literal">true</span>;<br>　　　　　　&#125;<br>　　　　&#125;<br>　　&#125; <span class="hljs-keyword">finally</span> &#123;<br>　　　　<span class="hljs-keyword">if</span> (!workerStarted)    <span class="hljs-comment">//未能成功创建执行工作线程</span><br>　　　　　　addWorkerFailed(w);    <span class="hljs-comment">//在启动工作线程失败后，将工作线程从集合中移除</span><br>　　&#125;<br>　　<span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Worker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ThreadPoolExecutor$Worker，它继承了AQS，同时实现了Runnable，所以它具备了这两者的所有特性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>　　<span class="hljs-keyword">final</span> Thread thread;<br>　　Runnable firstTask;<br>　　<span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable firstTask)</span> &#123;<br>　　　　setState(-<span class="hljs-number">1</span>);    <br>　　　　<span class="hljs-comment">//设置AQS的同步状态为-1，禁止中断，直到调用runWorker</span><br>　　　　<span class="hljs-built_in">this</span>.firstTask = firstTask;<br>　　　　<span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);   <br>　　　　 <span class="hljs-comment">//通过线程工厂来创建一个线程，将自身作为Runnable传递传递</span><br>　　&#125;<br>　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>　　　　runWorker(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">//运行工作线程</span><br>　　&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><code>worker</code>在执行完任务后，还会通过<code>getTask</code>方法循环获取工作队里的任务来执行</p></blockquote><h2 id="线程池案例"><a href="#线程池案例" class="headerlink" title="线程池案例"></a>线程池案例</h2><p><strong>创建线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingDeque;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedBlockingDeque&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">10</span>,<br>                <span class="hljs-number">60</span>,<br>                TimeUnit.SECONDS,<br>                queue<br>        );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExample</span>(), <span class="hljs-string">&quot;Thread&quot;</span> + i));<br>            System.out.println(<span class="hljs-string">&quot;线程中活跃的线程数：&quot;</span> + threadPool.getPoolSize());<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----&gt;队伍中阻塞的线程数：&quot;</span> + queue.size());<br>            &#125;<br>        &#125;<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">线程中活跃的线程数：1<br>线程中活跃的线程数：2<br>线程中活跃的线程数：3<br>线程中活跃的线程数：4<br>线程中活跃的线程数：5<br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：1</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：2</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：3</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：4</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：6<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：7<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：8<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：9<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：10<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@5cad8086[Running, pool size = 10, active threads = 10, queued tasks = 5, completed tasks = 0]<br>at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)<br>at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)<br>at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)<br>at com.madao33.ThreadPoolExample.main(ThreadPoolExample.java:27)<br><br></code></pre></td></tr></table></figure><p>从结果可以观察出：</p><ul><li>创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。</li><li>我们通过queue.size()的方法来获取工作队列中的任务数。</li><li>刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。</li></ul><p>当然，为了达到需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放</p><p><strong>饱和策略</strong></p><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是<code>AbortPolicy</code>，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：</p><ul><li><code>AbortPolicy</code>：直接抛出异常</li><li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>：不处理，丢弃掉。</li></ul><p>我们现在用第四种策略来处理上面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingDeque;<br><span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionHandler;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedBlockingDeque&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy();<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">10</span>,<br>                <span class="hljs-number">60</span>,<br>                TimeUnit.SECONDS,<br>                queue,<br>                handler<br>        );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExample</span>(), <span class="hljs-string">&quot;Thread&quot;</span> + i));<br>            System.out.println(<span class="hljs-string">&quot;线程中活跃的线程数：&quot;</span> + threadPool.getPoolSize());<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----&gt;队伍中阻塞的线程数：&quot;</span> + queue.size());<br>            &#125;<br>        &#125;<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里采用了丢弃策略后，就没有再抛出异常，而是直接丢弃。在某些重要的场景下，可以采用记录日志或者存储到数据库中，而不应该直接丢弃。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">线程中活跃的线程数：1<br>线程中活跃的线程数：2<br>线程中活跃的线程数：3<br>线程中活跃的线程数：4<br>线程中活跃的线程数：5<br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：1</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：2</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：3</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：4</span><br>线程中活跃的线程数：5<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：6<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：7<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：8<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：9<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：10<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br>线程中活跃的线程数：10<br><span class="hljs-meta prompt_">-----&gt;</span><span class="language-bash">队伍中阻塞的线程数：5</span><br><br>Process finished with exit code 0<br><br></code></pre></td></tr></table></figure><p><strong>Callable、Future、FutureTash</strong></p><p><code>Callable</code>与<code>Future</code>是在JAVA的后续版本中引入进来的，<code>Callable</code>类似于<code>Runnable</code>接口，实现<code>Callable</code>接口的类与实现<code>Runnable</code>的类都是可以被线程执行的任务</p><ul><li><code>Callable</code>是<code>Runnable</code>封装的异步运算任务。</li><li><code>Future</code>用来保存<code>Callable</code>异步运算的结果</li><li><code>FutureTask</code>封装<code>Future</code>的实体类</li></ul><p><code>Callable</code>与<code>Runnbale</code>的区别：</p><ul><li><code>Callable</code>定义的方法是call，而<code>Runnable</code>定义的方法是run<code>。</code></li><li><code>call</code>方法有返回值，而<code>run</code>方法是没有返回值的。</li><li><code>call</code>方法可以抛出异常，而<code>run</code>方法不能抛出异常。</li></ul><p><strong>Future</strong></p><p>future表示异步计算的结果，提供了以下方法，主要是判断任务是否完成，中断任务，获取任务执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>FutureTask</strong></p><p>可取消的异步计算，此类提供了对Future的基本实现，仅在计算完成时才能获取结果，如果计算尚未完成，则阻塞get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt;<br></code></pre></td></tr></table></figure><p>FutureTask不仅实现了Future接口，还实现了Runnable接口，所以不仅可以将FutureTask当成一个任务交给Executor来执行，还可以通过Thread来创建一个线程。</p><p><strong>Callable与FutureTask案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;callable do something&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallableTask</span>();<br>        FutureTask&lt;Integer&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(callable);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(future);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//尝试取消对此任务的执行</span><br>        future.cancel(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//判断是否在任务正常完成前取消</span><br>        System.out.println(<span class="hljs-string">&quot;future is cancel:&quot;</span> + future.isCancelled());<br>        <span class="hljs-keyword">if</span>(!future.isCancelled())<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;future is cancelled&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//判断任务是否已完成</span><br>        System.out.println(<span class="hljs-string">&quot;future is done:&quot;</span> + future.isDone());<br>        <span class="hljs-keyword">if</span>(!future.isDone())<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;future get=&quot;</span> + future.get());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//任务已完成</span><br>            System.out.println(<span class="hljs-string">&quot;task is done&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">callable do something<br>future is cancel:true<br>future is done:true<br>task is done<br></code></pre></td></tr></table></figure><p><strong>Callable与Future</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;进入call方法，开始休眠，休眠时间为： &quot;</span> + System.currentTimeMillis());<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;今天停电&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableThread</span>();<br>        Future&lt;String&gt; fu = es.submit(call);<br>        es.shutdown();<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">&quot;主线程休眠5秒，当前时间&quot;</span> + System.currentTimeMillis());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> fu.get();<br>        System.out.println(<span class="hljs-string">&quot;Future已拿到数据，str=&quot;</span> + str + <span class="hljs-string">&quot;;当前时间为：&quot;</span> + System.currentTimeMillis());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">进入call方法，开始休眠，休眠时间为： 1664097924448<br>主线程休眠5秒，当前时间1664097929462<br>Future已拿到数据，str=今天停电;当前时间为：1664097934459<br></code></pre></td></tr></table></figure><p>这里的future是直接扔到线程池里面去执行的。由于要打印任务的执行结果，所以从执行结果来看，主线程虽然休眠了5s，但是从Call方法执行到拿到任务的结果，这中间的时间差正好是10s，说明get方法会阻塞当前线程直到任务完成。</p><p>通过FutureTask也可以达到同样的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>      Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableThread</span>();<br>      FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(call);<br>      es.submit(task);<br>      es.shutdown();<br>      Thread.sleep(<span class="hljs-number">5000</span>);<br>      System.out.println(<span class="hljs-string">&quot;主线程等待5秒，当前时间为：&quot;</span> + System.currentTimeMillis());<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> task.get();<br>      System.out.println(<span class="hljs-string">&quot;Future已拿到数据，str=&quot;</span> + str + <span class="hljs-string">&quot;;当前时间为：&quot;</span> + System.currentTimeMillis());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过以上代码的组合，得到这样一个应用场景</p><p>如有一种场景中，方法A返回一个数据需要10s,A方法后面的代码运行需要20s，但是这20s的执行过程中，只有后面10s依赖于方法A执行的结果。如果与以往一样采用同步的方式，势必会有10s的时间被浪费，如果采用前面两种组合，则效率会提高：</p><ul><li>先把A方法的内容放到Callable实现类的call()方法中</li><li>在主线程中通过线程池执行A任务</li><li>执行后面方法中10秒不依赖方法A运行结果的代码</li><li>获取方法A的运行结果，执行后面方法中10秒依赖方法A运行结果的代码</li></ul><p>这样代码执行效率一下子就提高了，程序不必卡在A方法处。</p><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="说一下你对Java虚拟机的理解"><a href="#说一下你对Java虚拟机的理解" class="headerlink" title="说一下你对Java虚拟机的理解"></a>说一下你对Java虚拟机的理解</h2><h3 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802212445262.png"></p><p>方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p><ul><li>Java堆（Heap），是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li><li>方法区（Method Area），方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li></ul><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811130946227.png" alt="image-20220811130946227"></p><ul><li>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li><li>加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。</li><li>最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</li></ul><p>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811131032798.png" alt="image-20220811131032798"></p><ul><li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li><li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、ParallelScavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802213622688.png" alt="image-20220802213622688"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li><li>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<ul><li>优点：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小。</li><li>缺点：浮动垃圾目前使用的非常少，真正普及还是需要写时间的。</li></ul></li></ul><p><strong>新生代收集器</strong>：Serial、ParNew、Parallel Scavenge</p><p><strong>老年代收集器</strong>：CMS、Serial Old、Parallel Old</p><p><strong>整堆收集器</strong>：G1，ZGC(因为不涉年代不在图中)。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>是最基础的收集器，在JDK1.3.1之前是HotSpot虚拟机新生代收集器的唯一选择。他是一个单线程工作的收集器，其单线程的意义不是说它只会使用一个处理器或者一条收集线程去完成垃圾手机工作，更重要的腔调它在进行垃圾收集的时候，必须暂停其他所有工作线程，直到它收集结束。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220919171855626.png" alt="image-20220919171855626"></p><ul><li>在客户端模式下的<strong>默认新生代收集器</strong>，简单高效</li><li>在内存有限的情况下，是所有收集器里<strong>额外内存消耗最小</strong>的</li><li>单核处理器中或者处理器核心数较少的环境中，<strong>没有线程交互的开销</strong></li></ul><blockquote><p>Stop The World：垃圾回收算法在进行垃圾回收的时候暂停用户线程，导致的卡顿，感觉就像世界停止了一样</p></blockquote><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的<strong>多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：<code>-XX：SurvivorRatio</code>、<code>-XX：PretenureSizeThreshold</code>、<code>-XX：HandlePromotionFailure</code>等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220919173206845.png" alt="image-20220919173206845"></p><p>除了支持新生代多线程并行收集外，和Serial收集器没有太多创新之处，但是是不少运行在服务端的HotSpot虚拟机，尤其是JDK7之前首选的新生代收集器</p><p>同时，ParNew也可以和CMS收集器配合工作，CMS是一个老年代收集器，<strong>CMS激活后默认的新生代收集器就是ParNew收集器</strong></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器也是一款<strong>新生代收集器</strong>，它同样是基于<strong>标记-复制</strong>算法实现的收集器，也是能够并行收集的多线程收集器，它的目标是达到一个可控制的吞吐量（Throughtput)，所谓的吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值<br>$$<br>吞吐量&#x3D;\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}<br>$$<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是</p><ul><li>控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数</li><li>设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数</li></ul><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220920155351376.png" alt="image-20220920155351376"></p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的<strong>老年代</strong>版本，支持多线程并发收集，基于<strong>标记-整理</strong>算法实现</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220920155540697.png" alt="image-20220920155540697"></p><p>配合新生代Parallel Scavenge收集器使用，在注重吞吐量或者处理器资源较为稀缺的组合，可以优先考虑Parallel Scavenge</p><h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是基于<strong>标记-清除</strong>算法实现的，只会回收老年代和永久代，整个过程包含四个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220920203116064.png" alt="image-20220920203116064">其中<strong>初始标记、重新标记</strong>这两个步骤仍然需要“Stop The World”。</p><ul><li><strong>初始标记</strong>仅仅只是标记一下<strong>GCRoots能直接关联</strong>到的对象，速度很快；</li><li><strong>并发标记</strong>阶段就是<strong>从GC Roots的直接关联对象开始遍历整个对象图</strong>的过程，这个过程<strong>耗时较长</strong>但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li><li>而<strong>重新标记</strong>阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</li><li>最后是<strong>并发清除</strong>阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li></ul><blockquote><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</p></blockquote><p>虽说CMS有：<strong>并发收集、低停顿</strong>的优点，但是还是有一些缺点：</p><ul><li>首先，CMS收集器<strong>对处理器资源非常敏感</strong>。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）&#x2F;4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。</li><li>然后，由于<strong>CMS收集器无法处理“浮动垃圾”（Floating Garbage）</strong>，有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li><li>因为是基于<strong>标记-清除</strong>算法实现的收集器，所以收集结束会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC。</li></ul><h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式</p><p>G1是一款主要面向服务端应用的垃圾收集器。</p><p>G1开创的基于Region的堆内存布局，G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个<strong>大小相等的独立区域（Region）</strong>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够<strong>对扮演不同角色的Region采用不同的策略去处理</strong>，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>Region中还有一类<strong>特殊的Humongous区域，专门用来存储大对象</strong>。G1认为只要大小<strong>超过了一个Region容量一半</strong>的对象即可判定为大对象。</p><p>Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定，取值范围为1MB～32MB，且应为2的N次幂</p><p>超过了整个Region容量的超级大对象，将会被<strong>存放在N个连续的Humongous Region之中</strong>，G1的大多数行为都把Humongous Region<strong>作为老年代</strong>的一部分来进行看待</p><p>具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台<strong>维护一个优先级列表</strong>，每次根据用户设定<strong>允许的收集停顿时间</strong>（使用参数<code>-XX：MaxGCPauseMillis</code>指定，默认值是200毫秒），<strong>优先处理回收价值收益最大的那些Region</strong>，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220922112100355.png" alt="image-20220922112100355"></p><ul><li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li><strong>并发标记（Concurrent Marking）</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li><strong>最终标记（Final Marking）</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li></ul><blockquote><ul><li>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，它的目标是在延迟可控的情况下获得尽可能高的吞吐量</li><li>在<strong>小内存应用上CMS的表现大概率仍然要会优于G1</strong>，而在<strong>大内存应用上G1则大多能发挥其优势</strong>，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</li></ul></blockquote><h3 id="ZGC垃圾回收器"><a href="#ZGC垃圾回收器" class="headerlink" title="ZGC垃圾回收器"></a>ZGC垃圾回收器</h3><p>ZGC的核心是一个并发垃圾回收器，其设计的目标是：</p><ol><li>停顿时间不超过10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li><li>支持堆范围为8MB~4TB级别（未来支持16TB）。</li></ol><p>总之， ZGC的目的就是在减少暂停时间的同时，仍然能压缩堆</p><p><strong>ZGC内存管理</strong></p><p>ZGC中管理物理内存的基本单位是segment。segment默认与small page size一样，都是2MB。引入segment是为了避免频繁的申请和释放内存的系统调用，一次申请2MB，当segment空闲时，将加入空闲列表，等待之后重复使用。</p><p>ZGC为了能高效、灵活地管理内存，实现了两级内存管理：虚拟内存和物理内存，并且实现了物理内存和虚拟内存的映射关系。这和操作系统中虚拟地址和物理地址设计思路基本一致。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925204903234.png" alt="image-20220925204903234"></p><p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，ZGC同时会为该对象在Marked0、Marked1和Remapped三个视图空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址。</p><p>在ZGC中这三个空间在同一时间点有且仅有一个空间有效</p><p>为什么这么设计呢</p><p>这就是ZGC的高明之处，利用虚拟空间换时间</p><p>这三个空间的切换是由垃圾回收的不同阶段触发的，通过限定三个空间在同一时间点有且仅有一个空间有效高效的完成GC过程的并发操作，这个和ZGC并发处理算法有关系。ZGC并发处理算法利用全局空间视图的切换和对象地址视图的切换，结合SATB算法实现了高效的并发。</p><p><strong>染色指针</strong></p><p>我们都知道，之前的垃圾收集器都是把GC信息（标记信息、GC分代年龄..）存在对象头的Mark Word里。</p><p>而ZGC是这样做的：</p><p>如果某个对象是垃圾对象。就在这对象的信息里面标注这个对象是个垃圾。以后不管这个对象在哪儿使用，都知道他是个垃圾对象。</p><p>ZGC将对象信息存储在指针中，这种技术叫做——染色指针（Colored Pointer）。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925205522139.png" alt="image-20220925205522139"></p><p>在64位的机器中，对象指针是64位的。</p><p>ZGC使用64位地址空间的第0~43位存储对象地址，2^44 &#x3D; 16TB，所以ZGC最大支持16TB的堆。</p><p>而第44~47位作为颜色标志位，Marked0、Marked1和Remapped代表三个视图标志位，Finalizable表示这个对象只能通过finalizer才能访问。</p><p>第48~63位固定为0没有利用。</p><p><strong>读屏障</strong></p><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。不要把这个读屏障和Java内存模型里面的读屏障搞混了，两者根本不是同一个东西，ZGC中的读屏障更像是一种AOP技术，在字节码层面或者编译代码层面给读操作增加一个额外的处理。</p><p>ZGC作为一款优秀垃圾收集器了，其借鉴了Pauseless GC，但在G1都没有普及的今天，谈论ZGC似乎为时过早。但也许我们探讨的不是ZGC，而是ZGC背后的设计思路。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="排序算法了解过吗，可以详细介绍一下吗"><a href="#排序算法了解过吗，可以详细介绍一下吗" class="headerlink" title="排序算法了解过吗，可以详细介绍一下吗"></a>排序算法了解过吗，可以详细介绍一下吗</h2><p>了解过一点，例如冒泡排序和选择排序</p><ul><li><p>冒泡排序：每一轮循环都是和相邻的元素比较，然后一步步的将最小的元素或者最大的元素排在前面，时间复杂度是 $O(n^2)$</p></li><li><p>选择排序：每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。每一趟通过不断地比较交换来使得首元素为当前最小，交换是一个比较耗时间的操作，我们可以通过设置一个值来记录较小元素的下标，循环结束后存储的就是当前最小元素的下标，这时再进行交换就可以了。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220802214609664.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[a];<br>arr[a] = arr[b];<br>arr[b] = tmp;<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">SimpleSelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span><br>&#123;<br><span class="hljs-type">int</span> min, len = arr.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len - <span class="hljs-number">1</span>;i++)<br>&#123;<br>min = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;j &lt; len;j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[min] &gt; arr[j])<br>&#123;<br>min = j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (min != i)<br>&#123;<br>Swap(arr,min,i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="写一下反转链表的代码，伪代码即可"><a href="#写一下反转链表的代码，伪代码即可" class="headerlink" title="写一下反转链表的代码，伪代码即可"></a>写一下反转链表的代码，伪代码即可</h2><p>了解的链表反转有两种方法：</p><ul><li>第一种是<strong>递归</strong>，递归的写法是需要明确两个条件：边界条件和递推关系<ul><li>先说一下<strong>递推关系</strong>：假设递归的顺序是先调整后面的结点，当前结点的后续结点都已经反转了，只需要反转当前结点和其后继结点的关系，这时候只需要将当前结点的后继结点的后继指向当前结点，即<code>cur.next.next = cur</code>，然后将当前结点的后继变为<code>null</code>，防止循环链表的出现，然后返回反转之后的头结点</li><li><strong>边界条件</strong>则是递归到最后一个节点，同时加上判断链表头结点是否为空的判断</li></ul></li><li>另一种就是<strong>双指针</strong>，双指针比起递归来说要更好理解一些<ul><li>首先设置两个指针<code>pre, cur</code>，分别表示前一个结点和当前结点</li><li>先设置一个临时变量保存当前结点的后继<code>Node temp = cur.next</code>，然后将当前结点的后继指向前一个结点<code>cur.next = pre</code>，这样实现了后继关系的反转，然后判断下一个，这时候的<code>pre = cur; cur = temp</code></li><li>反转结束之后返回<code>pre</code>为反转后链表的头结点</li></ul></li></ul><p>具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduInterview</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归实现链表反转</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 链表头结点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回反转后链表的头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newroot</span> <span class="hljs-operator">=</span> reverseLinkedList(root.next);<br>        root.next.next = root;<br>        root.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newroot;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList2</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过数组构建链表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> head 链表头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">constructLinkedList</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(num);<br>            temp.next = <span class="hljs-literal">null</span>;<br>            cur.next = temp;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> constructLinkedList(nums);<br><span class="hljs-comment">//        Node reversed2 = reverseLinkedList(root);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">reversed3</span> <span class="hljs-operator">=</span> reverseLinkedList2(root);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义链表结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">public</span> Node next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79980618)">[5]</span></a></sup>，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:</p><ol><li>每个节点都有红色或黑色</li><li>树的根始终是黑色的 (黑土地孕育黑树根， )</li><li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，<strong>并没有说不能出现连续的黑色节点</strong>）</li><li>从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</li></ol><p>一棵典型的红黑树如下图所示</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803220406437.png" alt="image-20220803220406437"></p><p>关于红黑树的左旋右旋操作过多，后续再来详细记载，可以先查看这篇文章</p><p><a href="https://blog.csdn.net/u014454538/article/details/120120216">红黑树详解_晓之木初的博客-CSDN博客_红黑树</a></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="有了解过Java的设计模式吗，手写一个单例模式"><a href="#有了解过Java的设计模式吗，手写一个单例模式" class="headerlink" title="有了解过Java的设计模式吗，手写一个单例模式"></a>有了解过Java的设计模式吗，手写一个单例模式</h2><p>了解过一些，设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它<br>不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p><p>单例模式、代理模式、模板方法模式、装饰器模式、工厂模式、责任链模式、观察者模式、原型模<br>式。</p><p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。<br>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>单例模式有很多种的写法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[我给面试官讲解了单例模式后，他对我竖起了大拇指！](https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142^v39^pc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187)">[2]</span></a></sup>：</p><ul><li><p><strong>饿汉式单例模式</strong>的写法：线程安全</p><p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创建</strong>。</p><p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220803141933702.png" alt="image-20220803141933702"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>懒汉式单例模式</strong>的写法：非线程安全</p><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象，否则则先执行实例化操作。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803141920683.png" alt="image-20220803141920683"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这个单例模式是较为简单的写法，写完之后，面试官问如果在多线程的任务下，很多线程请求，可能会出现线程不安全的情况，都到达<code>if(singleton == null)</code>，可能会有复数个线程创建了不同的实例</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803142100572.png" alt="image-20220803142100572"></p><p>如何解决这个问题，这个时候需要考虑加锁，也就是下面这个方式</p></li><li><p><strong>双检锁单例模式</strong>的写法：线程安全</p><p>一般在懒汉单例非线程的代码上进行修改有两种简便的方式：一种是给对象加锁，一种是给方法加锁</p><ul><li><p><strong>对象上锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></li><li>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</li></ul></blockquote><p>直接在方法上加锁的方式被废除掉了，这种方式无论如何都需要先获取锁，所以在对象加锁代码的基础上进行优化</p><p>优化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>        <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经完美地解决了并发安全+性能低效问题：</p><ul><li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li><li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li></ul><p>上面这段代码已经近似完美了，但是还存在最后一个问题：<strong>指令重排</strong>，这个时候可以使用<code>volatile</code>防止指令重排</p><p>创建一个对象，在JVM中会经过三步：</p><ul><li><p>为singleton分配内存空间</p></li><li><p>初始化singleton对象</p></li><li><p>将singleton指向分配好的内存空间</p></li></ul><p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p><p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803143240854.png" alt="image-20220803143240854"></p><p>使用volatile关键字可以<strong>防止指令重排序</strong>，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了</p><blockquote><p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p></blockquote><p>最终的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>拓展的方式，<strong>枚举实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是枚举类型的单例模式！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举实现的优点：</p><ul><li>对比饿汉和懒汉式来说，更加简洁</li><li>不需要做任何额外的操作去保证对象单一性与线程安全性</li><li>使用枚举可以防止调用者使用<strong>反射、序列化和反序列化</strong>机制强制生成多个单例对象，以此破坏单例模式</li></ul><blockquote><ul><li>单例模式常见的写法有两种：懒汉式、饿汉式</li><li>懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</li><li>饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</li><li>在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</li><li>如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</li><li>为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加volatile关键字防止指令重排序</li><li>最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</li></ul></blockquote><h2 id="有在项目中用到过这种设计模式吗"><a href="#有在项目中用到过这种设计模式吗" class="headerlink" title="有在项目中用到过这种设计模式吗"></a>有在项目中用到过这种设计模式吗</h2><p>在个人网站的开发过程中，每一个页面设置了一个head-img，使用的是枚举的单例模式实现的，在每一篇文章和每一个页面加载的时候创建图片的实例，并获取实例，为了加速访问数据，还将对应图片的路径&#x2F;链接保存在redis数据库中</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络协议层次"><a href="#网络协议层次" class="headerlink" title="网络协议层次"></a>网络协议层次</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925222019385.png" alt="image-20220925222019385"></p><ul><li>应用层：HTTP，DNS(域名解析协议)，FTP(文件传输协议)</li><li>传输层：UDP,TCP</li><li>网络层：IP(网际协议)，ICMP(互联网控制报文协议），IGMP（互联网组管理协议），RIP</li></ul><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>知网掩码又叫网络掩码、地址掩码、子网络遮罩，是一个应用于TCP&#x2F;IP网络的32位二进制值。它可以屏蔽IP地址中的一部分，从而分离出IP地址中的网络部分与主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。它必须结合IP地址一起使用。</p><p><strong>如何通过子网掩码得到网络和主机地址</strong></p><ul><li>网络地址：二进制形式的IP地址与子网掩码的二进制做<strong>与</strong>运算，将结果转换为十进制就是网络地址</li><li>主机地址：将<strong>取反</strong>的子网掩码与IP地址做<strong>与</strong>，将结果转换为十进制得到主机地址</li></ul><p>例如：</p><p>ip地址：192.168.0.1  子网掩码：255.255.255.0</p><p>ip二进制：    11000000.10101000.00000000.00000001</p><p>子网二进制：11111111.11111111.11111111.00000000</p><p>网络地址：    11000000.10101000.00000000.00000000   192.168.0.0</p><p>主机地址：    00000000.00000000.00000000.00000001    0.0.0.1</p><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>HTTP<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HTTP 和 HTTPS 的区别（面试常考题）](https://blog.csdn.net/qq_36667170/article/details/121656279)">[3]</span></a></sup>：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p><p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803144740620.png" alt="image-20220803144740620"></p><p>简要概括一下两者的区别就是：</p><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><h2 id="说一下加密算法，即https如何实现加密传输的"><a href="#说一下加密算法，即https如何实现加密传输的" class="headerlink" title="说一下加密算法，即https如何实现加密传输的"></a>说一下加密算法，即https如何实现加密传输的</h2><p>加密方法：SSL采用一种叫作公开秘钥加密的加密处理方式，近代的加密方法中加密算法是公开的，而秘钥是保密的，通过这种方式可以保持加密方法的安全性。</p><p>共享秘钥加密：加密和解密使用同一个秘钥的方式，在加密时必须要将秘钥也发给对方，在互联网转发秘钥时，如果通信被监听那么秘钥就可能会落入攻击者之手，同时也失去了加密的意义。</p><p>使用两把秘钥的公开秘钥加密：公开秘钥加密使用一堆非对称的秘钥，一把叫做私有秘钥，另一把叫做公开秘钥；发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有秘钥进行解密，利用这种方式，不需要发送用来解密的私有秘钥，也不必担心秘钥被攻击者窃听而盗走；但是他的处理速度相对共享秘钥来说很慢。</p><p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p><p>https采用对称加密与非对称加密的混合加密方式</p><p>混合加密方式原理：</p><ol><li>用户在浏览器发起HTTPS请求( 如<a href="https://www.mogu.com/">https://www.mogu.com</a> )，默认使用服务端的443端口进行连接；</li><li>HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；</li><li>服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；</li><li>客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；</li><li>客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；</li><li>服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；</li><li>服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；</li><li>客户端使用随机Key对称解密密文，得到HTTP数据明文；</li><li>后续HTTPS请求使用之前交换好的随机Key进行对称加解密。</li></ol><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用</p><p>HTTP状态码分类</p><ul><li><code>1xx</code> 信息，服务器收到请求，需要请求者继续执行操作</li><li><code>2xx</code>  成功，操作被成功接收并处理</li><li><code>3xx</code> 重定向，需要进一步的操作以完成请求</li><li><code>4xx</code> 客户端错误，请求包含语法错误或无法完成请求</li><li><code>5xx</code> 服务器错误，服务器在处理请求的过程中发生了错误</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>数据库有四个隔离级别：</p><ul><li><p><strong>读未提交（Read uncommitted)</strong></p><p>这种隔离级别下，可以读取还未提交的数据，并发最高，但是可能导致<strong>脏读</strong></p></li><li><p><strong>读已提交（Read committed）</strong></p><p>可以读取已经提交的数据，可以避免脏读，但是仍然存在<strong>不可重复读</strong>和<strong>幻读</strong>的现象</p></li><li><p><strong>可重复读（Repeated read)</strong></p><p>MySQL默认隔离级别，可以避免脏读，不可重复读的现象，但是仍然存在<strong>幻读</strong>的想想</p></li><li><p><strong>串行化（Serializable)</strong></p><p>可以避免幻读、不可重复读、幻读的发生</p></li></ul><blockquote><ul><li>脏读：一个事务在处理数据的过程中，读取到另一个未提交事务的数据</li><li>不可重复读：对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另一个事务修改并提交了，针对的是行级别的数据修改</li><li>幻读：对于同一查询，两次返回的数据统计不一致，针对的是表级别的新增数据，重点在于新增或者删除</li></ul></blockquote><h2 id="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"><a href="#有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗" class="headerlink" title="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"></a>有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗</h2><p>官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[一文搞懂MySQL索引所有知识点（建议收藏）](https://blog.csdn.net/qq_35190492/article/details/109257302)">[4]</span></a></sup>。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul><li><p>主键索引：索引列中的值必须是唯一的，不允许有空值</p></li><li><p>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p></li><li><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</p></li><li><p>全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。 MyISAM和InnoDB中都可以使用全文索引。</p></li><li><p>空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p></li><li><p>前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p></li><li><p>其他（按照索引列数量分类）</p><ul><li><p>单列索引</p></li><li><p>组合索引</p><p>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。</p></li></ul></li></ul><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><p>Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803151811292.png" alt="image-20220803151811292"></p><p>每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。</p><p>这个特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这就很难受很不稳定。</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋&#x2F;右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。</p><p>使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。查询id&#x3D;6，只需要两次IO。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803152915087.png" alt="image-20220803152915087"></p><p>就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：</p><p>时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10&#x3D;0.2s）</p><p>平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。</p><h4 id="B树：改造二叉树"><a href="#B树：改造二叉树" class="headerlink" title="B树：改造二叉树"></a>B树：改造二叉树</h4><p>MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。</p><p>为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k&#x2F;16&#x3D;1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000&#x3D;1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。</p><p>这种数据结构我们称为B树，B树是一种多叉平衡查找树，如下图主要特点：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803155515665.png" alt="image-20220803155515665"></p><ol><li>B树的节点中存储着多个元素，每个内节点有多个分叉。</li><li>节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。</li><li>父节点当中的元素不会出现在子节点中。</li><li>所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。</li></ol><p>在B树中查询数据的例子：</p><blockquote><p>假如我们查询值等于10的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。</p><p>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10&lt;15，走左路，到磁盘寻址磁盘块2。</p><p>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;10，到磁盘中寻址定位到磁盘块5。</p><p>第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10&#x3D;10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。</p><p>相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162233851.png" alt="image-20220803162233851"></p><p>虽然B树看来已经很理想了，但是仍然存在许多可以优化的地方：</p><ul><li>B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。</li><li>如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</li></ul></blockquote><h4 id="B-树：改造B树"><a href="#B-树：改造B树" class="headerlink" title="B+树：改造B树"></a>B+树：改造B树</h4><p>B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于<strong>非叶子节点是否存储数据</strong>的问题</p><ul><li>B树：非叶子节点和叶子节点都会存储数据。</li><li>B+树：<strong>只有叶子节点才会存储数据</strong>，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162526549.png" alt="image-20220803162526549"></p><blockquote><p>B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟着增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点</p></blockquote><p><strong>等值查询</strong><br>假如我们查询值等于9的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块6。</p><ul><li>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，9&lt;15，走左路，到磁盘寻址磁盘块2。</li><li>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;9&lt;12，到磁盘中寻址定位到磁盘块6。</li><li>第三次磁盘IO：将磁盘块6加载到内存中，在内存中从头遍历比较，在第三个索引中找到9，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。（这里需要区分的是在InnoDB中Data存储的为行数据，而MyIsam中存储的是磁盘地址。）</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162810055.png" alt="image-20220803162810055"></p><p><strong>范围查询</strong></p><p>假如我们想要查找9和26之间的数据。查找路径是磁盘块1-&gt;磁盘块2-&gt;磁盘块6-&gt;磁盘块7。</p><ul><li>首先查找值等于9的数据，将值等于9的数据缓存到结果集。这一步和前面等值查询流程一样，发生了三次磁盘IO。</li><li>查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块6，键值9开始向后遍历筛选所有符合筛选条件的数据。</li><li>第四次磁盘IO：根据磁盘6后继指针到磁盘中寻址定位到磁盘块7，将磁盘7加载到内存中，在内存中从头遍历比较，9&lt;25&lt;26，9&lt;26&lt;&#x3D;26，将data缓存到结果集。</li><li>主键具备唯一性（后面不会有&lt;&#x3D;26的数据），不需再向后查找，查询终止。将结果集返回给用户。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162902012.png" alt="image-20220803162902012"></p><p><strong>可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构</strong></p><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><h4 id="MyIsam索引"><a href="#MyIsam索引" class="headerlink" title="MyIsam索引"></a>MyIsam索引</h4><p>以一个简单的user表为例。user表存在两个索引，id列为主键索引，age列为普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = MyISAM<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8;<br><br></code></pre></td></tr></table></figure><p>MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。</p><p>主键索引的B+树如下图所示：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803163454024.png" alt="image-20220803163454024"></p><p>表user的索引存储在索引文件<code>user.MYI</code>中，数据文件存储在数据文件 <code>user.MYD</code>中</p><p><strong>主键等值索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 28;<br></code></pre></td></tr></table></figure><ul><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于30的索引项。（1次磁盘IO）</li><li>从索引项中获取磁盘地址，然后到数据文件user.MYD中获取对应整行记录。（1次磁盘IO）</li><li>将记录返给客户端。</li></ul><p><strong>磁盘IO次数：3次索引检索+记录数据检索。</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803164712589.png" alt="image-20220803164712589"></p><p><strong>主键返回查询数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id between 28 and 47;<br></code></pre></td></tr></table></figure><ul><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历比较16&lt;28，18&lt;28，28&#x3D;28&lt;47。查找到值等于28的索引项。</li><li>根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li><li>我们的查询语句时范围查找，需要向后遍历底层叶子链表，直至到达最后一个不满足筛选条件。</li><li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，28&lt;47&#x3D;47，根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li><li>最后得到两条符合筛选条件，将查询结果集返给客户端。</li></ul><p><strong>磁盘IO次数：4次索引检索+记录数据检索</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165338794.png" alt="image-20220803165338794"></p><blockquote><p>在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。</p><p>查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。</p></blockquote><h4 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h4><p>每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：</p><ul><li>在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。</li><li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li><li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li></ul><p>这里以user_innodb为例，user_innodb的id列为主键，age列为普通索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user_innodb`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure><p><strong>InnoDB主键索引</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165717554.png" alt="image-20220803165717554"></p><p><strong>查询等值数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user_innodb where id = 28;<br></code></pre></td></tr></table></figure><ul><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205600971.png" alt="image-20220803205600971"></p><p><strong>辅助索引</strong></p><p>除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。</p><p>以表user_innodb的age列为例，age索引的索引结果如下图</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205628315.png" alt="image-20220803205628315"></p><p>底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。</p><p>使用辅助索引需要<strong>检索两遍索引</strong>：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记录。</p><p><strong>辅助索引等值查询的情况</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where age=19;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205904722.png" alt="image-20220803205904722"></p><p>根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为<strong>回表</strong>查询。</p><p><strong>磁盘IO数：辅助索引3次+获取记录回表3次</strong></p><p><strong>组合索引</strong></p><p>还是以自己创建的一个表为例：表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `abc_innodb`<br>(<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `a`  int(11)     DEFAULT NULL,<br>  `b`  int(11)     DEFAULT NULL,<br>  `c`  varchar(10) DEFAULT NULL,<br>  `d`  varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_abc` (`a`, `b`, `c`)<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure><p>组合索引的数据结构</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210223424.png" alt="image-20220803210223424"></p><p><strong>组合索引的查询过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from abc_innodb where a = 13 and b = 16 and c = 4;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210836339.png" alt="image-20220803210836339"></p><p><strong>最左匹配原则</strong></p><p>最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。</p><p>在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。</p><p>就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。</p><p>可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。、</p><p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong></p><p><strong>覆盖索引</strong></p><p>覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。</p><h2 id="可以讲一下如何优化数据库查询吗"><a href="#可以讲一下如何优化数据库查询吗" class="headerlink" title="可以讲一下如何优化数据库查询吗"></a>可以讲一下如何优化数据库查询吗</h2><h3 id="避免回表"><a href="#避免回表" class="headerlink" title="避免回表"></a>避免回表</h3><p>在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？</p><p>使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）</p><p>如果在一个场景下，<code>select id,name,sex from user where name =&#39;zhangsan&#39;;</code>这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。</p><p>这里就是一个典型的使用覆盖索引的优化策略减少回表的情况。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><strong>联合索引</strong>，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。</p><p><strong>联合索引的创建原则</strong>，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。</p><p><strong>联合索引的使用</strong></p><p>考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。<br>当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。</p><h2 id="数据库中的锁"><a href="#数据库中的锁" class="headerlink" title="数据库中的锁"></a>数据库中的锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>MySQL大致可归纳为以下3种锁：</p><ul><li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><h3 id="MyIsam锁"><a href="#MyIsam锁" class="headerlink" title="MyIsam锁"></a>MyIsam锁</h3><p>在使用MyIsam时，我们<strong>只可以使用表级锁</strong>，而MySQL的表级锁有两种模式：</p><p><strong>表共享锁</strong>（Table Read Lock）和<strong>表独占写锁</strong>（Table Write Lock），他们在工作时表现如下：</p><ul><li>对某一个表的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</li><li>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；</li><li>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</li></ul><p>当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p><p>MyISAM在执行<strong>查询语句</strong>（SELECT）前，会自动给涉及的所有表<strong>加读锁</strong>，在<strong>执行更新操作</strong>（UPDATE、DELETE、INSERT等）前，会自动给涉及的表<strong>加写锁</strong>，这个过程并不需要用户干预</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p><p>行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p><h4 id="事务（Transaction）及其ACID属性"><a href="#事务（Transaction）及其ACID属性" class="headerlink" title="事务（Transaction）及其ACID属性"></a>事务（Transaction）及其ACID属性</h4><p>  事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p><ul><li><strong>原子性（Actomicity）</strong>：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li><strong>一致性（Consistent）</strong>：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li><strong>隔离性（Isolation）</strong>：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li><strong>持久性（Durable）</strong>：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ul><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>  相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p><ul><li><p><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</p></li><li><p><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</p></li><li><p><strong>不可重复读</strong>（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</p></li><li><p><strong>幻读</strong></p><p>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><ul><li>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是<strong>间隙锁(Gap Lock)</strong></li></ul></li></ul><h4 id="InnoDB都有哪些锁"><a href="#InnoDB都有哪些锁" class="headerlink" title="InnoDB都有哪些锁"></a>InnoDB都有哪些锁</h4><ol><li>行锁<ol><li>共享锁（lock in share mode）</li><li>排他锁（for update）</li></ol></li><li>意向锁（表级别）<ol><li>意向共享锁</li><li>意向排他锁</li></ol></li><li>间隙锁</li><li>Next-key lock：行锁（排他锁）+间隙锁</li></ol><h4 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h4><p>InnoDB实现了以下两种类型的行锁。</p><ul><li><strong>共享锁（s）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。xxx lock in share mode</li><li><strong>排他锁（Ｘ）</strong>：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。xxx for update</li></ul><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><p><strong>意向共享锁（IS）</strong>：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p><p><strong>意向排他锁（IX）</strong>：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p><h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p><strong>InnoDB行锁是通过索引上的索引项来实现的</strong>，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁（如果是RR &#x2F; Serializable 级别，将在主键上使用Next-Key Locks（行锁+间隙锁）来实现锁表的操作）</p><blockquote><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p></blockquote><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p> 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB（可重复读、串行化级别下才有效）会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁它通常是一个开区间（xx, xx）。</p><p>  InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求</p><blockquote><p> 很显然，<strong>在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待</strong>。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p></blockquote><h4 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h4><p>next-key lock是InnoDB加锁的基本单位，它是一个前开后闭的区间，即行锁+间隙锁</p><h4 id="InnoDB加锁规则"><a href="#InnoDB加锁规则" class="headerlink" title="InnoDB加锁规则"></a>InnoDB加锁规则</h4><p><strong>两个“原则”、两个“优化”和一个“bug”：</strong></p><ul><li>原则1：加锁的基本单位是next-key lock。next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ul><h4 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h4><p> 对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><ul><li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><p><strong>InnoDB加锁方法</strong></p><ul><li><p>意向锁是 InnoDB 自动加的， 不需用户干预。</p></li><li><p>对于 <code>UPDATE</code>、 <code>DELETE </code>和 <code>INSERT </code>语句， InnoDB会自动给涉及数据集加排他锁（X)；</p></li><li><p>对于普通 <code>SELECT </code>语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p></li><li><ul><li>共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code>。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code>。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ul></li></ul><p><strong>for update 和 lock in share mode 的区别：</strong></p><p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 <code>for update</code> ；后一个是共享锁，多个事务可以同时的对相同数据执行 <code>lock in share mode</code></p><h3 id="MySQL乐观锁的实现"><a href="#MySQL乐观锁的实现" class="headerlink" title="MySQL乐观锁的实现"></a>MySQL乐观锁的实现</h3><p><strong>悲观锁</strong>：从字面理解就是很悲观，每次去拿数据的时候都认为别人会修改，所以在每次拿的时候对数据上锁，这样就保证了数据的准确性。比如mysql中的表锁，行锁。</p><p><strong>乐观锁</strong>：<strong>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</strong></p><p>乐观锁的实现：使用版本控制字段，再使用行锁的特性实现乐观锁</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925191406535.png" alt="image-20220925191406535"></p><p>如果执行一次，那么版本号就增加一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update order set price = 1, version = version + 1 where id = 1 and version = 0;<br></code></pre></td></tr></table></figure><p><strong>死锁的处理</strong></p><p>数据库使用乐观锁导致产生死锁</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925191736595.png" alt="image-20220925191736595"></p><p>假设在两个事务中有以上两个操作，同时修改order表中两条数据</p><p>事务A在执行完第一条update的时候，刚好事务B也执行完第一条update</p><p>此时， 事务A中order表中的id &#x3D; 1的行被锁住， 事务B中order表中id &#x3D; 2的行被锁住，两个事务继续往下执行</p><p>事务A中第二条update执行需要order表中id &#x3D; 2的行数据，而事务B中第二条update执行需要id &#x3D; 1的行数据， 两条update往下执行的条件都需要对方事务中已经被锁住的行，于是陷入无限等待，形成死锁。</p><p><strong>解决死锁的方法</strong></p><p><strong>指定锁的执行顺序</strong>，比如把以上两事务稍作修改</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925192445700.png" alt="image-20220925192445700"></p><p>事务A执行第一条update时，id &#x3D; 2 的行被锁住，此时，事务B想修改id &#x3D; 2的行，只能等待事务A执行完成，当事务A执行完成时，事务B再执行， 这样就不会产生死锁了。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h2><ol><li>Redis是<strong>纯内存数据库</strong>。</li><li>Redis是<strong>单线程数据库</strong>。利用<strong>队列</strong>技术将并发访问变为串行访问。</li><li>Redis采用了<strong>多路复用IO技术</strong>：“多路”指多个网络连接；”复用”指复用一个线程；多路复用IO技术<strong>可以让单线程高效的处理多个连接请求</strong>。</li></ol><h2 id="Redis常用的数据结构"><a href="#Redis常用的数据结构" class="headerlink" title="Redis常用的数据结构"></a>Redis常用的数据结构</h2><ul><li>字符串 <code>String</code></li><li>列表 <code>list</code></li><li>有序集合 <code>zset</code></li><li>哈希表 <code>hash</code></li><li>集合 <code>set</code></li></ul><p>其他的一些高级数据结构</p><ul><li><code>HyperLogLog</code>：通常用于基数统计，使用少量固定大小的内存，来统计集合中唯一元素的数据</li><li><code>Geo</code>：可以将用户给定的地理位置信息存储起来，并进行操作</li><li><code>BitMap</code>：位图</li><li><code>Stream</code>：主要用于消息队列，类似于<code>Kafka</code>。提供了消息的持久化和主从复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证信息不丢失</li></ul><h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><ul><li>缓存</li><li>分布式锁</li><li>排行榜 <code>zset</code></li><li>计数 <code>incrby</code></li><li>消息队列 <code>stream</code></li><li>地理位置 <code>geo</code></li><li>访客统计 <code>hyperloglog</code></li></ul><h2 id="Redis做异步队列"><a href="#Redis做异步队列" class="headerlink" title="Redis做异步队列"></a>Redis做异步队列</h2><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产信息，<code>lpop</code>消费消息</p><p>缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等</p><blockquote><p>使用<code>pub/sub</code>主题订阅者模式，可以实现<code>1:N</code>的消息队列</p></blockquote><h2 id="Redis和数据库一致性问题"><a href="#Redis和数据库一致性问题" class="headerlink" title="Redis和数据库一致性问题"></a>Redis和数据库一致性问题</h2><p>更新策略：</p><ul><li>采用正确的更新策略，先更新数据库，再删除缓存</li><li>因为可能存在删除缓存失败的问题，提供一个消息队列作为补偿措施</li></ul><p>采用延时双删策略：</p><ul><li>先淘汰缓存</li><li>再写数据库</li><li>休眠一会，再次淘汰缓存</li></ul><blockquote><p>如果对数据有强一致性要求，不能放缓存</p></blockquote><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了或宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。</p><p>持久化就是把内存的数据写到磁盘中，防止服务器宕机了，导致内存数据待久。</p><p>Redis提供两种持久化机制，分别是RDB和AOF。<strong>Redis服务器默认开启RDB，关闭AOF</strong>；</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB(Redis DataBase)：快照。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923221404554.png" alt="image-20220923221404554"></p><p>优点：<strong>RDB文件紧凑，体积小，网络传输快，适合全量复制</strong>；<strong>恢复速度比AOF快</strong>。与AOF相比，RDB最重要的优点之一是<strong>对性能的影响相对较小</strong>。</p><p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然<strong>做不到实时持久化</strong>，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF(Append Only File)：将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志志中文件恢复数据。</p><p>与RDB持久化相对应，AOF的优点在于支持<strong>秒级持久化</strong>、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p><p><strong>持久化策略选择</strong></p><ul><li>如果Redis中的数据完全丢弃也没有关系，那么无论是单机，还是主从架构，都可以不进行任何持久化。</li><li>在单机环境下，如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</li><li>但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</li></ul><h2 id="Redis的淘汰策略"><a href="#Redis的淘汰策略" class="headerlink" title="Redis的淘汰策略"></a>Redis的淘汰策略</h2><p>当Redis的内存（maxmemory参数配置）已满时，它会根据淘汰策略（maxmemory-policy参数配置）进行相应的操作。</p><ul><li><p>不删除策略（no-eviction）<br>no-eviction：不删除策略。Redis默认策略。达到最大内存限制时，若需要更多内存，直接返回错误信息。</p></li><li><p>最近最少使用策略（lru）</p><ul><li>allkeys-lru：所有key通用；优先删除最近最少使用的key</li><li>volatile-lru：只限于设置了 expire 过期时间的部分；优先删除最近最少使用的key</li></ul></li><li><p>随机策略（random）：</p><ul><li>allkeys-random：所有key通用；随机删除一部分key。</li><li>volatile-random：只限于设置 expire 的部分；随机删除一部分key。</li></ul></li><li><p>剩余时间短策略（ttl）：</p><p>volatile-ttl：只限于设置 expire 的部分；优先删除剩余时间短的key。</p></li><li><p>最不经常使用策略（lfu）:</p><p>volatile-lfu：只限于设置 expire 的部分；优先删除最不经常使用的key。</p></li><li><p>allkeys-lfu：所有key通用；优先删除最不经常使用的key。</p></li></ul><blockquote><ul><li>volatile-：从已过期时间的数据集中淘汰key。</li><li>allkeys-：所有key。</li></ul></blockquote><h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>Redis基于 <strong>Reactor 模式</strong>开发了自己网络事件处理器，它由四部分组成，分别是</p><ul><li>套接字</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器</li></ul><p>因为<strong>文件事件分派器队列</strong>的消费是单线程的，所以Redis才叫单线程模型。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220923222211570.png" alt="image-20220923222211570"></p><h2 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h2><p>IO多路复用：”多路”是指多个TCP连接；”复用”是指复用一个或多个线程；可以让单线程高效的处理多个连接请求。</p><p>IO多路复用使用两个系统调用(select&#x2F;poll&#x2F;epoll和recvfrom)，阻塞IO只调用了recvfrom；</p><p>select&#x2F;poll&#x2F;epoll 核心是可以同时处理多个连接，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好，多路复用模型中，每一个socket，设置为non-blocking，阻塞是被select这个函数阻塞的，而不是被socket阻塞的。</p><h3 id="select机制"><a href="#select机制" class="headerlink" title="select机制"></a>select机制</h3><p>原理：客户端操作服务器时会三种文件描述符(简称fd)：writefds(写)、readfds(读)、exceptfds(异常)。select会阻塞监视3类文件描述符，等有数据、可读、可写、出异常或超时，就会返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后进行对应的IO操作。</p><p>优点：所有平台都支持，跨平台性好。<br>缺点：</p><ul><li>由于是采用轮询方式全盘扫描，会随着文件描述符fd数量增多而性能下降。</li><li>每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)</li><li>默认单个进程打开的fd有限制是1024个，可修改宏定义，但是效率仍然慢。</li></ul><h3 id="poll机制"><a href="#poll机制" class="headerlink" title="poll机制"></a>poll机制</h3><p>原理：基本原理与select一致，也是轮询+遍历；唯一的区别就是poll没有最大文件描述符限制（使用链表的方式存储fd）。</p><h3 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h3><p>原理：epoll也没有fd个数限制，用户态拷贝到内核态只需要一次，使用时间通知机制来触发。通过epoll_ctl注册fd，一旦fd就绪就会通过callback回调机制来激活对应fd，进行相关的io操作。</p><p>优点：</p><ul><li>没有fd限制，所支持的fd上限是操作系统的最大文件句柄数，1G内存大概支持10万个句柄</li><li>效率提高，使用回调通知而不是轮询的方式，不会随着FD数目的增加效率下降</li><li>内核和用户空间mmap同一块内存实现(mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)</li></ul><h2 id="Redis异常问题"><a href="#Redis异常问题" class="headerlink" title="Redis异常问题"></a>Redis异常问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>同一时间内大量键过期（失效）</strong>，导致所有请求瞬间都落在了数据库中导致连接异常而崩掉。</p><p>如何解决缓存雪崩</p><ul><li>给缓存数据的过期时间设置随机机，防止同一时间大量数据过期。</li><li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，若标记失效，则更新缓存数据。</li><li>并发量不大时，可以使用加锁排队。</li></ul><p>对于”Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：</p><ul><li><strong>事发前</strong>：实现Redis的高可用（主从架构+Sentinel或者Redis集群），尽量避免Redis挂掉</li><li><strong>事发中</strong>：设置本地缓存(ehcache)+限流(hystrix)，尽量避免数据挂掉，保证服务能正常工作</li><li><strong>事发后</strong>：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>恶意请求缓存中不存在的数据</strong>，导致所有请求都落在数据库，造成短时间承受大量请求而崩掉</p><p><code>采用布隆过滤器</code>，将所有可能存在的数据哈希到一个bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据。<strong>同时读缓存数据没有读到</strong>，导致所有请求都落在数据库，造成过大压力。</p><p><strong>缓存雪崩与缓存击穿的区别</strong></p><p>与缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期，很多数据都查不到从而查数据库。</p><p><strong>如何解决缓存击穿</strong></p><ol><li><code>设置热点数据永不过期</code>。</li><li><code>利用互斥锁</code>：在缓存失效的时，先获取锁，得到锁后再去请求数据库。没有得到锁，则休眠一段时间在重试。</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热指系统上线后，将相关的缓存数据直接加载到Redis中，这样就可以避免在用户请求时，先查询数据库，然后再将数据缓存的问题。</p><ol><li>直接写个缓存刷新页面，系统上线时手动将缓存数据加载；</li><li>定时刷新缓存；</li></ol><h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ul><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ul><p><strong>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</strong></p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>事务间相互独立：事务中的所有命令都会序列化，按顺序执行。事务在执行过程中，不会被其他客户端请求的命令中断。</p><blockquote><p>事务中的命令要么都执行，要么都不执行</p></blockquote><h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD、WATCH命令实现的。通过MULTI开启事务，然后将请求的命令入队，最后通过EXEC命令依次执行队列中所有的命令。</p><p>Redis会将一个事务所有的命令序列化，然后按顺序执行。</p><ul><li><strong>Redis不支持回滚</strong>。Redis在事务失败时不进行回滚，而是继续执行剩下的命令。</li><li><strong>若在一个事务中的命令出现错误，那么所有命令都不会执行</strong>。</li><li><strong>若在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li></ul><p><strong>WATCH命令</strong>：是一个乐观锁，可以为Redis提供CAS操作。可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不执行，监控一直持续到EXEC命令。</p><p><strong>MULTI命令</strong>：用于开启事务。MULTI执行后，Client可以继续向服务器发送任意多条命令，这些命令会存放到一个队列中，当EXEC命令调用后，所有队列中的命令才会被执行。</p><p><strong>EXEC命令</strong>：执行所有事务块的命令，可以理解为提交事务。按命令的执行顺序，返回事务中所有命令的返回值。当操作被打断时，返回空值（nil）。</p><p><strong>DISCARD命令</strong>：用于清空事务队列，并放弃执行事务。Client从事务状态中退出。</p><p><strong>UNWATCH命令</strong>：用于取消WATCH命令对所有key的监控。</p><blockquote><p><strong>事务执行过程中，若服务器收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中</strong></p></blockquote><h3 id="Redis事务的特性"><a href="#Redis事务的特性" class="headerlink" title="Redis事务的特性"></a>Redis事务的特性</h3><p>就是数据库的ACID特性</p><ul><li><strong>原子性（Atomicity）</strong></li><li><strong>一致性（Consistency）</strong></li><li><strong>隔离性（Isolation）</strong></li><li><strong>持久性（Durability）</strong></li></ul><h2 id="Redis分布式问题"><a href="#Redis分布式问题" class="headerlink" title="Redis分布式问题"></a>Redis分布式问题</h2><h3 id="Redis的分布式锁"><a href="#Redis的分布式锁" class="headerlink" title="Redis的分布式锁"></a>Redis的分布式锁</h3><p>Redis是单进程模式，队列技术将并发访问变为串行访问，且多个客户端对Redis的连接并不存在竞争关系，Redis可以使用<code>setnx</code>命令实现分布式锁。</p><p><strong>获取锁时调用setnx（setnx若设置值成功，返回1；设置失败，返回0）。锁的value值会随机生成一个UUID，在释放锁时，会通过UUID进行判断是否为对应的锁，若是该锁，则释放该锁；可以使用 <code>expire </code>命令为锁添加一个超时时间，超过该时间则自动释放锁。</strong></p><p><code>setnx key value</code>：只有在 key 不存在时，才将key设置为value值。</p><h3 id="Redis的并发竞争key问题"><a href="#Redis的并发竞争key问题" class="headerlink" title="Redis的并发竞争key问题"></a>Redis的并发竞争key问题</h3><p>多个系统同时对一个key进行操作，最后执行的顺序和我们期望的顺序不同，导致结果不同。</p><p>如何解决并发竞争问题</p><ul><li><strong>Redis实现分布式锁</strong>：通过Redis中setnx命令可以实现分布式锁。当获取锁时，调用setnx加锁。锁的value值会随机生成一个UUID。在释放锁时，通过UUID进行判断是否为对应的锁，若是则释放锁。使用expire命令为锁添加一个超时时间，若超过该时间则自动释放锁。</li><li>Zookeeper实现分布式锁：通过Zookeeper临时有序节点可以实现分布式锁。每个Client对某个方法加锁时，在Zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。通过判断有序节点中，序号是否为最小来获取锁；当释放锁时，只需要删除瞬时有序节点。</li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵（Sentinel） 是 Redis 的高可用性解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220925140736236.png" alt="image-20220925140736236"></p><p><strong>哨兵的作用</strong></p><ul><li>监控redis主、从数据库是否正常运行</li><li>主数据库出现故障自动将从数据库转换为主数据库</li></ul><p><strong>哨兵的核心知识</strong></p><ul><li>哨兵至少需要3个实例，来保证自己的健壮性</li><li>哨兵+redis主从的部署架构，是不保证数据零丢失的，<strong>只能保证redis集群的高可用性</strong></li><li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li><li>配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</li></ul><h2 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a>Redis的主从复制</h2><p>当从数据库启动时，会向主数据库发送<code>sync</code>命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。复制初始化结束。之后，主数据库每收到1个命令就同步发送给从数据库。 当出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库。增量复制。<code>213  c</code></p><p>主从复制是乐观复制，当客户端发送写执行给主数据库，主数据库执行完立即将结果返回客户端，并异步的把命令发送给从数据库，从而不影响性能。</p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring的IOC和AOP吗"><a href="#Spring的IOC和AOP吗" class="headerlink" title="Spring的IOC和AOP吗"></a>Spring的IOC和AOP吗</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（面向切面）是一种编程范式，提供从另一个角度来考虑程序结构以完善面向对象编程（OOP）。<br>AOP为开发者提供了一种描述横切关注点的机制，并能够自动将横切关注点织入到面向对象的软件系统中，从而实现了横切关注点的模块化。<br>AOP能够将那些与业务无关，却为业务模块所共同调用的<a href="https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E6%88%96&spm=1001.2101.3001.7020">逻辑或</a>责任，例如事务处理、日志管理、权限控制等，封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><p><strong>使用AOP的好处</strong></p><ul><li>降低模块的耦合度</li><li>使系统容易扩展</li><li>提高代码复用性</li></ul><p><strong>AOP的基本概念</strong></p><ul><li>连接点（JoinPoint）：需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点。</li><li>切入点（Pointcut）：一组相关连接点的集合。</li><li>通知（Advice）：在连接点上执行的行为，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置增强（before advice）、后置增强 (after advice)、环绕增强 （around advice）。</li><li>切面（Aspect）：通知和切入点的结合。</li><li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</li><li>代理（Proxy）：通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</li><li>目标对象（Target）：需要被织入关注点的对象。即被代理的对象。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803214934226.png" alt="image-20220803214934226"></p><p>实现AOP的主要设计模式就是动态代理。</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（控制反转）就是依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。<br>Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是<strong>工厂模式</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803215056912.png" alt="image-20220803215056912"></p><p><strong>使用IOC的好处</strong></p><ul><li>集中管理，实现类的可配置和易管理。</li><li>降低了类与类之间的耦合度</li></ul><h1 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h1><p>Tomcat 服务器<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[学习Tomcat这一篇就够了](http://t.csdn.cn/cQSkN)">[7]</span></a></sup>是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p><h2 id="Tomcat的缺省端口"><a href="#Tomcat的缺省端口" class="headerlink" title="Tomcat的缺省端口"></a>Tomcat的缺省端口</h2><p>Tomcat目录下的conf文件夹下的server.xml文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">uriEncoding</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP&#x2F;IP协议来传递数据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端和服务器之间的通信格式。它的整个过程如下图所示：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907213344213.png" alt="image-20220907213344213"></p><ol><li>用户通过浏览器进行了一个操作，比如输入网址并回车，或者是点击链接，接着浏览器获取了这个事件。</li><li>浏览器向服务端发出TCP连接请求。</li><li>服务程序接受浏览器的连接请求并经过TCP三次握手建立连接。</li><li>浏览器将请求数据打包成一个HTTP协议格式的数据包。</li><li>浏览器将该数据包推入网络，数据包经过网络传输，最终达到端服务程序。</li><li>服务端程序拿到这个数据包后，同样以HTTP协议格式解包，获取到客户端的意图。</li><li>得知客户端意图后进行处理，比如提供静态文件或者调用服务端程序获得动态结果。</li><li>服务器将响应结果（可能是HTML或者图片等）按照HTTP协议格式打包。</li><li>服务器将响应数据包推入网络，数据包经过网络传输最终达到到浏览器。</li><li>浏览器拿到数据包后，以HTTP协议的格式解包，然后解析数据，假设这里的数据是 HTML。</li><li>浏览器将HTML文件展示在页面上。</li></ol><h2 id="Tomcat整体架构"><a href="#Tomcat整体架构" class="headerlink" title="Tomcat整体架构"></a>Tomcat整体架构</h2><p>Tomcat要实现两个核心功能：</p><ol><li>处理Socket连接，负责网络字节流与Request和Response对象的转化。</li><li>加载和管理Servlet，以及具体处理Request请求。</li></ol><p>因此Tomcat设计了两个核心组件</p><ul><li><strong>连接器（Connector）</strong>：负责对外交流</li><li><strong>容器（Container）</strong>：负责内部处理</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907214254671.png" alt="image-20220907214254671"></p><h3 id="Coyote连接器架构"><a href="#Coyote连接器架构" class="headerlink" title="Coyote连接器架构"></a>Coyote连接器架构</h3><p>Coyote是Tomcat的连接器框架的名称 , 是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受响应 。</p><p>Coyote封装了底层的网络通信（Socket请求及响应处理），为Catalina容器提供了统一的接口，使Catalina容器与具体的请求协议及IO操作方式完全解耦。Coyote 将Socket输入转换封装为Request对象，交由Catalina容器进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流 。</p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>布隆过滤器（Bloom Filter）<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/94433082)">[6]</span></a></sup>是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。</p><p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p><p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p><p>根据定义，布隆过滤器可以检查值是 <strong>“可能在集合中”</strong> 还是 <strong>“绝对不在集合中”</strong>。“可能” 表示有一定的概率，也就是说可能存在一定为误判率。那为什么会存在误判呢？下面我们来分析一下具体的原因。</p><p>布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，如下图所示。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221423444.png" alt="image-20220803221423444"></p><p>为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221528106.png" alt="image-20220803221528106"></p><p>如上图所示，当输入 “semlinker” 时，预设的 3 个哈希函数将输出 2、4、6，我们把相应位置 1。假设另一个输入 ”kakuqo“，哈希函数输出 3、4 和 7。你可能已经注意到，索引位 4 已经被先前的 “semlinker” 标记了。此时，我们已经使用 “semlinker” 和 ”kakuqo“ 两个输入值，填充了位向量。当前位向量的标记状态为：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221601391.png" alt="image-20220803221601391"></p><p>当对值进行搜索时，与哈希表类似，我们将使用 3 个哈希函数对 ”搜索的值“ 进行哈希运算，并查看其生成的索引值。假设，当我们搜索 ”fullstack“ 时，3 个哈希函数输出的 3 个索引值分别是 2、3 和 7：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221742464.png" alt="image-20220803221742464"></p><p>从上图可以看出，相应的索引位都被置为 1，这意味着我们可以说 ”fullstack“ 可能已经插入到集合中。事实上这是误报的情形，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。幸运的是，布隆过滤器有一个可预测的误判率（FPP）：<br>$$<br>P_{fpp} \approx (1-e^{-\frac{kn}{m}})^k<br>$$</p><ul><li>n 是已经添加元素的数量；</li><li>k 哈希的次数；</li><li>m 布隆过滤器的长度（如比特数组的大小）；</li></ul><p><strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在实际工作中，布隆过滤器常见的应用场景如下：</p><ul><li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li><li>Google Chrome 使用布隆过滤器识别恶意 URL；</li><li>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</li><li>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。 除了上述的应用场景之外，布隆过滤器还有一个应用场景就是解决缓存穿透的问题。所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。</li></ul><p>利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>可以创建一个Maven项目，在pom文件中引入以下坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.0-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后创建一个测试代码，初始化一百万条数据到过滤器中，然后在原有的基础上增加一万条数据，并且判断这些数据是否存在布隆过滤器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Charsets;<br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 总数量</span><br>        BloomFilter&lt;CharSequence&gt; bf = <br>          BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total);<br>        <span class="hljs-comment">// 初始化 1000000 条数据到过滤器中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total; i++) &#123;<br>            bf.put(<span class="hljs-string">&quot;&quot;</span> + i);<br>        &#125;<br>        <span class="hljs-comment">// 判断值是否存在过滤器中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total + <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bf.mightContain(<span class="hljs-string">&quot;&quot;</span> + i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;已匹配数量 &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">已匹配数量 <span class="hljs-number">1000309</span><br></code></pre></td></tr></table></figure><p>上述结果出现了误报，误报率比预期多了309个元素<br>$$<br>\frac{309}{1000000+10000} \times 100% \approx 3.059%<br>$$</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142%5Ev39%5Epc_rank_v37&spm=1018.2226.3001.4187">Java多线程同步之ThreadLocal与Synchromized</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142%5Ev39%5Epc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187">我给面试官讲解了单例模式后，他对我竖起了大拇指！</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/qq_36667170/article/details/121656279">HTTP 和 HTTPS 的区别（面试常考题）</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/qq_35190492/article/details/109257302">一文搞懂MySQL索引所有知识点（建议收藏）</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/79980618">红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/94433082">5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="http://t.csdn.cn/cQSkN">学习Tomcat这一篇就够了</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>八股文</tag>
      
      <tag>摆烂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为机试练习汇总记录</title>
    <link href="/2022/09/08/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/09/08/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="华为笔试题牛客网"><a href="#华为笔试题牛客网" class="headerlink" title="华为笔试题牛客网"></a>华为笔试题牛客网</h1><p>为了准备华为的机试，专门进行了一些专项训练，主要训练一些中等和难题</p><p>主要涵盖以下相关内容的题目：</p><ul><li>动态规划</li><li>DFS</li><li>背包问题</li><li>贪心问题</li><li>二叉树</li><li>回溯剪枝</li></ul><h1 id="HJ1-字符串最后一个单词的长度-x3D-x3D-字符串-x3D-x3D"><a href="#HJ1-字符串最后一个单词的长度-x3D-x3D-字符串-x3D-x3D" class="headerlink" title="HJ1 字符串最后一个单词的长度&#x3D;&#x3D;字符串&#x3D;&#x3D;"></a>HJ1 字符串最后一个单词的长度&#x3D;&#x3D;字符串&#x3D;&#x3D;</h1><ul><li><p>题目</p></li><li><p>题解(816)</p></li><li><p>讨论(2k)</p></li><li><p>排行</p></li><li><p>面经</p><p>new</p></li></ul><p>简单 通过率：36.37% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入一行，代表要计算的字符串，非空，长度小于5000。</p><h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出一个整数，表示输入字符串最后一个单词的长度。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello nowcoder</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">最后一个单词为nowcoder，长度为8   <br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接使用<code>split</code>分割，然后输出字符串数组最后一个字符串的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String[] strs = scanner.nextLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(strs[strs.length - <span class="hljs-number">1</span>].length());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220905160813230.png" alt="image-20220905160813230"></p><p>另一种方式是直接从字符串末尾查找第一个空格，设置一个<code>count</code>记录查找了多少个字符，查找到第一个空格直接返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> str.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (str.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>            count++;<br>        &#125;<br>        System.out.println(count);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220905161343377.png" alt="image-20220905161343377"></p><h1 id="HJ2-计算某字符出现次数-x3D-x3D-字符串-x3D-x3D"><a href="#HJ2-计算某字符出现次数-x3D-x3D-字符串-x3D-x3D" class="headerlink" title="HJ2 计算某字符出现次数&#x3D;&#x3D;字符串&#x3D;&#x3D;"></a>HJ2 计算某字符出现次数&#x3D;&#x3D;字符串&#x3D;&#x3D;</h1><ul><li><p>题目</p></li><li><p>题解(829)</p></li><li><p>讨论(2k)</p></li><li><p>排行</p></li><li><p>面经</p><p>new</p></li></ul><p>简单 通过率：33.72% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=585">哈希</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母）</p><p>数据范围： 1 \le n \le 1000 \1≤<em>n</em>≤1000 </p><h3 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h3><p>第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字符。</p><h3 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出输入字符串中含有该字符的个数。（不区分大小写字母）</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ABCabc<br><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>如果是字母，需要判断大小写，如果是数字，直接判断是否相等，最后返回计数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> scanner.nextLine().charAt(<span class="hljs-number">0</span>);<br>        ch = Character.isLowerCase(ch) ? Character.toUpperCase(ch) : ch;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> str.charAt(i) - ch;<br>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-number">0</span> || (Character.isLetter(ch) &amp;&amp; temp == <span class="hljs-number">32</span>))<br>                count++;<br>        &#125;<br>        System.out.println(count);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220905162502487.png" alt="image-20220905162502487"></p><h1 id="HJ3-明明的随机数-x3D-x3D-字符串-x3D-x3D"><a href="#HJ3-明明的随机数-x3D-x3D-字符串-x3D-x3D" class="headerlink" title="HJ3 明明的随机数&#x3D;&#x3D;字符串&#x3D;&#x3D;"></a>HJ3 明明的随机数&#x3D;&#x3D;字符串&#x3D;&#x3D;</h1><ul><li><p>题目</p></li><li><p>题解(832)</p></li><li><p>讨论(2k)</p></li><li><p>排行</p></li><li><p>面经</p><p>new</p></li></ul><p>较难 通过率：25.09% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=578">数组</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>明明生成了N<em>N</em>个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。</p><p>数据范围： 1 \le n \le 1000 \1≤<em>n</em>≤1000 ，输入的数字大小满足 1 \le val \le 500 \1≤<em>v<strong>a</strong>l</em>≤500 </p><h3 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h3><p>第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的”示例”。</p><h3 id="输出描述：-2"><a href="#输出描述：-2" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出多行，表示输入数据处理后的结果</p><h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br>2<br>1<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入解释：<br>第一个数字是3，也即这个小样例的<span class="hljs-attribute">N</span>=3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：<br>2<br>2<br>1<br>所以样例的输出为：<br>1<br>2     <br></code></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>直接利用<code>HashSet</code>去重并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            set.add(scanner.nextInt());<br><br>        <span class="hljs-keyword">for</span> (Integer s : set)<br>            System.out.println(s);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220905163418709.png" alt="image-20220905163418709"></p><h1 id="HJ4-字符串分隔-x3D-x3D-字符串-x3D-x3D"><a href="#HJ4-字符串分隔-x3D-x3D-字符串-x3D-x3D" class="headerlink" title="HJ4 字符串分隔&#x3D;&#x3D;字符串&#x3D;&#x3D;"></a>HJ4 字符串分隔&#x3D;&#x3D;字符串&#x3D;&#x3D;</h1><ul><li><p>题目</p></li><li><p>题解(914)</p></li><li><p>讨论(2k)</p></li><li><p>排行</p></li><li><p>面经</p><p>new</p></li></ul><p>简单 通过率：31.34% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>•输入一个字符串，请按长度为8拆分每个输入字符串并进行输出；</p><p>•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</p><h3 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h3><p>连续输入字符串(每个字符串长度小于等于100)</p><h3 id="输出描述：-3"><a href="#输出描述：-3" class="headerlink" title="输出描述："></a>输出描述：</h3><p>依次输出所有分割后的长度为8的新字符串</p><h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abc</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">abc00000<br></code></pre></td></tr></table></figure><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>首先先将前面字符串8个换行输出，后面的补零输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        pring(str);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pring</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length() / <span class="hljs-number">8</span>; i++)<br>            System.out.println(str.substring(i*<span class="hljs-number">8</span>, (i+<span class="hljs-number">1</span>) * <span class="hljs-number">8</span>));<br>        System.out.print(str.substring(str.length() - str.length() % <span class="hljs-number">8</span>, str.length()));<br>        <span class="hljs-keyword">if</span> (str.length() % <span class="hljs-number">8</span> != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> - str.length() % <span class="hljs-number">8</span>; i++)<br>                System.out.print(<span class="hljs-string">&quot;0&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220905165634379.png" alt="image-20220905165634379"></p><h1 id="HJ5-进制转换-x3D-x3D-字符串-x3D-x3D"><a href="#HJ5-进制转换-x3D-x3D-字符串-x3D-x3D" class="headerlink" title="HJ5 进制转换&#x3D;&#x3D;字符串&#x3D;&#x3D;"></a>HJ5 进制转换&#x3D;&#x3D;字符串&#x3D;&#x3D;</h1><ul><li><p>题目</p></li><li><p>题解(605)</p></li><li><p>讨论(1k)</p></li><li><p>排行</p></li><li><p>面经</p><p>new</p></li></ul><p>简单 通过率：37.38% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。</p><p>数据范围：保证结果在 1 \le n \le 2^{31}-1 \1≤<em>n</em>≤231−1 </p><h3 id="输入描述：-4"><a href="#输入描述：-4" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入一个十六进制的数值字符串。</p><h3 id="输出描述：-4"><a href="#输出描述：-4" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出该数值的十进制字符串。不同组的测试用例用\n隔开。</p><h2 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xAA</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">170<br></code></pre></td></tr></table></figure><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        System.out.println(hexToInteger(str.substring(<span class="hljs-number">2</span>, str.length())));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">hexToInteger</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;F&#x27;</span>)<br>                ans = ans * <span class="hljs-number">16</span> + (ch - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">else</span><br>                ans = ans * <span class="hljs-number">16</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220905170422937.png" alt="image-20220905170422937"></p><h1 id="HJ16-购物单-x3D-x3D-背包问题-01背包-x3D-x3D"><a href="#HJ16-购物单-x3D-x3D-背包问题-01背包-x3D-x3D" class="headerlink" title="HJ16 购物单&#x3D;&#x3D;背包问题-01背包&#x3D;&#x3D;"></a>HJ16 购物单&#x3D;&#x3D;背包问题-01背包&#x3D;&#x3D;</h1><p>中等 通过率：23.60% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=593">动态规划</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th>主件</th><th>附件</th></tr></thead><tbody><tr><td>电脑</td><td>打印机，扫描仪</td></tr><tr><td>书柜</td><td>图书</td></tr><tr><td>书桌</td><td>台灯，文具</td></tr><tr><td>工作椅</td><td>无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。</p><p>每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。</p><p>王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 <strong>~</strong> 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。</p><p>满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第i<em>i</em>件物品的价格为v[i]<em>v</em>[<em>i</em>]，重要度为w[i]<em>w</em>[<em>i</em>]，共选中了k<em>k</em>件物品，编号依次为j_1,j_2,…,j_k<em>j</em>1,<em>j</em>2,…,<em>j**k</em>，则满意度为：v[j_1]<em>w[j_1]+v[j_2]<em>w[j_2]+ … +v[j_k]<em>w[j_k]<em>v</em>[<em>j</em>1]∗</em>w</em>[<em>j</em>1]+<em>v</em>[<em>j</em>2]∗</em>w*[<em>j</em>2]+…+<em>v</em>[<em>j**k</em>]∗<em>w</em>[<em>j**k</em>]。（其中 * 为乘号）</p><p>请你帮助王强计算可获得的最大的满意度。</p><h3 id="输入描述：-5"><a href="#输入描述：-5" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入的第 1 行，为两个正整数N，m，用一个空格隔开：</p><p>（其中 N （ N&lt;32000 ）表示总钱数， m （m &lt;60 ）为可购买的物品的个数。）</p><p>从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q</p><p>（其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 **~** 5 ）， q 表示该物品是主件还是附件。如果 q&#x3D;0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号）</p><h3 id="输出描述：-5"><a href="#输出描述：-5" class="headerlink" title="输出描述："></a>输出描述：</h3><p> 输出一个正整数，为张强可以获得的最大的满意度。</p><h2 id="示例1-5"><a href="#示例1-5" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1000 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">800 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">400 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">300 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">400 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">500 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2200</span><br></code></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">50 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">130<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">由第1行可知总钱数N为50以及希望购买的物品个数m为5；<br>第2和第3行的q为5，说明它们都是编号为5的物品的附件；<br>第4~6行的q都为0，说明它们都是主件，它们的编号依次为3~5；<br>所以物品的价格与重要度乘积的总和的最大值为10<span class="hljs-number">*1</span>+20<span class="hljs-number">*3</span>+20<span class="hljs-number">*3</span>=130       <br></code></pre></td></tr></table></figure><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>这道题是经典的背包问题，首先是0-1背包问题</p><p>有一个背包可以装物品的总重量为W现有N个物品，每个物品W[i]，价值在v[i]，用背包装物品，能装的最大价值是多少</p><p>可以定义一个状态转移数组dp[i][j]，表示前i个物品，背包总量为j的情况下能装的最大价值</p><p>状态转移方程为<br>$$<br>dp[i][j]&#x3D;\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])<br>$$<br>也就是说要么当前物品不放入背包<code>dp[i-1][j]</code>，或者当前物品放入背包<code>dp[i-1][j-w[i]] + v[i]</code></p><h3 id="购物车思路"><a href="#购物车思路" class="headerlink" title="购物车思路"></a>购物车思路</h3><p>这道题本质上还是0-1背包问题，不过多了主件和附件，可以将主件和附件放在一起考虑，即考虑每个物品的时候要考虑每种可能出现的情况</p><ul><li>主件</li><li>主件+附件1</li><li>主件+附件2</li><li>主件+附件1+附件2</li></ul><p>可以使用一维数组优化状态转移方程空间复杂度，并用两个m+1行3列的数组分别存储物品的价格和满意度，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(), m = scanner.nextInt();<br>        <span class="hljs-type">int</span>[][] price = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span>[][] importance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> scanner.nextInt(), p = scanner.nextInt(), q = scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">im</span> <span class="hljs-operator">=</span> v * p;<br>            <span class="hljs-keyword">if</span> (q == <span class="hljs-number">0</span>) &#123;<br>                price[i][<span class="hljs-number">0</span>] = v;<br>                importance[i][<span class="hljs-number">0</span>] = im;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (price[q][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>                    price[q][<span class="hljs-number">1</span>] = v;<br>                    importance[q][<span class="hljs-number">1</span>] = im;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    price[q][<span class="hljs-number">2</span>] = v;<br>                    importance[q][<span class="hljs-number">2</span>] = im;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (price[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= price[i][<span class="hljs-number">0</span>]; j--) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> price[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> importance[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> price[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> importance[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> price[i][<span class="hljs-number">2</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> importance[i][<span class="hljs-number">2</span>];<br><br>                <span class="hljs-keyword">if</span> (j &gt;= a) &#123;<br>                    dp[j] = Math.max(dp[j], dp[j-a] + a1);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (j &gt;= a + b)<br>                    dp[j] = Math.max(dp[j], dp[j-a-b] + a1 + b1);<br><br>                <span class="hljs-keyword">if</span> (j &gt;= a + c)<br>                    dp[j] = Math.max(dp[j], dp[j-a-c] + a1 + c1);<br><br>                <span class="hljs-keyword">if</span> (j &gt;= a + b + c)<br>                    dp[j] = Math.max(dp[j], dp[j-a-b-c] + a1 + b1 + c1);<br>            &#125;<br>        &#125;<br><br>        System.out.println(dp[n]);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907122609608.png" alt="image-20220907122609608"></p><h1 id="HJ24-合唱队-x3D-x3D-动态规划-最长递增子序列-x3D-x3D"><a href="#HJ24-合唱队-x3D-x3D-动态规划-最长递增子序列-x3D-x3D" class="headerlink" title="HJ24 合唱队&#x3D;&#x3D;动态规划-最长递增子序列&#x3D;&#x3D;"></a>HJ24 合唱队&#x3D;&#x3D;动态规划-最长递增子序列&#x3D;&#x3D;</h1><p>中等 通过率：29.00% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=593">动态规划</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=582">队列</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>N 位同学站成一排，音乐老师要请最少的同学出列，使得剩下的 K 位同学排成合唱队形。</p><p>设K<em>K</em>位同学从左到右依次编号为 1，2…，K ，他们的身高分别为T_1,T_2,…,T_K<em>T</em>1,<em>T</em>2,…,<em>T**K</em> ，若存在i(1\leq i\leq K)<em>i</em>(1≤<em>i</em>≤<em>K</em>) 使得T_1&lt;T_2&lt;……&lt;T_{i-1}&lt;T_i<em>T*1&lt;*T*2&lt;……&lt;*T**i*−1&lt;*T**i* 且 T_i&gt;T_{i+1}&gt;……&gt;T_K</em>T<strong>i*&gt;*T</strong>i*+1&gt;……&gt;<em>T**K</em>，则称这K<em>K</em>名同学排成了合唱队形。</p><p>通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。</p><p>例子：</p><p>123 124 125 123 121 是一个合唱队形</p><p>123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求</p><p>123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。</p><p>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>注意：不允许改变队列元素的先后顺序</strong> <strong>且</strong> <strong>不要求最高同学左右人数必须相等</strong></p><p>数据范围： 1 \le n \le 3000 \1≤<em>n</em>≤3000 </p><h3 id="输入描述：-6"><a href="#输入描述：-6" class="headerlink" title="输入描述："></a>输入描述：</h3><p>用例两行数据，第一行是同学的总数 N ，第二行是 N 位同学的身高，以空格隔开</p><h3 id="输出描述：-6"><a href="#输出描述：-6" class="headerlink" title="输出描述："></a>输出描述：</h3><p>最少需要几位同学出列</p><h2 id="示例1-6"><a href="#示例1-6" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">由于不允许改变队列元素的先后顺序，所以最终剩下的队列应该为186<span class="hljs-number"> 200 </span>160 130或150<span class="hljs-number"> 200 </span>160<span class="hljs-number"> 130 </span> <br></code></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>可以看做是最长递增子序列的变种题，对于第i个元素，其<code>0</code>到<code>i-1</code>的元素的最长递增子序列的长度和<code>i+1</code>到<code>n-1</code>元素的最长递减子序列长度的和就是可以满足合唱队的最长长度length，那么需要出列的同学就是n-length</p><p>可以设置一个数组<code>l[n]</code>表示当前n位同学的最长递增子序列长度，那么当<code>i&gt;j &amp;&amp; nums[i] &gt; nums[j] </code>时，可以得到 <code>l[i] = max(l[i], l[j] + 1)</code>，其中初始化l[i] &#x3D; 1，对于i之后的最长递减子序列只需要<code>i &lt; j</code>同样的操作即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                    l[i] = Math.max(l[i], l[j]);<br>            &#125;<br>            l[i] = l[i] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                    r[i] = Math.max(r[i], r[j]);<br>            &#125;<br>            r[i] = r[i] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans = Math.max(ans, l[i] + r[i] - <span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(n - ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907134155941.png" alt="image-20220907134155941"></p><h1 id="HJ32-密码截取-x3D-x3D-动态规划-最长回文子串-x3D-x3D"><a href="#HJ32-密码截取-x3D-x3D-动态规划-最长回文子串-x3D-x3D" class="headerlink" title="HJ32 密码截取&#x3D;&#x3D;动态规划-最长回文子串&#x3D;&#x3D;"></a>HJ32 密码截取&#x3D;&#x3D;动态规划-最长回文子串&#x3D;&#x3D;</h1><p>中等 通过率：33.53% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=593">动态规划</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>Catcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA-&gt;12ABBA,ABA-&gt;ABAKK,123321-&gt;51233214　。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？</p><p>数据范围：字符串长度满足 1 \le n \le 2500 \1≤<em>n</em>≤2500 </p><h3 id="输入描述：-7"><a href="#输入描述：-7" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入一个字符串（字符串的长度不超过2500）</p><h3 id="输出描述：-7"><a href="#输出描述：-7" class="headerlink" title="输出描述："></a>输出描述：</h3><p>返回有效密码串的最大长度</p><h2 id="示例1-7"><a href="#示例1-7" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ABBA</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ABBBA</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12HHHHA<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>可以考虑中心扩散法查找回文子串，可以看到有两种情况的回文字符串</p><ul><li>ABA</li><li>ABBA</li></ul><p>所以需要计算两种情况下的最长回文子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br><br>        System.out.println(getAns(chars));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAns</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> getLongest(chars, i, i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> getLongest(chars, i, i+<span class="hljs-number">1</span>);<br>            ans = Math.max(ans, Math.max(len1, len2));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLongest</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; chars.length &amp;&amp; chars[l] == chars[r]) &#123;<br>            r++;l--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r - l - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907142927503.png" alt="image-20220907142927503"></p><h1 id="HJ43-迷宫问题-x3D-x3D-DFS递归回溯-x3D-x3D"><a href="#HJ43-迷宫问题-x3D-x3D-DFS递归回溯-x3D-x3D" class="headerlink" title="HJ43 迷宫问题&#x3D;&#x3D;DFS递归回溯&#x3D;&#x3D;"></a>HJ43 迷宫问题&#x3D;&#x3D;DFS递归回溯&#x3D;&#x3D;</h1><p>中等 通过率：39.32% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=589">查找</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=5051">dfs</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=1263">广度优先搜索(BFS)</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h2><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p><p>int maze[5][5] &#x3D; {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2 \le n,m \le 10 \2≤<em>n</em>,<em>m</em>≤10 ， 输入的内容只包含 0 \le val \le 1 \0≤<em>v<strong>a</strong>l</em>≤1 </p><h3 id="输入描述：-8"><a href="#输入描述：-8" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p><h3 id="输出描述：-8"><a href="#输出描述：-8" class="headerlink" title="输出描述："></a>输出描述：</h3><p>左上角到右下角的最短路径，格式如样例所示。</p><h2 id="示例1-8"><a href="#示例1-8" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意：不能斜着走！！    <br></code></pre></td></tr></table></figure><h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>直接使用dfs递归回溯的模板解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] directions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">static</span> List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(), m = scanner.nextInt();<br>        <span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)<br>                nums[i][j] = scanner.nextInt();<br><br>        List&lt;<span class="hljs-type">int</span>[]&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][m];<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        dfs(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, path, visited);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] a : ans) &#123;<br>            System.out.println(<span class="hljs-string">&quot;(&quot;</span> + a[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;,&quot;</span> + a[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, List&lt;<span class="hljs-type">int</span>[]&gt; path, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == nums.length - <span class="hljs-number">1</span> &amp;&amp; j == nums[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>            ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] direct : directions) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newi</span> <span class="hljs-operator">=</span> i + direct[<span class="hljs-number">0</span>], newj = j + direct[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (newi &gt;= <span class="hljs-number">0</span> &amp;&amp; newi &lt; nums.length &amp;&amp; newj &gt;= <span class="hljs-number">0</span> &amp;&amp; newj &lt; nums[<span class="hljs-number">0</span>].length &amp;&amp; nums[newi][newj] == <span class="hljs-number">0</span> &amp;&amp; !visited[newi][newj]) &#123;<br>                path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newi, newj&#125;);<br>                visited[newi][newj] = <span class="hljs-literal">true</span>;<br>                dfs(nums, newi, newj, path, visited);<br>                visited[newi][newj] = <span class="hljs-literal">false</span>;<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220907162727614.png" alt="image-20220907162727614"></p><h1 id="HJ45-名字的漂亮度-x3D-x3D-字符串贪心-x3D-x3D"><a href="#HJ45-名字的漂亮度-x3D-x3D-字符串贪心-x3D-x3D" class="headerlink" title="HJ45 名字的漂亮度&#x3D;&#x3D;字符串贪心&#x3D;&#x3D;"></a>HJ45 名字的漂亮度&#x3D;&#x3D;字符串贪心&#x3D;&#x3D;</h1><p>中等 通过率：45.29% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=592">贪心</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h2><p>给出一个字符串，该字符串仅由小写字母组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。<br>每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个不同字母拥有相同的“漂亮度”。字母忽略大小写。</p><p>给出多个字符串，计算每个字符串最大可能的“漂亮度”。</p><p>本题含有多组数据。</p><p>数据范围：输入的名字长度满足 1 \le n \le 10000 \1≤<em>n</em>≤10000 </p><h3 id="输入描述：-9"><a href="#输入描述：-9" class="headerlink" title="输入描述："></a>输入描述：</h3><p>第一行一个整数N，接下来N行每行一个字符串</p><h3 id="输出描述：-9"><a href="#输出描述：-9" class="headerlink" title="输出描述："></a>输出描述：</h3><p>每个字符串可能的最大漂亮程度</p><h2 id="示例1-9"><a href="#示例1-9" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>zhangsan<br>lisi<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">192<br>101<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">对于样例lisi，让i的漂亮度为26，l的漂亮度为25，s的漂亮度为24，lisi的漂亮度为25<span class="hljs-string">+26</span><span class="hljs-string">+24</span><span class="hljs-string">+26</span>=101.  <br></code></pre></td></tr></table></figure><h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>通知字符串中字符出现频率，然后按照出现频率排序，之后频率最高的设置漂亮度为26，然后为25，依次递减，输出计算的漂亮度之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            System.out.println(getBeautiful(str));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getBeautiful</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">int</span>[][] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>            counts[i][<span class="hljs-number">0</span>] = i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            counts[ch][<span class="hljs-number">1</span>]++;<br>        &#125;<br><br>        Arrays.sort(counts, (a, b)-&gt;b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (counts[i][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            ans += (<span class="hljs-type">long</span>) (<span class="hljs-number">26</span> - i) * counts[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220908150710343.png" alt="image-20220908150710343"></p><h1 id="HJ52-计算字符串的编辑距离-x3D-x3D-编辑距离-动态规划-x3D-x3D"><a href="#HJ52-计算字符串的编辑距离-x3D-x3D-编辑距离-动态规划-x3D-x3D" class="headerlink" title="HJ52 计算字符串的编辑距离&#x3D;&#x3D;编辑距离-动态规划&#x3D;&#x3D;"></a>HJ52 计算字符串的编辑距离&#x3D;&#x3D;编辑距离-动态规划&#x3D;&#x3D;</h1><p>中等 通过率：40.74% 时间限制：1秒 空间限制：256M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a><a href="https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=593">动态规划</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h2><p>Levenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括<strong>将一个字符替换成另一个字符，插入一个字符，删除一个字符</strong>。编辑距离的算法是首先由俄国科学家 Levenshtein 提出的，故又叫 Levenshtein Distance 。</p><p>例如：</p><p>字符串A: abcdefg</p><p>字符串B: abcdef</p><p>通过增加或是删掉字符 ”g” 的方式达到目的。这两种方案都需要一次操作。把这个操作所需要的次数定义为两个字符串的距离。</p><p>要求：</p><p>给定任意两个字符串，写出一个算法计算它们的编辑距离。</p><p>数据范围：给定的字符串长度满足 1 \le len(str) \le 1000 \1≤<em>l<strong>e</strong>n</em>(<em>s<strong>t</strong>r</em>)≤1000 </p><h3 id="输入描述：-10"><a href="#输入描述：-10" class="headerlink" title="输入描述："></a>输入描述：</h3><p>每组用例一共2行，为输入的两个字符串</p><h3 id="输出描述：-10"><a href="#输出描述：-10" class="headerlink" title="输出描述："></a>输出描述：</h3><p>每组用例输出一行，代表字符串的距离</p><h2 id="示例1-10"><a href="#示例1-10" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abcdefg</span><br><span class="hljs-attribute">abcdef</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h2><p>类似于<a href="https://leetcode.cn/problems/edit-distance/">leetcode72.编辑距离</a></p><p>设置一个二维数组<code>dp[i][j]</code>表示A的前<code>i</code>个字母和B的前<code>j</code>个字母之间的编辑距离</p><p>对于<code>dp[i][j]</code>可以有三种情况的变化：</p><ul><li><code>dp[i][j-1]+1</code>，即在B字符串后添加一个和<code>A[i]</code>相同的字符</li><li><code>dp[i-1][j] + 1</code> ，在A字符串后添加一个和<code>B[j]</code>相同的字符</li><li>如果<code>A[i]=B[j]</code>，那么可以<code>dp[i][j]=dp[i-1][j-1]</code>，如果不相等，那么<code>dp[i][j] = dp[i-1][j-1]</code>，即修改<code>A[i]=B[j]</code>或者<code>B[j]=A[i]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.nextLine(), str2 = scanner.nextLine();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> levenshteinDistance(str1, str2);<br>        System.out.println(ans);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">levenshteinDistance</span><span class="hljs-params">(String words1, String words2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words1.length(), m = words2.length();<br><br>        <span class="hljs-keyword">if</span> (n * m == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> n + m;<br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">1</span>; j++)<br>            dp[<span class="hljs-number">0</span>][j] = j;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left_down</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (words1.charAt(i - <span class="hljs-number">1</span>) != words2.charAt(j - <span class="hljs-number">1</span>))<br>                    left_down += <span class="hljs-number">1</span>;<br>                dp[i][j] = Math.min(Math.min(left, down), left_down);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220908154947578.png" alt="image-20220908154947578"></p><h1 id="HJ54-表达式求值-x3D-x3D-后缀表达式取巧做法-x3D-x3D"><a href="#HJ54-表达式求值-x3D-x3D-后缀表达式取巧做法-x3D-x3D" class="headerlink" title="HJ54 表达式求值&#x3D;&#x3D;后缀表达式取巧做法&#x3D;&#x3D;"></a>HJ54 表达式求值&#x3D;&#x3D;后缀表达式取巧做法&#x3D;&#x3D;</h1><p>简单 通过率：57.95% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=2&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=579">字符串</a><a href="https://www.nowcoder.com/exam/oj?page=2&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=5050">基础数学</a><a href="https://www.nowcoder.com/exam/oj?page=2&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=581">栈</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h2><p>给定一个字符串描述的算术表达式，计算出结果值。</p><p>输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, &#x2F;, (, )” ， ”0-9” 。</p><p>数据范围：运算过程中和最终结果均满足 |val| \le 2^{31}-1 \∣<em>v<strong>a</strong>l</em>∣≤231−1 ，即只进行整型运算，确保输入的表达式合法</p><h3 id="输入描述：-11"><a href="#输入描述：-11" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入算术表达式</p><h3 id="输出描述：-11"><a href="#输出描述：-11" class="headerlink" title="输出描述："></a>输出描述：</h3><p>计算出结果值</p><h2 id="示例1-11"><a href="#示例1-11" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">400</span>+<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">405<br></code></pre></td></tr></table></figure><h2 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h2><p>奇技淫巧，时间复杂度太高了，先mark一下，还是考虑一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.script.ScriptEngine;<br><span class="hljs-keyword">import</span> javax.script.ScriptEngineManager;<br><span class="hljs-keyword">import</span> javax.script.ScriptException;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ScriptException &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        str = str.replace(<span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>);<br>        str = str.replace(<span class="hljs-string">&quot;&#123;&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>);<br>        str = str.replace(<span class="hljs-string">&quot;&#125;&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>);<br>        str = str.replace(<span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-type">ScriptEngine</span> <span class="hljs-variable">scriptEngine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptEngineManager</span>().getEngineByName(<span class="hljs-string">&quot;nashorn&quot;</span>);<br>        System.out.println(scriptEngine.eval(str));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220908161520615.png" alt="image-20220908161520615"></p><h1 id="HJ61-放苹果-x3D-x3D-动态规划-x3D-x3D"><a href="#HJ61-放苹果-x3D-x3D-动态规划-x3D-x3D" class="headerlink" title="HJ61 放苹果&#x3D;&#x3D;动态规划&#x3D;&#x3D;"></a>HJ61 放苹果&#x3D;&#x3D;动态规划&#x3D;&#x3D;</h1><p>简单 通过率：51.69% 时间限制：1秒 空间限制：32M</p><p>知识点<a href="https://www.nowcoder.com/exam/oj?page=2&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=591">递归</a><a href="https://www.nowcoder.com/exam/oj?page=2&pageSize=50&search=&tab=%E5%90%8D%E4%BC%81%E7%9C%9F%E9%A2%98&topicId=37?tag=593">动态规划</a></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/warning.png" alt="warning"> 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。</p><h2 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h2><p>把m个<strong>同样</strong>的苹果放在n个<strong>同样</strong>的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？</p><p>注意：如果有7个苹果和3个盘子，（5，1，1）和（1，5，1）被视为是同一种分法。</p><p>数据范围：0 \le m \le 10 \0≤<em>m</em>≤10 ，1 \le n \le 10 \1≤<em>n</em>≤10 。</p><h3 id="输入描述：-12"><a href="#输入描述：-12" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入两个int整数</p><h3 id="输出描述：-12"><a href="#输出描述：-12" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出结果，int型</p><h2 id="示例1-12"><a href="#示例1-12" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h2 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h2><p>同样地可以使用动态规划，主要是要理清楚这个思路</p><p>设置一个二维数组<code>dp[i][j]</code>表示将<code>i</code>个苹果放在<code>j</code>个盘子中</p><p>可以得知两个初始条件：</p><ul><li>将0个苹果或者一个苹果放在n个盘子里面只能有一种分法即<code>dp[0][i] = dp[1][i] = 1</code></li><li>将n个苹果放在一个盘子也只有一种情况<code>dp[i][1] = 1</code></li></ul><p>对于状态转移可以考虑，如果多加了一个盘子，有两种情况：</p><ul><li><p>苹果数不小于盘子数，有两种情况：</p><ul><li>至少有一个盘子可以不放，因此可以有<code>dp[i][j-1]</code>中方法</li><li>至少每个盘子都有一个苹果，摆放完之后还剩下<code>i-j</code>个苹果，那么剩下的苹果<code>i-j</code>放在<code>j</code>个盘子里面有&#96;&#96;dp[i-j][j]&#96;种分法</li></ul><p>将两者相加得到<code>dp[i][j] = dp[i][j-1] + dp[i-j][j]</code></p></li><li><p>另一种情况是苹果数小于等于盘子数，一定有<code>j-i</code>个盘子空着，每个盘子都是一样的，所以没有多的分法，即<code>dp[i][j]=dp[i][j-1]</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(), m = scanner.nextInt();<br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; j &lt;= m; j++) &#123;<br>                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + (i - j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[i-j][j]);<br>            &#125;<br>        &#125;<br><br>        System.out.println(dp[n][m]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220908181529296.png" alt="image-20220908181529296"></p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>华为</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端工程师-软件类OPPO-2023届校园招聘笔试题-后端（A卷）</title>
    <link href="/2022/09/04/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88-%E8%BD%AF%E4%BB%B6%E7%B1%BBOPPO-2023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E9%A2%98-%E5%90%8E%E7%AB%AF%EF%BC%88A%E5%8D%B7%EF%BC%89/"/>
    <url>/2022/09/04/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88-%E8%BD%AF%E4%BB%B6%E7%B1%BBOPPO-2023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E9%A2%98-%E5%90%8E%E7%AB%AF%EF%BC%88A%E5%8D%B7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>oppo后端开发A卷笔试题记录，三道编程大题，难度都比较简单，最后一道题直接就是leetcode的原题-青蛙跳台阶</p><p>不知道是不是不招人，虽说收到了笔试</p><span id="more"></span><h1 id="后端工程师-软件类OPPO-2023届校园招聘笔试题-后端（A卷）"><a href="#后端工程师-软件类OPPO-2023届校园招聘笔试题-后端（A卷）" class="headerlink" title="后端工程师-软件类OPPO-2023届校园招聘笔试题-后端（A卷）"></a>后端工程师-软件类OPPO-2023届校园招聘笔试题-后端（A卷）</h1><h1 id="编程题1-x3D-x3D-AC-x3D-x3D"><a href="#编程题1-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题1 &#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题1 &#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220902143028358.png" alt="image-20220902143028358"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> digits int整型一维数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDigit</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] digits)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        Arrays.sort(digits);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> digits.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + digits[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220902143311338.png" alt="image-20220902143311338"></p><h1 id="编程题2-x3D-x3D-AC-x3D-x3D"><a href="#编程题2-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题2&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题2&#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220902144129304.png" alt="image-20220902144129304"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *   int val;</span><br><span class="hljs-comment"> *   ListNode next = null;</span><br><span class="hljs-comment"> *   public ListNode(int val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node1 ListNode类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node2 ListNode类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">combineTwoDisorderNodeToOrder</span> <span class="hljs-params">(ListNode node1, ListNode node2)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        List&lt;ListNode&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        getListNodeToLists(node1, lists);<br>        getListNodeToLists(node2, lists);<br>        lists.sort((ListNode a, ListNode b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> a.val - b.val;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> getSortListNode(lists);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getListNodeToLists</span><span class="hljs-params">(ListNode head, List&lt;ListNode&gt; lists)</span> &#123;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = <span class="hljs-literal">null</span>;<br>            lists.add(head);<br>            head = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getSortListNode</span><span class="hljs-params">(List&lt;ListNode&gt; lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.size(); i++) &#123;<br>            cur.next = lists.get(i);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220902144204519.png" alt="image-20220902144204519"></p><h1 id="编程题3-x3D-x3D-AC-x3D-x3D"><a href="#编程题3-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题3&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题3&#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220902144154050.png" alt="image-20220902144154050"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> scenicspot int整型 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> long长整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">tourismRoutePlanning</span> <span class="hljs-params">(<span class="hljs-type">int</span> scenicspot)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (scenicspot == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">if</span> (scenicspot == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2L</span>;<br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[scenicspot];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1L</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; scenicspot; i++)<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">return</span> dp[scenicspot - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220902145055925.png" alt="image-20220902145055925"></p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>oppo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>782.变为棋盘</title>
    <link href="/2022/08/23/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/782.%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/"/>
    <url>/2022/08/23/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/782.%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="782-变为棋盘"><a href="#782-变为棋盘" class="headerlink" title="782.变为棋盘"></a><a href="https://leetcode.cn/problems/transform-to-chessboard/">782.变为棋盘</a></h1><p>难度困难156收藏分享切换为英文接收动态反馈</p><p>一个 <code>n x n</code> 的二维网络 <code>board</code> 仅由 <code>0</code> 和 <code>1</code> 组成 。每次移动，你能任意交换两列或是两行的位置。</p><p>返回 <em>将这个矩阵变为 <strong>“棋盘”</strong> 所需的最小移动次数</em> 。如果不存在可行的变换，输出 <code>-1</code>。</p><p><strong>“棋盘”</strong> 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p><p><strong>示例 1:</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/chessboard1-grid.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: board = <span class="hljs-comment">[<span class="hljs-comment">[0,1,1,0]</span>,<span class="hljs-comment">[0,1,1,0]</span>,<span class="hljs-comment">[1,0,0,1]</span>,<span class="hljs-comment">[1,0,0,1]</span>]</span><br>输出: 2<br>解释:一种可行的变换方式如下，从左到右：<br>第一次移动交换了第一列和第二列。<br>第二次移动交换了第二行和第三行。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/chessboard2-grid.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: board = <span class="hljs-string">[[0, 1], [1, 0]]</span><br>输出: <span class="hljs-number">0</span><br>解释: 注意左上角的格值为<span class="hljs-number">0</span>时也是合法的棋盘，也是合法的棋盘.<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/chessboard3-grid.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: board = <span class="hljs-string">[[1, 0], [1, 0]]</span><br>输出: <span class="hljs-number">-1</span><br>解释: 任意的变换都不能使这个输入变为合法的棋盘。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == board.length</code></li><li><code>n == board[i].length</code></li><li><code>2 &lt;= n &lt;= 30</code></li><li><code>board[i][j]</code> 将只包含 <code>0</code>或 <code>1</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>完全不会</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getCnt</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.bitCount(a) != Integer.bitCount(b) ? INF : Integer.bitCount(a ^ b) / <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movesToChessboard</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g)</span> &#123;<br>        n = g.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, r2 = -<span class="hljs-number">1</span>, c1 = -<span class="hljs-number">1</span>, c2 = -<span class="hljs-number">1</span>, mask = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-number">1</span>) a += (<span class="hljs-number">1</span> &lt;&lt; j);<br>                <span class="hljs-keyword">if</span> (g[j][i] == <span class="hljs-number">1</span>) b += (<span class="hljs-number">1</span> &lt;&lt; j);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (r1 == -<span class="hljs-number">1</span>) r1 = a;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r2 == -<span class="hljs-number">1</span> &amp;&amp; a != r1) r2 = a;<br>            <span class="hljs-keyword">if</span> (c1 == -<span class="hljs-number">1</span>) c1 = b;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c2 == -<span class="hljs-number">1</span> &amp;&amp; b != c1) c2 = b;<br>            <span class="hljs-keyword">if</span> (a != r1 &amp;&amp; a != r2) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (b != c1 &amp;&amp; b != c2) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Integer.bitCount(r1) + Integer.bitCount(r2) != n) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (Integer.bitCount(c1) + Integer.bitCount(c2) != n) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> ((r1 ^ r2) != mask || (c1 ^ c2) != mask) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) t += (<span class="hljs-number">1</span> &lt;&lt; i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Math.min(getCnt(r1, t), getCnt(r2, t)) + Math.min(getCnt(c1, t), getCnt(c2, t));<br>        <span class="hljs-keyword">return</span> ans &gt;= INF ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220823231056022.png" alt="image-20220823231056022"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
      <tag>困难题</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>655.输出二叉树</title>
    <link href="/2022/08/23/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/655.%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/08/23/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/655.%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="655-输出二叉树"><a href="#655-输出二叉树" class="headerlink" title="655.输出二叉树"></a><a href="https://leetcode.cn/problems/print-binary-tree/">655.输出二叉树</a></h1><p>难度中等198收藏分享切换为英文接收动态反馈</p><p>给你一棵二叉树的根节点 <code>root</code> ，请你构造一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的字符串矩阵 <code>res</code> ，用以表示树的 <strong>格式化布局</strong> 。构造此格式化布局矩阵需要遵循以下规则：</p><ul><li>树的 <strong>高度</strong> 为 <code>height</code> ，矩阵的行数 <code>m</code> 应该等于 <code>height + 1</code> 。</li><li>矩阵的列数 <code>n</code> 应该等于 <code>2height+1 - 1</code> 。</li><li><strong>根节点</strong> 需要放置在 <strong>顶行</strong> 的 <strong>正中间</strong> ，对应位置为 <code>res[0][(n-1)/2]</code> 。</li><li>对于放置在矩阵中的每个节点，设对应位置为 <code>res[r][c]</code> ，将其左子节点放置在 <code>res[r+1][c-2height-r-1]</code> ，右子节点放置在 <code>res[r+1][c+2height-r-1]</code> 。</li><li>继续这一过程，直到树中的所有节点都妥善放置。</li><li>任意空单元格都应该包含空字符串 <code>&quot;&quot;</code> 。</li></ul><p>返回构造得到的矩阵 <code>res</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/print1-tree.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<br>[[<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>],<br> [<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/print2-tree.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,null,<span class="hljs-number">4</span>]<br>输出：<br>[[<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>],<br> [<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;&quot;</span>],<br> [<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 210]</code> 内</li><li><code>-99 &lt;= Node.val &lt;= 99</code></li><li>树的深度在范围 <code>[1, 10]</code> 内</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接通过深度优先遍历获取树的高度，然后创建一个（m, n）的二维字符串list，之后递归的遍历树，并将对应结点的值放在该二维字符串list数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> h, m, n;<br>    List&lt;List&lt;String&gt;&gt; ans;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">printTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs1(root, <span class="hljs-number">0</span>);<br>        m = h + <span class="hljs-number">1</span>; n = (<span class="hljs-number">1</span> &lt;&lt; (h + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            List&lt;String&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) cur.add(<span class="hljs-string">&quot;&quot;</span>);<br>            ans.add(cur);<br>        &#125;<br>        dfs2(root, <span class="hljs-number">0</span>, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs1</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ;<br>        h = Math.max(h, depth);<br>        dfs1(root.left, depth + <span class="hljs-number">1</span>);<br>        dfs1(root.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ;<br>        ans.get(x).set(y, String.valueOf(root.val));<br>        dfs2(root.left, x + <span class="hljs-number">1</span>, y - (<span class="hljs-number">1</span> &lt;&lt; (h - x - <span class="hljs-number">1</span>)));<br>        dfs2(root.right, x + <span class="hljs-number">1</span>, y + (<span class="hljs-number">1</span> &lt;&lt; (h - x - <span class="hljs-number">1</span>)));<br>    &#125;<br>&#125; <br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times m)$</li><li>空间复杂度：$O(n \times m)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220823020900603.png" alt="image-20220823020900603"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>二叉树</tag>
      
      <tag>BFS</tag>
      
      <tag>树</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1455.检查单词是否为句中其他单词的前缀</title>
    <link href="/2022/08/21/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1455.%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%80/"/>
    <url>/2022/08/21/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1455.%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1455-检查单词是否为句中其他单词的前缀"><a href="#1455-检查单词是否为句中其他单词的前缀" class="headerlink" title="1455.检查单词是否为句中其他单词的前缀"></a><a href="https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/">1455.检查单词是否为句中其他单词的前缀</a></h1><p>难度简单66</p><p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p><p>如果 <code>searchWord</code> 是某一个单词的前缀，则返回句子 <code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <code>-1</code> 。</p><p>字符串 <code>s</code> 的 <strong>前缀</strong> 是 <code>s</code> 的任何前导连续子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">sentence</span> = <span class="hljs-string">&quot;i love eating burger&quot;</span>, searchWord = <span class="hljs-string">&quot;burg&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：<span class="hljs-string">&quot;burg&quot;</span> 是 <span class="hljs-string">&quot;burger&quot;</span> 的前缀，而 <span class="hljs-string">&quot;burger&quot;</span> 是句子中第 <span class="hljs-number">4</span> 个单词。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">sentence</span> = <span class="hljs-string">&quot;this problem is an easy problem&quot;</span>, searchWord = <span class="hljs-string">&quot;pro&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;pro&quot;</span> 是 <span class="hljs-string">&quot;problem&quot;</span> 的前缀，而 <span class="hljs-string">&quot;problem&quot;</span> 是句子中第 <span class="hljs-number">2</span> 个也是第 <span class="hljs-number">6</span> 个单词，但是应该返回最小下标 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">sentence</span> = <span class="hljs-string">&quot;i am tired&quot;</span>, searchWord = <span class="hljs-string">&quot;you&quot;</span><br>输出：<span class="hljs-number">-1</span><br>解释：<span class="hljs-string">&quot;you&quot;</span> 不是句子中任何单词的前缀。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sentence.length &lt;= 100</code></li><li><code>1 &lt;= searchWord.length &lt;= 10</code></li><li><code>sentence</code> 由小写英文字母和空格组成。</li><li><code>searchWord</code> 由小写英文字母组成。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接将字符串根据空格划分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">isPrefixOfWord</span><span class="hljs-params">(String sentence, String searchWord)</span> &#123;<br>        String[] strs = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isPrefix(strs[i], searchWord) &amp;&amp; ans == -<span class="hljs-number">1</span>) <br>                ans = i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrefix</span><span class="hljs-params">(String word, String searchWord)</span> &#123;<br>        <span class="hljs-keyword">if</span> (word.length() &lt; searchWord.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> searchWord.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (word.charAt(i) != searchWord.charAt(i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220821195709642.png" alt="image-20220821195709642"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐狗游戏2023届秋季招聘笔试-游戏服务器开发</title>
    <link href="/2022/08/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E4%B9%90%E7%8B%97%E6%B8%B8%E6%88%8F2023%E5%B1%8A%E7%A7%8B%E5%AD%A3%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95-%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    <url>/2022/08/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E4%B9%90%E7%8B%97%E6%B8%B8%E6%88%8F2023%E5%B1%8A%E7%A7%8B%E5%AD%A3%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95-%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="乐狗游戏2023届秋季招聘笔试-游戏服务器开发"><a href="#乐狗游戏2023届秋季招聘笔试-游戏服务器开发" class="headerlink" title="乐狗游戏2023届秋季招聘笔试-游戏服务器开发"></a>乐狗游戏2023届秋季招聘笔试-游戏服务器开发</h1><h1 id="编程题1-x3D-x3D-AC-x3D-x3D"><a href="#编程题1-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题1&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题1&#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820200205723.png" alt="image-20220820200205723"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820200217061.png" alt="image-20220820200217061"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820200225355.png" alt="image-20220820200225355"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 输入参数 Ax 角色A的血量，Ay 角色A 的攻击力，Az A的攻击CD，Aw 角色A的恢复力</span><br><span class="hljs-comment">     输入参数 Bx 角色B的血量，By 角色B 的攻击力，Bz B的攻击CD，Bw 角色B的恢复力</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Ax int整型 角色A的血量上限</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Ay int整型 角色A的攻击力</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Az int整型 A的攻击CD</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Aw int整型 角色A的每回合恢复血量值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Bx int整型 角色B的血量上限</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> By int整型 角色B的攻击力</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Bz int整型 B的攻击CD</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> Bw int整型 角色B的每回合恢复血量值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">PK</span> <span class="hljs-params">(<span class="hljs-type">int</span> Ax, <span class="hljs-type">int</span> Ay, <span class="hljs-type">int</span> Az, <span class="hljs-type">int</span> Aw, <span class="hljs-type">int</span> Bx, <span class="hljs-type">int</span> By, <span class="hljs-type">int</span> Bz, <span class="hljs-type">int</span> Bw)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (Ax &gt; By &amp;&amp; (Az + <span class="hljs-number">1</span>) * Aw &gt;= By &amp;&amp; Bx &gt; Ay &amp;&amp; (Bz + <span class="hljs-number">1</span>) * Bw &gt;= Ay)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ax</span> <span class="hljs-operator">=</span> Ax, bx = Bx;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(ax &gt; <span class="hljs-number">0</span> &amp;&amp; bx &gt; <span class="hljs-number">0</span>) &#123;<br>            ax = Math.min(Ax, ax + Aw);<br>            bx = Math.min(Bx, bx + Bw);<br>            <span class="hljs-keyword">if</span> (cnt % (Az + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>                bx -= Ay;<br>            <span class="hljs-keyword">if</span> (cnt % (Bz + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>                ax -= By;<br>            cnt++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ax &gt; <span class="hljs-number">0</span> &amp;&amp; bx &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ax &lt;= <span class="hljs-number">0</span> &amp;&amp; bx &gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820212914615.png" alt="image-20220820212914615"></p><h1 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820203403864.png" alt="image-20220820203403864"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820203417410.png" alt="image-20220820203417410"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 给定字符串 和 显示宽度。 按规则返回自动换行处理后的最后一行。 如不能则返回字符串&quot;error&quot;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str string字符串 给定的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> width int整型 显示的宽度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLastLine</span> <span class="hljs-params">(String str, <span class="hljs-type">int</span> width)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        String[] strs = str.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (String temp : strs) &#123;<br>            <span class="hljs-keyword">if</span> (temp.length() * <span class="hljs-number">16</span> &gt; width)<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; temp != <span class="hljs-literal">null</span>)<br>                ans = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820204401842.png" alt="image-20220820204401842"></p><blockquote><p>这道题完全不知道怎么做，随便写了个，混了些测试案例</p></blockquote><h1 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820204431428.png" alt="image-20220820204431428"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820204442687.png" alt="image-20220820204442687"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820204451090.png" alt="image-20220820204451090"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span>[][] directions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 抵达铁门时可能的最大生命值，如果不可达，则返回 -1。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cave int整型二维数组 洞穴的信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hp int整型 小明的初始生命值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">EscapeFromCave</span> <span class="hljs-params">(<span class="hljs-type">int</span>[][] cave, <span class="hljs-type">int</span> hp)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cave.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; cave[<span class="hljs-number">0</span>].length; j++)<br>                <span class="hljs-keyword">if</span> (cave[i][j] == -<span class="hljs-number">2</span>) &#123;<br>                    x = i;<br>                    y = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            <span class="hljs-keyword">if</span> ( x != <span class="hljs-number">0</span> &amp;&amp; y != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[cave.length][cave[<span class="hljs-number">0</span>].length];<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        dfs(cave, x, y, hp, visited);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] cave, <span class="hljs-type">int</span> curi, <span class="hljs-type">int</span> curj, <span class="hljs-type">int</span> hp, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (hp &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (cave[curi][curj] == -<span class="hljs-number">3</span>) &#123;<br>            ans = Math.max(ans, hp - <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempi</span> <span class="hljs-operator">=</span> curi + dir[<span class="hljs-number">0</span>], tempj = curj + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (tempi &lt; <span class="hljs-number">0</span> || tempi &gt;= cave.length || tempj &lt; <span class="hljs-number">0</span> || tempj &gt;= cave[<span class="hljs-number">0</span>].length || cave[tempi][tempj] == -<span class="hljs-number">1</span> || visited[tempi][tempj])<br>                <span class="hljs-keyword">continue</span>;<br>            visited[tempi][tempj] = <span class="hljs-literal">true</span>;<br>            dfs(cave, tempi, tempj, hp - cave[tempi][tempj], visited);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820211601421.png" alt="image-20220820211601421"></p><blockquote><p>还是有一个特殊的案例没过，不知道为啥</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>乐狗游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网易2023届秋季校园招聘笔试0820-通用技术</title>
    <link href="/2022/08/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%BD%91%E6%98%932023%E5%B1%8A%E7%A7%8B%E5%AD%A3%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%950820-%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/08/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%BD%91%E6%98%932023%E5%B1%8A%E7%A7%8B%E5%AD%A3%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%950820-%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="网易2023届秋季校园招聘笔试0820-通用技术"><a href="#网易2023届秋季校园招聘笔试0820-通用技术" class="headerlink" title="网易2023届秋季校园招聘笔试0820-通用技术"></a>网易2023届秋季校园招聘笔试0820-通用技术</h1><h2 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820152143697.png" alt="image-20220820152143697"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820152157447.png" alt="image-20220820152157447"></p><h2 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820152429298.png" alt="image-20220820152429298"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oddMax</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, singMax = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                oddMax = Math.max(oddMax, nums[i]);<br>            <span class="hljs-keyword">else</span><br>                singMax = Math.max(singMax, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (oddMax == singMax)<br>            singMax += <span class="hljs-number">1</span>;<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? oddMax - nums[i] : singMax - nums[i];<br>            ans = ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(String.valueOf(temp)));<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820160603979.png" alt="image-20220820160603979"></p><h2 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820152603406.png" alt="image-20220820152603406"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820152616346.png" alt="image-20220820152616346"></p><h2 id="编程题4"><a href="#编程题4" class="headerlink" title="编程题4"></a>编程题4</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820152631279.png" alt="image-20220820152631279"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            nums[i] = scanner.nextInt();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">2</span>; k &lt; n; k++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; k; j++)<br>                    <span class="hljs-keyword">if</span> (nums[i] == nums[k] &amp;&amp; nums[i] &gt; nums[j])<br>                        ans++;<br>            &#125;<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820153621396.png" alt="image-20220820153621396"></p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>网易</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团2023届笔试第三批</title>
    <link href="/2022/08/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%BE%8E%E5%9B%A22023%E5%B1%8A%E7%A7%8B%E6%8B%9B-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%880820/"/>
    <url>/2022/08/20/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%BE%8E%E5%9B%A22023%E5%B1%8A%E7%A7%8B%E6%8B%9B-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%880820/</url>
    
    <content type="html"><![CDATA[<h1 id="美团2023届秋招-技术综合0820"><a href="#美团2023届秋招-技术综合0820" class="headerlink" title="美团2023届秋招 技术综合0820"></a>美团2023届秋招 技术综合0820</h1><h2 id="编程题1-x3D-x3D-AC-x3D-x3D"><a href="#编程题1-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题1&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题1&#x3D;&#x3D;AC&#x3D;&#x3D;</h2><p>编程题|20.0分1&#x2F;4</p><p>烤串</p><p><strong>时间限制：</strong> 3000MS<br><strong>内存限制：</strong> 589824KB</p><p><strong>题目描述：</strong></p><p> 小团想要自己来烤串！不过在烤串之前，需要串好烤串。小团有n个荤菜和n个素菜，他想按顺序分别一个荤菜一个素菜串起来，想请你帮他串好！给出两个长度分别为n的仅包含小写英文字母的串A和B，分别代表荤菜和素菜的种类（用字母来表示菜的种类）。请你以从左到右的顺序依次串好他们！例如对于荤菜串A1A2…An和素菜串B1B2…Bn，串好应该是A1B1A2B2…AnBn</p><p>输入描述</p><p>第一行一个正整数n，表示烤串长度</p><p>第二行为一个长度为n的字符串A，表示荤菜按次序都是哪些菜。 </p><p>第三行为一个长度为n的字符串B，表示素菜按次序都是哪些菜。</p><p>对于80%的数据，n≤1000</p><p>对于20%的数据，n≤50000</p><p>对于所有数据，A和B为仅包含小写英文字母的字符串。</p><p>输出描述</p><p>输出一行，包含2n个字符串表示串好的烤串。</p><p>样例输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>abcd<br>efgh<br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aebfcgdh</span><br></code></pre></td></tr></table></figure><p>提示</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">按规则<span class="hljs-keyword">A</span><span class="hljs-number">1B1A2B2</span>...AnBn串好即可。<br></code></pre></td></tr></table></figure><p>规则</p><p>请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果<br>点击“调试”亦可保存代码<br>编程题可以使用本地编译器，此页面不记录跳出次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">meat</span> <span class="hljs-operator">=</span> scanner.nextLine(), vegetable = scanner.nextLine();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            sb.append(meat.charAt(i)).append(vegetable.charAt(i));<br>        System.out.println(sb);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820100812035.png" alt="image-20220820100812035"></p><h2 id="编程题2-x3D-x3D-AC-x3D-x3D"><a href="#编程题2-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题2&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题2&#x3D;&#x3D;AC&#x3D;&#x3D;</h2><p>编程题|20.0分2&#x2F;4</p><p>定位</p><p><strong>时间限制：</strong> 3000MS<br><strong>内存限制：</strong> 589824KB</p><p><strong>题目描述：</strong></p><p>小团在地图上放了三个定位装置，想依赖他们来进行定位！小团的地图是一个n×n的一个棋盘，他在(x1,y1),(x2,y2),(x3,y3) xi,yi ∈ Z ∩ [1,n] 这三个位置分别放置了一个定位装置（两两不重叠）。然后小团在一个特定的位置(a,b)a,b ∈ Z ∩ [1,n]放置了一个信标。每个信标会告诉小团它自身到那个信标的曼哈顿距离，即对i&#x3D;1,2,3 小团知道(|xi-a|+|yi-b|)，现在小团想让你帮他找出信标的位置！注意，题目保证最少有一个正确的信标位置。因为小团不能定位装置确定出来的信标位置是否唯一，如果有多个，输出字典序最小的那个。(a,b)的字典序比(c,d)小，当且仅当 a&lt;c或者a&#x3D;&#x3D;c∧b&lt;d</p><p>输入描述</p><p>第一行一个正整数n，表示棋盘大小。</p><p>第二行两个整数，分别表示x1与y1，即第一个定位器的位置。</p><p>第三行两个整数，分别表示x2与y2，即第二个定位器的位置。</p><p>第四行两个整数，分别表示x3与y3，即第三个定位器的位置。</p><p>第五行三个整数，分别表示第一、二、三个定位器到信标的曼哈顿距离。第i个定位器到信标的曼哈顿距离即(|xi-a|+|yi-b|)</p><p>数字间两两有空格隔开，对于所有数据， n≤50000, 1≤xi,yi≤n</p><p>输出描述</p><p>输出一行两个整数，表示字典序最小的可能的信标位置。</p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">样例解释：与 <span class="hljs-comment">(2, 1)</span> 的哈曼顿距离为<span class="hljs-number">2</span>的位置有三个，分别是 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2, 3)</span>, <span class="hljs-comment">(3, 2)</span>与 <span class="hljs-comment">(2, 2)</span> 的哈曼顿距离为<span class="hljs-number">1</span>的位置有四个，分别是 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2, 1)</span>, <span class="hljs-comment">(2, 3)</span>, <span class="hljs-comment">(3, 2)</span>与 <span class="hljs-comment">(2, 3)</span> 的哈曼顿距离为<span class="hljs-number">2</span>的位置有三个，分别是 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2, 1)</span>, <span class="hljs-comment">(3, 2)</span>所以只有 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(3, 2)</span> 这两个位置有可能是信标，而 <span class="hljs-comment">(1, 2)</span> 的字典序最小，所以输出 <span class="hljs-comment">(1, 2)</span><br></code></pre></td></tr></table></figure><p>规则</p><p>请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果<br>点击“调试”亦可保存代码<br>编程题可以使用本地编译器，此页面不记录跳出次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[][] base = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            base[i][<span class="hljs-number">0</span>] = scanner.nextInt();<br>            base[i][<span class="hljs-number">1</span>] = scanner.nextInt();<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] distance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            distance[i] = scanner.nextInt();<br>            List&lt;<span class="hljs-type">int</span>[]&gt; temp = addPoints(base[i], distance[i], n);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] t : temp) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(t[<span class="hljs-number">0</span>]) + <span class="hljs-string">&quot; &quot;</span> + String.valueOf(t[<span class="hljs-number">1</span>]);<br>                map.put(key, map.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(key) == <span class="hljs-number">3</span>)<br>                    ans.add(key);<br>            &#125;<br>        &#125;<br><br>        Collections.sort(ans);<br>        System.out.println(ans.get(<span class="hljs-number">0</span>));<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-type">int</span>[]&gt; addPoints(<span class="hljs-type">int</span>[] base, <span class="hljs-type">int</span> distance, <span class="hljs-type">int</span> N) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= N; j++) &#123;<br>                <span class="hljs-keyword">if</span> (Math.abs(base[<span class="hljs-number">0</span>] - i) + Math.abs(base[<span class="hljs-number">1</span>] - j) == distance) &#123;<br>                    ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820102737876.png" alt="image-20220820102737876"></p><h2 id="编程题3-x3D-x3D-73-x3D-x3D"><a href="#编程题3-x3D-x3D-73-x3D-x3D" class="headerlink" title="编程题3&#x3D;&#x3D;73%&#x3D;&#x3D;"></a>编程题3&#x3D;&#x3D;73%&#x3D;&#x3D;</h2><p>编程题|20.0分3&#x2F;4</p><p>复习</p><p><strong>时间限制：</strong> 3000MS<br><strong>内存限制：</strong> 589824KB</p><p><strong>题目描述：</strong></p><p>小美即将进行期末考试！小美现在盘算了一下，一共有n道试题，对于第 i 道试题，小美有着pi的概率做对，获得ai的分值，另外(1-pi)的概率做错，获得0分。小美的总分即是每道题获得的分数之和。小美不甘于此！她决定突击复习，因为时间有限，她最多复习m道试题，使得复习后的试题正确率提升到100%。小美想知道，如果她以最佳方式进行复习，能获得的期望总分最大是多少。</p><p>输入描述</p><p>第一行两个正整数n和m，表示总试题数和最多复习试题数。</p><p>接下来一行n个整数，分别为p1 p2…pn，表示小美有pi%的概率，即pi&#x3D;pi&#x2F;100的概率做对第i个题。（注意，这里为了简单起见，将概率pi扩张100倍成为整数pi方便输入）</p><p>接下来一行n个整数，分别表示a1 a2…an，分别表示第 i 个题做对的分值。</p><p>数字间两两有空格隔开，对于所有数据，1≤m≤n≤50000,0≤pi≤100,1≤ai≤1000</p><p>输出描述</p><p>输出一行一个恰好两位的小数，表示能获得的最大期望总分。（如果答案为10应输出10.00，2.5应输出2.50）</p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">89 </span><span class="hljs-number">38</span> <br><span class="hljs-symbol">445 </span><span class="hljs-number">754</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1150</span>.<span class="hljs-number">05</span><br></code></pre></td></tr></table></figure><p>提示</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">如果都不复习，小美总分的期望为<span class="hljs-number">89</span><span class="hljs-meta">%</span>*<span class="hljs-number">445</span><span class="hljs-number">+38</span><span class="hljs-meta">%</span>*<span class="hljs-number">754</span>=<span class="hljs-number">682.57</span>如果复习第一道题，小美总分的期望为<span class="hljs-number">100</span><span class="hljs-meta">%</span>*<span class="hljs-number">445</span><span class="hljs-number">+38</span><span class="hljs-meta">%</span>*<span class="hljs-number">754</span>=<span class="hljs-number">731.52</span>如果复习第二道题，小美总分的期望为<span class="hljs-number">89</span><span class="hljs-meta">%</span>*<span class="hljs-number">445</span><span class="hljs-number">+100</span><span class="hljs-meta">%</span>*<span class="hljs-number">754</span>=<span class="hljs-number">1150.05</span>所以选择复习第二道题，这样能获得最大期望总分<span class="hljs-number">1150.05</span>根据每题复习后的收益进行排序即可<br></code></pre></td></tr></table></figure><p>规则</p><p>请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果<br>点击“调试”亦可保存代码<br>编程题可以使用本地编译器，此页面不记录跳出次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(), m = scanner.nextInt();<br>        <span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            nums[i][<span class="hljs-number">0</span>] = scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            nums[i][<span class="hljs-number">1</span>] = scanner.nextInt();<br><br>        Arrays.sort(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br><span class="hljs-comment">//                return o1[1] == o2[1] ? o1[0] - o2[0] : o2[1] - o1[1];</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (<span class="hljs-number">100</span> - o2[<span class="hljs-number">0</span>]) * o2[<span class="hljs-number">1</span>] - (<span class="hljs-number">100</span>-o1[<span class="hljs-number">0</span>]) * o1[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">return</span> temp == <span class="hljs-number">0</span> ? o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">1</span>] : temp;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)<br>            ans += nums[i][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++)<br>            ans2 += (<span class="hljs-type">long</span>) nums[i][<span class="hljs-number">0</span>] * nums[i][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>) ans + ans2 / <span class="hljs-number">100.0</span>;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820105426892.png" alt="image-20220820105426892"></p><h2 id="编程题4"><a href="#编程题4" class="headerlink" title="编程题4"></a>编程题4</h2><p>编程题|20.0分4&#x2F;4</p><p>拟合</p><p><strong>时间限制：</strong> 3000MS<br><strong>内存限制：</strong> 589824KB</p><p><strong>题目描述：</strong></p><p> 小团生日收到妈妈送的两个一模一样的数列作为礼物！他很开心的把玩，不过不小心没拿稳将数列摔坏了！现在他手上的两个数列分别为A和B，长度分别为n和m。小团很想再次让这两个数列变得一样。他现在能做两种操作，操作一是将一个选定数列中的某一个数a改成数b，这会花费|b-a|的时间，操作二是选择一个数列中某个数a，将它从数列中丢掉，花费|a|的时间。小团想知道，他最少能以多少时间将这两个数列变得再次相同！</p><p>输入描述</p><p>第一行两个空格隔开的正整数n和m，分别表示数列A和B的长度。</p><p>接下来一行n个整数，分别为A1 A2…An</p><p>接下来一行m个整数，分别为B1 B2…Bm</p><p>对于所有数据，1≤n,m≤2000， |Ai|,|Bi|≤10000</p><p>输出描述</p><p>输出一行一个整数，表示最少花费时间，来使得两个数列相同。</p><p>样例输入</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">1 1<br><span class="hljs-deletion">-9821 </span><br>7742<br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">17563<br></code></pre></td></tr></table></figure><p>提示</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">可以选择两次第二种操作，消除数列<span class="hljs-keyword">A</span>的第一个数和数列B的第一个数，需要花费<span class="hljs-number">9821+7742</span>=<span class="hljs-number">17563</span>的时间也可以选择一次第一种操作，将数列<span class="hljs-keyword">A</span>的第一个数改成数列B的第一个数，也是需要花费<span class="hljs-number">9821+7742</span>=<span class="hljs-number">17563</span>的时间所以答案为<span class="hljs-number">17563</span><br></code></pre></td></tr></table></figure><p>规则</p><p>请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果<br>点击“调试”亦可保存代码<br>编程题可以使用本地编译器，此页面不记录跳出次数</p><h2 id="编程题5"><a href="#编程题5" class="headerlink" title="编程题5"></a>编程题5</h2><p>编程题|20.0分1&#x2F;1</p><p>修补</p><p><strong>时间限制：</strong> 3000MS<br><strong>内存限制：</strong> 589824KB</p><p><strong>题目描述：</strong></p><p>小团的玩具火箭有点磨损了，上面有很多地方翘起来了，小团想要用强力胶进行修补，但在强力胶凝结之前，需要找点东西压住。幸好小团有很多这样的东西。小团有m种配重材料，第i种材料重ai单位重量（因为小团有太多了，可以认为每种都有任意多个）。火箭上有n个地方翘起来了，需要至少bi单位重量的东西来压住，而且只能用一个配重材料来压，(多了的话不好压，多个配重材料容易散开，所以小团不想用多个来折腾)。小团想一次就把所有翘起来的地方全都修补好，请问他需要使用的配重材料重量之和最少是多少？ </p><p>输入描述</p><p>第一行两个正整数n和m，分别代表需要修补的地方个数以及材料种类数。</p><p>接下来一行n个数b1,b2,…,bn，含义如题。</p><p>接下来一行m个数 a1,a2,…,am，含义如题。</p><p>对于40%的数据，n,m≤100</p><p>对于另外30%的数据，n,m≤2000</p><p>对于所有数据，1≤n,m≤50000，1≤ai,bi≤104</p><p>输出描述</p><p>输出小团最少需要使用的配重材料重量之和。如果没有任何办法满足，输出-1 </p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p>提示</p><p>样例1解释需要5单位重量，只有4单位重量的材料，压不住，输出-1。<br>输入样例2</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出样例2</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><p>样例解释2第一个地方需要重量为4的，第二个地方可以用重量为1的，第三个地方只能选择重量为4的才能压住。所以总重量需求为9。可以证明没有更优方案。</p><p>规则</p><p>请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果<br>点击“调试”亦可保存代码<br>编程题可以使用本地编译器，此页面不记录跳出次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(), m = scanner.nextInt();<br>        <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            b[i] = scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)<br>            a[i] = scanner.nextInt();<br><br>        Arrays.sort(a);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> binarySearch(a, b[i]);<br>            <span class="hljs-keyword">if</span> (temp == -<span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-1&quot;</span>);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            res += temp;<br>        &#125;<br><br>        System.out.println(res);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (nums[n-<span class="hljs-number">1</span>] &lt; val)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; val)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[right];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820114757841.png" alt="image-20220820114757841"></p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>美团</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>654.最大二叉树</title>
    <link href="/2022/08/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/08/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654.最大二叉树</a></h1><p>难度中等516收藏分享切换为英文接收动态反馈</p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/tree1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,6,0,5]</span><br>输出：<span class="hljs-comment">[6,3,5,null,2,0,null,null,1]</span><br>解释：递归调用如下所示：<br>- <span class="hljs-comment">[3,2,1,6,0,5]</span> 中的最大值是 6 ，左边部分是 <span class="hljs-comment">[3,2,1]</span> ，右边部分是 <span class="hljs-comment">[0,5]</span> 。<br>    - <span class="hljs-comment">[3,2,1]</span> 中的最大值是 3 ，左边部分是 <span class="hljs-comment">[]</span> ，右边部分是 <span class="hljs-comment">[2,1]</span> 。<br>        - 空数组，无子节点。<br>        - <span class="hljs-comment">[2,1]</span> 中的最大值是 2 ，左边部分是 <span class="hljs-comment">[]</span> ，右边部分是 <span class="hljs-comment">[1]</span> 。<br>            - 空数组，无子节点。<br>            - 只有一个元素，所以子节点是一个值为 1 的节点。<br>    - <span class="hljs-comment">[0,5]</span> 中的最大值是 5 ，左边部分是 <span class="hljs-comment">[0]</span> ，右边部分是 <span class="hljs-comment">[]</span> 。<br>        - 只有一个元素，所以子节点是一个值为 0 的节点。<br>        - 空数组，无子节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/tree2.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归创建即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> construct(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">construct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">best</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> best + <span class="hljs-number">1</span>; i &lt;= right; i++)<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[best])<br>                best = i;<br>        <br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span> (nums[best]);<br>        root.left = construct(nums, left, best-<span class="hljs-number">1</span>);<br>        root.right = construct(nums, best+<span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820163256680.png" alt="image-20220820163256680"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>二叉树</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1450.在既定时间做作业的学生人数</title>
    <link href="/2022/08/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1450.%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/"/>
    <url>/2022/08/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1450.%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1450-在既定时间做作业的学生人数"><a href="#1450-在既定时间做作业的学生人数" class="headerlink" title="1450.在既定时间做作业的学生人数"></a><a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/">1450.在既定时间做作业的学生人数</a></h1><p>难度简单77收藏分享切换为英文接收动态反馈</p><p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p><p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p><p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4<br>输出：1<br>解释：一共有<span class="hljs-number"> 3 </span>名学生。<br>第一名学生在时间<span class="hljs-number"> 1 </span>开始写作业，并于时间<span class="hljs-number"> 3 </span>完成作业，在时间<span class="hljs-number"> 4 </span>没有处于做作业的状态。<br>第二名学生在时间<span class="hljs-number"> 2 </span>开始写作业，并于时间<span class="hljs-number"> 2 </span>完成作业，在时间<span class="hljs-number"> 4 </span>没有处于做作业的状态。<br>第三名学生在时间<span class="hljs-number"> 3 </span>开始写作业，预计于时间<span class="hljs-number"> 7 </span>完成作业，这是是唯一一名在时间<span class="hljs-number"> 4 </span>时正在做作业的学生。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：startTime = [<span class="hljs-number">4</span>], <span class="hljs-keyword">end</span>Time = [<span class="hljs-number">4</span>], <span class="hljs-keyword">query</span>Time = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span><br>解释：在查询时间只有一名学生在做作业。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：startTime = [<span class="hljs-number">4</span>], <span class="hljs-keyword">end</span>Time = [<span class="hljs-number">4</span>], <span class="hljs-keyword">query</span>Time = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：startTime = [<span class="hljs-number">1,1,1,1</span>], endTime = [<span class="hljs-number">1,3,2,4</span>], queryTime = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：startTime = [<span class="hljs-number">9,8,7,6</span>,<span class="hljs-number">5,4,3,2</span>,<span class="hljs-number">1</span>], endTime = [<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10</span>], queryTime = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>startTime.length == endTime.length</code></li><li><code>1 &lt;= startTime.length &lt;= 100</code></li><li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li><li><code>1 &lt;= queryTime &lt;= 1000</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不解释连招</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">busyStudent</span><span class="hljs-params">(<span class="hljs-type">int</span>[] startTime, <span class="hljs-type">int</span>[] endTime, <span class="hljs-type">int</span> queryTime)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; startTime.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (queryTime &lt; startTime[i] || queryTime &gt; endTime[i])<br>                <span class="hljs-keyword">continue</span>;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220820162628007.png" alt="image-20220820162628007"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1224.最大相等频率</title>
    <link href="/2022/08/18/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1224.%E6%9C%80%E5%A4%A7%E7%9B%B8%E7%AD%89%E9%A2%91%E7%8E%87/"/>
    <url>/2022/08/18/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1224.%E6%9C%80%E5%A4%A7%E7%9B%B8%E7%AD%89%E9%A2%91%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1224-最大相等频率"><a href="#1224-最大相等频率" class="headerlink" title="1224.最大相等频率"></a><a href="https://leetcode.cn/problems/maximum-equal-frequency/">1224.最大相等频率</a></h1><p>难度困难125收藏分享切换为英文接收动态反馈</p><p>给你一个正整数数组 <code>nums</code>，请你帮忙从该数组中找出能满足下面要求的 <strong>最长</strong> 前缀，并返回该前缀的长度：</p><ul><li>从前缀中 <strong>恰好删除一个</strong> 元素后，剩下每个数字的出现次数都相同。</li></ul><p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">2,2,1,1</span>,<span class="hljs-number">5,3,3,5</span>]<br>输出：<span class="hljs-number">7</span><br>解释：对于长度为 <span class="hljs-number">7</span> 的子数组 [<span class="hljs-number">2,2,1,1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]，如果我们从中删去 nums[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span>，就可以得到 [<span class="hljs-number">2,2,1,1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]，里面每个数字都出现了两次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,1,2</span>,<span class="hljs-number">2,2,3,3</span>,<span class="hljs-number">3,4,4,4</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1000010</span>], sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100010</span>];<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEqualFreq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.fill(cnt, <span class="hljs-number">0</span>);<br>        Arrays.fill(sum, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, max = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i], cur = ++cnt[t], len = i+<span class="hljs-number">1</span>;<br>            sum[cur]++;sum[cur-<span class="hljs-number">1</span>]--;<br>            max = Math.max(max, cur);<br>            <span class="hljs-keyword">if</span> (max == <span class="hljs-number">1</span>) ans = len;<br>            <span class="hljs-keyword">if</span> (max * sum[max] + <span class="hljs-number">1</span> == len) ans = len;<br>            <span class="hljs-keyword">if</span> ((max - <span class="hljs-number">1</span>) * (sum[max-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> == len) ans = len;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220818145211780.png" alt="image-20220818145211780"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1302.层数最深叶子节点的和</title>
    <link href="/2022/08/17/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1302.%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/"/>
    <url>/2022/08/17/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1302.%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1302-层数最深叶子节点的和"><a href="#1302-层数最深叶子节点的和" class="headerlink" title="1302.层数最深叶子节点的和"></a><a href="https://leetcode.cn/problems/deepest-leaves-sum/">1302.层数最深叶子节点的和</a></h1><p>难度中等132收藏分享切换为英文接收动态反馈</p><p>给你一棵二叉树的根节点 <code>root</code> ，请你返回 <strong>层数最深的叶子节点的和</strong> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/1483_ex1.png" alt="img"></strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br>输出：<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 104]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 100</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接层序遍历，但是好像有很多重复计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deepestLeavesSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp += node.val;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            ans = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220817215229769.png" alt="image-20220817215229769"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>广度优先遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>641.设计循环双端队列</title>
    <link href="/2022/08/15/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/641.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/08/15/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/641.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641.设计循环双端队列"></a><a href="https://leetcode.cn/problems/design-circular-deque/">641.设计循环双端队列</a></h1><p>难度中等167</p><p>设计实现双端队列。</p><p>实现 <code>MyCircularDeque</code> 类:</p><ul><li><code>MyCircularDeque(int k)</code> ：构造函数,双端队列最大为 <code>k</code> 。</li><li><code>boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>boolean insertLast()</code> ：将一个元素添加到双端队列尾部。如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>boolean deleteFront()</code> ：从双端队列头部删除一个元素。 如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>boolean deleteLast()</code> ：从双端队列尾部删除一个元素。如果操作成功返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>int getFront()</code> )：从双端队列头部获得一个元素。如果双端队列为空，返回 <code>-1</code> 。</li><li><code>int getRear()</code> ：获得双端队列的最后一个元素。 如果双端队列为空，返回 <code>-1</code> 。</li><li><code>boolean isEmpty()</code> ：若双端队列为空，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>boolean isFull()</code> ：若双端队列满了，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入<br>[<span class="hljs-string">&quot;MyCircularDeque&quot;</span>, <span class="hljs-string">&quot;insertLast&quot;</span>, <span class="hljs-string">&quot;insertLast&quot;</span>, <span class="hljs-string">&quot;insertFront&quot;</span>, <span class="hljs-string">&quot;insertFront&quot;</span>, <span class="hljs-string">&quot;getRear&quot;</span>, <span class="hljs-string">&quot;isFull&quot;</span>, <span class="hljs-string">&quot;deleteLast&quot;</span>, <span class="hljs-string">&quot;insertFront&quot;</span>, <span class="hljs-string">&quot;getFront&quot;</span>]<br>[[<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>], [], [], [], [<span class="hljs-number">4</span>], []]<br>输出<br>[null, true, true, true, false, <span class="hljs-number">2</span>, true, true, true, <span class="hljs-number">4</span>]<br><br>解释<br>MyCircularDeque circularDeque = new MycircularDeque(<span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 设置容量大小为<span class="hljs-number">3</span><br>circularDeque.insertLast(<span class="hljs-number">1</span>);        <span class="hljs-regexp">//</span> 返回 true<br>circularDeque.insertLast(<span class="hljs-number">2</span>);        <span class="hljs-regexp">//</span> 返回 true<br>circularDeque.insertFront(<span class="hljs-number">3</span>);        <span class="hljs-regexp">//</span> 返回 true<br>circularDeque.insertFront(<span class="hljs-number">4</span>);        <span class="hljs-regexp">//</span> 已经满了，返回 false<br>circularDeque.getRear();  <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">2</span><br>circularDeque.isFull();        <span class="hljs-regexp">//</span> 返回 true<br>circularDeque.deleteLast();        <span class="hljs-regexp">//</span> 返回 true<br>circularDeque.insertFront(<span class="hljs-number">4</span>);        <span class="hljs-regexp">//</span> 返回 true<br>circularDeque.getFront();<span class="hljs-regexp">//</span> 返回 <span class="hljs-number">4</span><br> <br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 1000</code></li><li><code>0 &lt;= value &lt;= 1000</code></li><li><code>insertFront</code>, <code>insertLast</code>, <code>deleteFront</code>, <code>deleteLast</code>, <code>getFront</code>, <code>getRear</code>, <code>isEmpty</code>, <code>isFull</code> 调用次数不大于 <code>2000</code> 次</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>判断队伍空 <code>front == rear</code></li><li>判断队伍是否满 <code>(rear + 1) % capacity == front</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularDeque</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front, rear;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>];<br>        capacity = k + <span class="hljs-number">1</span>;<br>        rear = front = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertFront</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(isFull())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        front = (front - <span class="hljs-number">1</span> + capacity) % capacity;<br>        queue[front] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        queue[rear] = value;<br>        rear = (rear+<span class="hljs-number">1</span>)% capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        front = (front + <span class="hljs-number">1</span>) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        rear = (rear - <span class="hljs-number">1</span> + capacity) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> queue[front];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> queue[(rear - <span class="hljs-number">1</span> + capacity) % capacity];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rear == front;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % capacity == front;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220815152010456.png" alt="image-20220815152010456"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>设计</tag>
      
      <tag>数组</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网易游戏雷火2022秋招Web后端开发工程师</title>
    <link href="/2022/08/14/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/0814-%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB2022%E7%A7%8B%E6%8B%9BWeb%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2022/08/14/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/0814-%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB2022%E7%A7%8B%E6%8B%9BWeb%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h1 id="0814-网易游戏雷火2022秋招Web后端开发工程师"><a href="#0814-网易游戏雷火2022秋招Web后端开发工程师" class="headerlink" title="0814-网易游戏雷火2022秋招Web后端开发工程师"></a>0814-网易游戏雷火2022秋招Web后端开发工程师</h1><h1 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814141816135.png" alt="image-20220814141816135"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814141828444.png" alt="image-20220814141828444"></p><p>这道题恶心的是输入的处理，需要将这个各种方括号的玩意儿读出来，解析为<code>ArrayList</code>，想了一下还是有办法可以解决的，直接根据<code>],</code>分割每个宝箱的钥匙，然后去除一些无关字符就得到了每个宝箱的钥匙，并且数据类型是二维<code>ArrayList</code></p><p>然后就是直接一个程序遍历解决问题，遍历的时候记个数，计算一下开启的宝箱数量，如果开启的数量刚好等于n，那么返回<code>true</code>，否则为<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        List&lt;List&lt;Integer&gt;&gt; boxs = getkeys(res);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> boxs.size();<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (!visited[temp]) &#123;<br>                visited[temp] = <span class="hljs-literal">true</span>;<br>                cnt++;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : boxs.get(temp)) &#123;<br>                    queue.add(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == n)<br>            System.out.println(<span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;false&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">getkeys</span><span class="hljs-params">(String res)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        String[] boxs = res.substring(<span class="hljs-number">1</span>, res.length()-<span class="hljs-number">2</span>).split(<span class="hljs-string">&quot;],&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String box: boxs) &#123;<br>            box = box.substring(<span class="hljs-number">1</span>, box.length());<br>            String[] ints = box.split(<span class="hljs-string">&quot;,&quot;</span>);<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (String i : ints) &#123;<br>                <span class="hljs-keyword">if</span> (!i.equals(<span class="hljs-string">&quot;&quot;</span>))<br>                    temp.add(Integer.parseInt(i));<br>            &#125;<br>            ans.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814144331774.png" alt="image-20220814144331774"></p><h1 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814144402261.png" alt="image-20220814144402261"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814144417241.png" alt="image-20220814144417241"></p><p>这道题想来很久还是有点猪脑过载，算了，算了，放弃了</p><h1 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814144810502.png" alt="image-20220814144810502"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814144823051.png" alt="image-20220814144823051"></p><p>本来以为递归会出现超时，但是好像没有。。</p><p>通过递归计算点在希尔伯特曲线的序号，然后计算两个序号的绝对值之差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n int整型 方格矩阵Cn下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x1 int整型 方格1在方格矩阵中的横坐标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y1 int整型 方格1在方格矩阵中的纵坐标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x2 int整型 方格2在方格矩阵中的横坐标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y2 int整型 方格2在方格矩阵中的纵坐标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> long长整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">solution</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">return</span> Math.abs(f(n, x1, y1) - f(n, x2, y2));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (n-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (x &lt;= m &amp;&amp; y &lt;= m)<br>            <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>, y, x);<br>        <span class="hljs-keyword">if</span> (x &gt; m &amp;&amp; y &lt;= m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3L</span> * m * m + f(n-<span class="hljs-number">1</span>, m-y+<span class="hljs-number">1</span>, m*<span class="hljs-number">2</span>-x + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (x &lt; m &amp;&amp; y &gt; m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span> * m * m + f(n-<span class="hljs-number">1</span>, x, y - m);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2L</span> * m * m + f(n - <span class="hljs-number">1</span>, x - m, y - m);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814153343171.png" alt="image-20220814153343171"></p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>网易游戏雷火</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1422.分割字符串的最大得分</title>
    <link href="/2022/08/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1422.%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/"/>
    <url>/2022/08/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1422.%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1422-分割字符串的最大得分"><a href="#1422-分割字符串的最大得分" class="headerlink" title="1422.分割字符串的最大得分"></a><a href="https://leetcode.cn/problems/maximum-score-after-splitting-a-string/">1422.分割字符串的最大得分</a></h1><p>难度简单65</p><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p><p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;011101&quot;<br>输出：5 <br>解释：<br>将字符串 s 划分为两个非空子字符串的可行方案有：<br>左子字符串 = &quot;0&quot; 且 右子字符串 = &quot;11101&quot;，得分 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 5 </span><br>左子字符串 = &quot;01&quot; 且 右子字符串 = &quot;1101&quot;，得分 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span><br>左子字符串 = &quot;011&quot; 且 右子字符串 = &quot;101&quot;，得分 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span><br>左子字符串 = &quot;0111&quot; 且 右子字符串 = &quot;01&quot;，得分 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 2 </span><br>左子字符串 = &quot;01110&quot; 且 右子字符串 = &quot;1&quot;，得分 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;00111&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：当 左子字符串 = <span class="hljs-string">&quot;00&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;111&quot;</span> 时，我们得到最大得分 = <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= s.length &lt;= 500</code></li><li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>前缀和和后缀和计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> chars.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                left[i+<span class="hljs-number">1</span>] = left[i] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left[i+<span class="hljs-number">1</span>] = left[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                right[i] = right[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right[i] = right[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ans = Math.max(ans, left[i] + right[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220814134812084.png" alt="image-20220814134812084"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>前缀和</tag>
      
      <tag>后缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1656.设计有序流</title>
    <link href="/2022/08/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1656.%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/"/>
    <url>/2022/08/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1656.%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1656-设计有序流"><a href="#1656-设计有序流" class="headerlink" title="1656.设计有序流"></a><a href="https://leetcode.cn/problems/design-an-ordered-stream/">1656.设计有序流</a></h1><p>难度简单54</p><p>有 <code>n</code> 个 <code>(id, value)</code> 对，其中 <code>id</code> 是 <code>1</code> 到 <code>n</code> 之间的一个整数，<code>value</code> 是一个字符串。不存在 <code>id</code> 相同的两个 <code>(id, value)</code> 对。</p><p>设计一个流，以 <strong>任意</strong> 顺序获取 <code>n</code> 个 <code>(id, value)</code> 对，并在多次调用时 <strong>按 <code>id</code> 递增的顺序</strong> 返回一些值。</p><p>实现 <code>OrderedStream</code> 类：</p><ul><li><p><code>OrderedStream(int n)</code> 构造一个能接收 <code>n</code> 个值的流，并将当前指针 <code>ptr</code> 设为 <code>1</code> 。</p></li><li><p>&#96;&#96;&#96;<br>String[] insert(int id, String value)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs"><br> <br><br>向流中存储新的<br><br> <br><br></code></pre></td></tr></table></figure><p>(id, value)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>   <br><br>  对。存储后：<br><br><span class="hljs-bullet">  -</span> 如果流存储有 <span class="hljs-code">`id = ptr`</span> 的 <span class="hljs-code">`(id, value)`</span> 对，则找出从 <span class="hljs-code">`id = ptr`</span> 开始的 <span class="hljs-strong">**最长 id 连续递增序列**</span> ，并 <span class="hljs-strong">**按顺序**</span> 返回与这些 id 关联的值的列表。然后，将 <span class="hljs-code">`ptr`</span> 更新为最后那个 <span class="hljs-code">`id + 1`</span> 。<br><span class="hljs-bullet">  -</span> 否则，返回一个空列表。<br><br> <br><br><span class="hljs-strong">**示例：**</span><br><br>![<span class="hljs-string">img</span>](<span class="hljs-link">https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/q1.gif</span>)<br><br></code></pre></td></tr></table></figure><p>输入<br>[“OrderedStream”, “insert”, “insert”, “insert”, “insert”, “insert”]<br>[[5], [3, “ccccc”], [1, “aaaaa”], [2, “bbbbb”], [5, “eeeee”], [4, “ddddd”]]<br>输出<br>[null, [], [“aaaaa”], [“bbbbb”, “ccccc”], [], [“ddddd”, “eeeee”]]</p></li></ul><p>解释<br>OrderedStream os&#x3D; new OrderedStream(5);<br>os.insert(3, “ccccc”); &#x2F;&#x2F; 插入 (3, “ccccc”)，返回 []<br>os.insert(1, “aaaaa”); &#x2F;&#x2F; 插入 (1, “aaaaa”)，返回 [“aaaaa”]<br>os.insert(2, “bbbbb”); &#x2F;&#x2F; 插入 (2, “bbbbb”)，返回 [“bbbbb”, “ccccc”]<br>os.insert(5, “eeeee”); &#x2F;&#x2F; 插入 (5, “eeeee”)，返回 []<br>os.insert(4, “ddddd”); &#x2F;&#x2F; 插入 (4, “ddddd”)，返回 [“ddddd”, “eeeee”]</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br> <br><br>**提示：**<br><br>- `1 &lt;= n &lt;= <span class="hljs-number">1000</span>`<br>- `1 &lt;= id &lt;= n`<br>- `value.length == <span class="hljs-number">5</span>`<br>- `value` 仅由小写字母组成<br>- 每次调用 `insert` 都会使用一个唯一的 `id`<br>- 恰好调用 `n` 次 `insert`<br><br># 题解<br><br>直接使用一个字符串数组存储流，然后设置ptr的变化即可<br><br>```java<br>class OrderedStream &#123;<br>    private String[] stream<span class="hljs-comment">;</span><br>    private int ptr<span class="hljs-comment">;</span><br>    public OrderedStream(int n) &#123;<br>        stream = <span class="hljs-keyword">new</span> String[n + <span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br>        ptr=<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    &#125;<br><br>    public List&lt;String&gt; insert(int idKey, String value) &#123;<br>        stream[idKey] = value<span class="hljs-comment">;</span><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br>        if (idKey == ptr) &#123;<br>            for (int i = ptr<span class="hljs-comment">; i &lt; stream.length; i++) &#123;</span><br>                if (stream[i] == null)<br>                    <span class="hljs-keyword">break</span><span class="hljs-comment">;</span><br>                res.add(stream[i])<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>        ptr += res.size()<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">return</span> res<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220816153119432.png" alt="image-20220816153119432"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>设计</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>数据流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>768.最多能完成排序的块II</title>
    <link href="/2022/08/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/768.%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97II/"/>
    <url>/2022/08/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/768.%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="768-最多能完成排序的块II"><a href="#768-最多能完成排序的块II" class="headerlink" title="768.最多能完成排序的块II"></a><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768.最多能完成排序的块II</a></h1><p>难度困难185</p><p><em>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为<code>2000</code>，其中的元素最大为<code>10**8</code>。</em></p><p><code>arr</code>是一个可能包含<strong>重复元素</strong>的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: arr = <span class="hljs-comment">[5,4,3,2,1]</span><br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 <span class="hljs-comment">[5, 4]</span>, <span class="hljs-comment">[3, 2, 1]</span> 的结果是 <span class="hljs-comment">[4, 5, 1, 2, 3]</span>，这不是有序的数组。 <br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: arr = <span class="hljs-comment">[2,1,3,4,4]</span><br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 <span class="hljs-comment">[2, 1]</span>, <span class="hljs-comment">[3, 4, 4]</span>。<br>然而，分成 <span class="hljs-comment">[2, 1]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[4]</span>, <span class="hljs-comment">[4]</span> 可以得到最多的块数。 <br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>arr</code>的长度在<code>[1, 2000]</code>之间。</li><li><code>arr[i]</code>的大小在<code>[0, 10**8]</code>之间。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>可以理解为如果可以分块，那么对应分块的左边分块的最大值一定小于等于右边分块的最小值</p><ul><li>首先从左到右遍历，获取对应i之前的最大值prev[i]</li><li>然后从右到左遍历，获取对应i之后的最小值next[i]</li><li>比较prev[i-1] &lt;&#x3D; next[i]成立，可以进行分块，计数加1</li></ul><p>返回计数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length, cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-comment">// 计算前缀最大</span><br>        prev[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            prev[i] = Math.max(arr[i], prev[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        Arrays.fill(next, Integer.MAX_VALUE);<br><br>        <span class="hljs-comment">// 计算后缀最小</span><br>        next[n-<span class="hljs-number">1</span>] = arr[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            next[i] = Math.min(arr[i], next[i+<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prev[i-<span class="hljs-number">1</span>] &lt;= next[i])<br>                cnt++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$ 数组长度，三次数组长度的遍历</li><li>空间复杂度：$O(n)$ 数组长度的空间复杂度，设置了两个辅助数组</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220813143608107.png" alt="image-20220813143608107"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1282.用户分组</title>
    <link href="/2022/08/12/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1282.%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/"/>
    <url>/2022/08/12/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1282.%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282.用户分组"></a><a href="https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/">1282.用户分组</a></h1><p>难度中等90收藏分享切换为英文接收动态反馈</p><p>有 <code>n</code> 个人被分成数量未知的组。每个人都被标记为一个从 <code>0</code> 到 <code>n - 1</code> 的<strong>唯一ID</strong> 。</p><p>给定一个整数数组 <code>groupSizes</code> ，其中 <code>groupSizes[i]</code> 是第 <code>i</code> 个人所在的组的大小。例如，如果 <code>groupSizes[1] = 3</code> ，则第 <code>1</code> 个人必须位于大小为 <code>3</code> 的组中。</p><p>返回一个组列表，使每个人 <code>i</code> 都在一个大小为 <em><code>groupSizes[i]</code></em> 的组中。</p><p>每个人应该 <strong>恰好只</strong> 出现在 <strong>一个组</strong> 中，并且每个人必须在一个组中。如果有多个答案，返回其中 <strong>任何</strong> 一个。可以 <strong>保证</strong> 给定输入 <strong>至少有一个</strong> 有效的解。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：groupSizes = <span class="hljs-comment">[3,3,3,3,3,1,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[0,1,2]</span>,<span class="hljs-comment">[3,4,6]</span>]</span><br>解释：<br>第一组是 <span class="hljs-comment">[5]</span>，大小为 1，groupSizes<span class="hljs-comment">[5]</span> = 1。<br>第二组是 <span class="hljs-comment">[0,1,2]</span>，大小为 3，groupSizes<span class="hljs-comment">[0]</span> = groupSizes<span class="hljs-comment">[1]</span> = groupSizes<span class="hljs-comment">[2]</span> = 3。<br>第三组是 <span class="hljs-comment">[3,4,6]</span>，大小为 3，groupSizes<span class="hljs-comment">[3]</span> = groupSizes<span class="hljs-comment">[4]</span> = groupSizes<span class="hljs-comment">[6]</span> = 3。 <br>其他可能的解决方案有 <span class="hljs-comment">[<span class="hljs-comment">[2,1,6]</span>,<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[0,4,3]</span>]</span> 和 <span class="hljs-comment">[<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[0,6,2]</span>,<span class="hljs-comment">[4,3,1]</span>]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：groupSizes = <span class="hljs-comment">[2,1,3,3,3,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[0,5]</span>,<span class="hljs-comment">[2,3,4]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>groupSizes.length == n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>1 &lt;= groupSizes[i] &lt;= n</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">groupThePeople</span><span class="hljs-params">(<span class="hljs-type">int</span>[] groupSizes)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> groupSizes.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.getOrDefault(groupSizes[i], <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span> &amp;&amp; ans.get(index-<span class="hljs-number">1</span>).size() &lt; groupSizes[i]) &#123;<br>                ans.get(index-<span class="hljs-number">1</span>).add(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            temp.add(i);<br>            ans.add(temp);<br>            map.put(groupSizes[i], ans.size());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220812114605406.png" alt="image-20220812114605406"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zoom 2023届校园招聘-Java方向0810</title>
    <link href="/2022/08/11/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/Zoom2023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98-Java%E6%96%B9%E5%90%910810/"/>
    <url>/2022/08/11/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/Zoom2023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98-Java%E6%96%B9%E5%90%910810/</url>
    
    <content type="html"><![CDATA[<h1 id="Zoom-2023届校园招聘-Java方向0810"><a href="#Zoom-2023届校园招聘-Java方向0810" class="headerlink" title="Zoom 2023届校园招聘-Java方向0810"></a>Zoom 2023届校园招聘-Java方向0810</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810192347753.png" alt="image-20220810192347753"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810192402382.png" alt="image-20220810192402382"></p><p>最开始想的建树，但是好像有点麻烦，直接用邻接矩阵存储结点关系，然后遍历，结果报堆溢出，想来可能是后面结点数太大了，创建邻接矩阵的时候就导致堆溢出，改为邻接表，用ArrayList来存储结点</p><p>遍历获取权重计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] weights;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">colors</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        weights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            weights[i] = colors.charAt(i)==<span class="hljs-string">&#x27;R&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br><br>        List&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            graph.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> scanner.nextInt(), end = scanner.nextInt();<br>            graph.get(start-<span class="hljs-number">1</span>).add(end-<span class="hljs-number">1</span>);<br>            graph.get(end-<span class="hljs-number">1</span>).add(start-<span class="hljs-number">1</span>);<br>        &#125;<br><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        ans[<span class="hljs-number">0</span>] = weights[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        queue.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; graph.get(pre).size(); i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> graph.get(pre).get(i);<br>                <span class="hljs-keyword">if</span> (temp != pre &amp;&amp; !visited[temp]) &#123;<br>                    ans[temp] = weights[temp] + ans[pre];<br>                    visited[temp] = <span class="hljs-literal">true</span>;<br>                    queue.add(temp);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : ans)<br>            sum += Math.abs(a);<br><br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不知道为什么总有几个测试案例没过，难顶</p><p>不知道是不是最后的sum没有定义为long，导致最后求和的结果溢出所以导致错误的。。。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810202920693.png" alt="image-20220810202920693"></p><h1 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810192427777.png" alt="image-20220810192427777"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810192437919.png" alt="image-20220810192437919"></p><p>这道题应该是用并查集，完全没有研究过，开摆</p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>Zoom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>联想2023校招-python后端方向</title>
    <link href="/2022/08/11/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E8%81%94%E6%83%B32023%E6%A0%A1%E6%8B%9B-python%E5%90%8E%E7%AB%AF%E6%96%B9%E6%B3%95/"/>
    <url>/2022/08/11/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E8%81%94%E6%83%B32023%E6%A0%A1%E6%8B%9B-python%E5%90%8E%E7%AB%AF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="联想2023校招-后端开发"><a href="#联想2023校招-后端开发" class="headerlink" title="联想2023校招-后端开发"></a>联想2023校招-后端开发</h1><h1 id="编程题1-剪刀石头布"><a href="#编程题1-剪刀石头布" class="headerlink" title="编程题1-剪刀石头布"></a>编程题1-剪刀石头布</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810212412491.png" alt="image-20220810212412491"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> String[] choices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Rock&quot;</span>, <span class="hljs-string">&quot;Scissor&quot;</span>, <span class="hljs-string">&quot;Paper&quot;</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        String[] alice = s1.split(<span class="hljs-string">&quot; &quot;</span>), bob = s2.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> isWin(alice[i], bob[i]);<br>            <span class="hljs-keyword">if</span> (score == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">0</span>)<br>                ans1++;<br>            <span class="hljs-keyword">else</span><br>                ans2++;<br>        &#125;<br>        System.out.println(ans1 + <span class="hljs-string">&quot; &quot;</span> + ans2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">isWin</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s1.equals(choices[<span class="hljs-number">0</span>]) &amp;&amp; s2.equals(choices[<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s1.equals(choices[<span class="hljs-number">1</span>]) &amp;&amp; s2.equals(choices[<span class="hljs-number">2</span>]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s1.equals(choices[<span class="hljs-number">2</span>]) &amp;&amp; s2.equals(choices[<span class="hljs-number">0</span>]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s1.equals(s2))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810213722418.png" alt="image-20220810213722418"></p><h1 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810212433469.png" alt="image-20220810212433469"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810212446074.png" alt="image-20220810212446074"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        String[] days = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-comment">//            scanner.nextLine();</span><br>            days[i] = scanner.nextLine();<br>        &#125;<br><br>        TreeSet&lt;String&gt; sortedWords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String day : days) &#123;<br>            String[] words = day.split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">for</span> (String word : words) &#123;<br>                sortedWords.add(word);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!sortedWords.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sortedWords.pollFirst();<br>            <span class="hljs-keyword">if</span> (cnt + temp.length() &gt; <span class="hljs-number">50</span>) &#123;<br>                System.out.print(<span class="hljs-string">&quot;\n&quot;</span> + temp + <span class="hljs-string">&quot; &quot;</span>);<br>                cnt = <span class="hljs-number">0</span>;<br>                cnt += temp.length() + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.print(temp + <span class="hljs-string">&quot; &quot;</span>);<br>                cnt += temp.length() + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810215212581.png" alt="image-20220810215212581"></p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>联想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1417.重新格式化字符串</title>
    <link href="/2022/08/11/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1417.%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/08/11/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1417.%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1417-重新格式化字符串"><a href="#1417-重新格式化字符串" class="headerlink" title="1417.重新格式化字符串"></a><a href="https://leetcode.cn/problems/reformat-the-string/">1417.重新格式化字符串</a></h1><p>难度简单54收藏分享切换为英文接收动态反馈</p><p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p><p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p><p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;a0b1c2&quot;</span><br>输出：<span class="hljs-string">&quot;0a1b2c&quot;</span><br>解释：<span class="hljs-string">&quot;0a1b2c&quot;</span> 中任意两个相邻字符的类型都不同。 <span class="hljs-string">&quot;a0b1c2&quot;</span>, <span class="hljs-string">&quot;0a1b2c&quot;</span>, <span class="hljs-string">&quot;0c2a1b&quot;</span> 也是满足题目要求的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<span class="hljs-string">&quot;leetcode&quot;</span> 中只有字母，所以无法满足重新格式化的条件。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1229857369&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<span class="hljs-string">&quot;1229857369&quot;</span> 中只有数字，所以无法满足重新格式化的条件。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;covid2019&quot;</span><br>输出：<span class="hljs-string">&quot;c2o0v1i9d&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab123&quot;</span><br>输出：<span class="hljs-string">&quot;1a2b3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母和&#x2F;或数字组成。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先计算字母和数字的长度，两者长度差大于1，说明无解，直接返回空字符串</p><p>有解的情况就先放数量多的字符到结果中，然后间隔放另一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reformat</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numberCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">alph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isNumber(chars[i])) &#123;<br>                numberCnt++;<br>                numbers.append(chars[i]);<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                alph.append(chars[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">charCnt</span> <span class="hljs-operator">=</span> n-numberCnt;<br>        <span class="hljs-keyword">if</span> (Math.abs(numberCnt - charCnt) &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (charCnt &lt; numberCnt) &#123;<br>            flag=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">char</span>[] chars1 = alph.toString().toCharArray();<br>        <span class="hljs-type">char</span>[] chars2 = numbers.toString().toCharArray();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==flag) &#123;<br>                ans.append(chars1[cnt1]);<br>                cnt1++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.append(chars2[cnt2]);<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220811125016537.png" alt="image-20220811125016537"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>640.求解方程</title>
    <link href="/2022/08/10/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/640.%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/"/>
    <url>/2022/08/10/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/640.%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="640-求解方程"><a href="#640-求解方程" class="headerlink" title="640.求解方程"></a><a href="https://leetcode.cn/problems/solve-the-equation/">640.求解方程</a></h1><p>难度中等124收藏分享切换为英文接收动态反馈</p><p>求解一个给定的方程，将<code>x</code>以字符串 <code>&quot;x=#value&quot;</code> 的形式返回。该方程仅包含 <code>&#39;+&#39;</code> ， <code>&#39;-&#39;</code> 操作，变量 <code>x</code> 和其对应系数。</p><p>如果方程没有解，请返回 <code>&quot;No solution&quot;</code> 。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</p><p>题目保证，如果方程中只有一个解，则 ‘x’ 的值是一个整数。</p><p><strong>示例 1：</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">输入: <span class="hljs-keyword">equation</span> = <span class="hljs-string">&quot;x+5-3+x=6+x-2&quot;</span><br>输出: <span class="hljs-string">&quot;x=2&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">输入: <span class="hljs-keyword">equation</span> = <span class="hljs-string">&quot;x=x&quot;</span><br>输出: <span class="hljs-string">&quot;Infinite solutions&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">输入: <span class="hljs-keyword">equation</span> = <span class="hljs-string">&quot;2x=x&quot;</span><br>输出: <span class="hljs-string">&quot;x=0&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>3 &lt;= equation.length &lt;= 1000</code></li><li><code>equation</code> 只有一个 <code>&#39;=&#39;</code>.</li><li><code>equation</code> 方程由整数组成，其绝对值在 <code>[0, 100]</code> 范围内，不含前导零和变量 <code>&#39;x&#39;</code> 。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>思路是将方程通过<code>=</code>划分为前项和后项，然后分别对前项和后项处理，为了统一的划分各个项，可以首先替换<code>-</code>为<code>+-</code>，然后根据<code>+</code>划分，之后遍历处理所有的项，分别得到系数值和其他值，然后按照等式的计算公式得到系数<code>coef</code>和值<code>val</code>，方程解的判断：</p><ul><li><code>coef=1 &amp;&amp; val==0</code> 也就是x可以任意取值，即可满足方程要求，所以是无限解</li><li><code>coef==0&amp;&amp;val!=0</code> x取任意值也无法满足方程要求，没有解</li></ul><p>其他情况直接输出<code>x=</code>+解的字符串即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">solveEquation</span><span class="hljs-params">(String equation)</span> &#123;<br>        String[] equations = equation.split(<span class="hljs-string">&quot;=&quot;</span>);<br>        <span class="hljs-type">int</span>[] res1 = getCoefVal(equations[<span class="hljs-number">0</span>]), res2= getCoefVal(equations[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> res2[<span class="hljs-number">1</span>] - res1[<span class="hljs-number">1</span>], coef = res1[<span class="hljs-number">0</span>] - res2[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (coef == <span class="hljs-number">0</span> &amp;&amp; val == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Infinite solutions&quot;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (coef == <span class="hljs-number">0</span> &amp;&amp; val != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No solution&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;x=&quot;</span> + String.valueOf(val/coef);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getCoefVal(String equation) &#123;<br>        List&lt;Integer&gt; coef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> equation.replaceAll(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;+-&quot;</span>);<br>        String[] items = temp.split(<span class="hljs-string">&quot;\\+&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String item:items) &#123;<br>            <span class="hljs-keyword">if</span> (item.length()==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (item.contains(<span class="hljs-string">&quot;x&quot;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (item.length()==<span class="hljs-number">1</span>) &#123;<br>                    coef.add(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.length()==<span class="hljs-number">2</span> &amp;&amp; item.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    coef.add(-<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    coef.add(Integer.valueOf(item.substring(<span class="hljs-number">0</span>, item.length()-<span class="hljs-number">1</span>)));<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                val.add(Integer.parseInt(item));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> co:coef)<br>            res[<span class="hljs-number">0</span>] += co;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v:val)<br>            res[<span class="hljs-number">1</span>] += v;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220810110642683.png" alt="image-20220810110642683"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1413逐步求和得到正数的最小值</title>
    <link href="/2022/08/09/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1413.%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2022/08/09/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1413.%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="1413-逐步求和得到正数的最小值"><a href="#1413-逐步求和得到正数的最小值" class="headerlink" title="1413.逐步求和得到正数的最小值"></a><a href="https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/">1413.逐步求和得到正数的最小值</a></h1><p>难度简单76收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 <strong>正数</strong> startValue 作为初始值。</p><p>你需要从左到右遍历 <code>nums</code> 数组，并将 startValue 依次累加上 <code>nums</code> 数组中的值。</p><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 <strong>正数</strong> 作为 startValue 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-3</span>,2,<span class="hljs-string">-3</span>,4,2]<br>输出：5<br>解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。<br>                累加求和<br>                startValue = 4 | startValue = 5 | nums<br>                  (4 <span class="hljs-string">-3</span> ) = 1  | (5 <span class="hljs-string">-3</span> ) = 2    |  <span class="hljs-string">-3</span><br>                  (1 <span class="hljs-string">+2</span> ) = 3  | (2 <span class="hljs-string">+2</span> ) = 4    |   2<br>                  (3 <span class="hljs-string">-3</span> ) = 0  | (4 <span class="hljs-string">-3</span> ) = 1    |  <span class="hljs-string">-3</span><br>                  (0 <span class="hljs-string">+4</span> ) = 4  | (1 <span class="hljs-string">+4</span> ) = 5    |   4<br>                  (4 <span class="hljs-string">+2</span> ) = 6  | (5 <span class="hljs-string">+2</span> ) = 7    |   2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2]</span><br><span class="hljs-string">输出：1</span><br><span class="hljs-string">解释：最小的 startValue 需要是正数。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>]<br>输出：5<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>就直接按照题目模拟，找到累加过程中的最小值即可，对于这个最小值，需要分两种情况判断：</p><ul><li>如果最小值小于0，返回其相反数并加1</li><li>如果最小值大于0，直接返回1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minStartValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>            min = Math.min(min, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> min &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>-min : <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220809173222176.png" alt="image-20220809173222176"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>761特殊的二进制序列</title>
    <link href="/2022/08/08/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/761.%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97/"/>
    <url>/2022/08/08/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/761.%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="761-特殊的二进制序列"><a href="#761-特殊的二进制序列" class="headerlink" title="761.特殊的二进制序列"></a><a href="https://leetcode.cn/problems/special-binary-string/">761.特殊的二进制序列</a></h1><p>难度困难197收藏分享切换为英文接收动态反馈</p><p>特殊的二进制序列是具有以下两个性质的二进制序列：</p><ul><li>0 的数量与 1 的数量相等。</li><li>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。</li></ul><p>给定一个特殊的二进制序列 <code>S</code>，以字符串形式表示。定义一个<em>操作</em> 为首先选择 <code>S</code> 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)</p><p>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <span class="hljs-symbol">S</span> = <span class="hljs-string">&quot;11011000&quot;</span><br>输出: <span class="hljs-string">&quot;11100100&quot;</span><br>解释:<br>将子串 <span class="hljs-string">&quot;10&quot;</span> （在<span class="hljs-symbol">S</span>[<span class="hljs-number">1</span>]出现） 和 <span class="hljs-string">&quot;1100&quot;</span> （在<span class="hljs-symbol">S</span>[<span class="hljs-number">3</span>]出现）进行交换。<br>这是在进行若干次操作后按字典序排列最大的结果。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>S</code> 的长度不超过 <code>50</code>。</li><li><code>S</code> 保证为一个满足上述定义的<em>特殊</em> 的二进制序列。</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>主要是采用分治的思想，找到整体字符串中可以拆分的子串，使用递归处理得到完全无法拆分的子串，然后将这些子串按照降序排序，再拼接起来，就得到了字典序最大的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeLargestSpecial</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>        List&lt;String&gt; subs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt--;<br>                <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>                    subs.add(<span class="hljs-string">&quot;1&quot;</span> + makeLargestSpecial(s.substring(left+<span class="hljs-number">1</span>, i)) + <span class="hljs-string">&quot;0&quot;</span>);<br>                    left = i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        subs.sort((a, b) -&gt; b.compareTo(a));<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (String sub : subs)<br>            ans.append(sub);<br><br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220809210913515.png" alt="image-20220809210913515"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>字符串</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023届米哈游秋招-平台后端第1批</title>
    <link href="/2022/08/07/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/2023%E5%B1%8A%E7%B1%B3%E5%93%88%E6%B8%B8%E7%A7%8B%E6%8B%9B%E5%90%8E%E7%AB%AF%E7%AC%AC%E4%B8%80%E6%89%B9/"/>
    <url>/2022/08/07/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/2023%E5%B1%8A%E7%B1%B3%E5%93%88%E6%B8%B8%E7%A7%8B%E6%8B%9B%E5%90%8E%E7%AB%AF%E7%AC%AC%E4%B8%80%E6%89%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="2023届米哈游秋招-平台后端第1批"><a href="#2023届米哈游秋招-平台后端第1批" class="headerlink" title="2023届米哈游秋招-平台后端第1批"></a>2023届米哈游秋招-平台后端第1批</h1><h1 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807201723443.png" alt="image-20220807201723443"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807201733980.png" alt="image-20220807201733980"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">char</span>[] html = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> html.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">open</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;div&gt;&quot;</span>, close = <span class="hljs-string">&quot;&lt;/div&gt;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (html[i] == <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (len - i &gt;= <span class="hljs-number">5</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (str.substring(i, i+<span class="hljs-number">5</span>).equals(open)) &#123;<br>                        cnt++;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len - i &gt;= <span class="hljs-number">6</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (cnt&gt;<span class="hljs-number">0</span> &amp;&amp; str.substring(i, i+<span class="hljs-number">6</span>).equals(close)) &#123;<br>                        cnt--;<br>                        ans++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807202825639.png" alt="image-20220807202825639"></p><h1 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807202904112.png" alt="image-20220807202904112"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807202918549.png" alt="image-20220807202918549"></p><h1 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807203151788.png" alt="image-20220807203151788"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807203203258.png" alt="image-20220807203203258"></p><p>我发现我应该不适合做游戏开发，还是老老实实投Java后端吧:cry:</p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>米哈游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科大讯飞2023届秋招研发类笔试试卷A(二)</title>
    <link href="/2022/08/06/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E2023%E5%B1%8A%E7%A7%8B%E6%8B%9B%E7%A0%94%E5%8F%91%E7%B1%BB%E7%AC%94%E8%AF%95%E8%AF%95%E5%8D%B7A(%E4%BA%8C)/"/>
    <url>/2022/08/06/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E2023%E5%B1%8A%E7%A7%8B%E6%8B%9B%E7%A0%94%E5%8F%91%E7%B1%BB%E7%AC%94%E8%AF%95%E8%AF%95%E5%8D%B7A(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>做科大讯飞的时候，我真是脑子瓦特了，点到第三题的时候，提交运行，结果把编程题子卷全部提交了，前面两道题还没看，敲，虽然很是无能狂怒，不过还是好好看看这些题吧，这些题是我线下思考了一下写的，没有线上测试过，不能保证AC，有发现问题的同学请提出宝贵的意见:blush:</p><span id="more"></span><h1 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806193011145.png" alt="image-20220806193011145"></p><p>直接暴力循环判断吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcE</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, temp=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] strs = str.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i]==<span class="hljs-string">&#x27;e&#x27;</span> || strs[i] == <span class="hljs-string">&#x27;E&#x27;</span>)<br>                temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (strs[i] = <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; temp == <span class="hljs-number">1</span>) &#123;<br>                temp = <span class="hljs-number">0</span>;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不保证AC</p><h1 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806193117999.png" alt="image-20220806193117999"></p><p>将四边形分为两个三角形，然后计算两个三角形面积之和，三角形面积计算通过海伦公式</p><p>海伦公式，假设三角形边长分别是a，b，c，则有<br>$$<br>s &#x3D; \frac{a+b+c}{2} \<br>S_\Delta &#x3D; \sqrt{s(s-a)(s-b)(s-c)}<br>$$<br>最后将<code>double</code>转换为<code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] point1, <span class="hljs-type">int</span>[] point2, <span class="hljs-type">int</span>[] point3, <span class="hljs-type">int</span>[] point4)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span>  calcTrangle(point1, point2, point3) + calcTrangle(point2, point3, point4);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.ceil(temp);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcTrangle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] point1, <span class="hljs-type">int</span>[] point2, <span class="hljs-type">int</span>[] point3)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> calcDistance(point1, point2);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> calcDistance(point2, point3);<br>        <span class="hljs-type">double</span> c= calcDistance(point1, point3);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (a+b+c)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> Math.sqrt(s*(s-a) * (s-b) * (s-c));<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] point1, <span class="hljs-type">int</span>[] point2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.sqrt((point1[<span class="hljs-number">0</span>] - point2[<span class="hljs-number">0</span>]) * (point1[<span class="hljs-number">0</span>] - point2[<span class="hljs-number">0</span>]) + (point1[<span class="hljs-number">1</span>] - point2[<span class="hljs-number">1</span>]) * (point1[<span class="hljs-number">1</span>] - point2[<span class="hljs-number">1</span>]));<br>    &#125;<br></code></pre></td></tr></table></figure><p>不保证AC</p><h1 id="编程题3-x3D-x3D-宕机-x3D-x3D"><a href="#编程题3-x3D-x3D-宕机-x3D-x3D" class="headerlink" title="编程题3&#x3D;&#x3D;宕机&#x3D;&#x3D;"></a>编程题3&#x3D;&#x3D;宕机&#x3D;&#x3D;</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806193423392.png" alt="image-20220806193423392"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806193434327.png" alt="image-20220806193434327"></p><p>我也宕机了</p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>美团</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1408数组中的字符串匹配</title>
    <link href="/2022/08/06/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1408.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/08/06/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1408.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1408-数组中的字符串匹配"><a href="#1408-数组中的字符串匹配" class="headerlink" title="1408.数组中的字符串匹配"></a><a href="https://leetcode.cn/problems/string-matching-in-an-array/">1408.数组中的字符串匹配</a></h1><p>难度简单68</p><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p><p>如果你可以删除 <code>words[j]</code> 最左侧和&#x2F;或最右侧的若干字符得到 <code>word[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;mass&quot;</span>,<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-string">&quot;hero&quot;</span>,<span class="hljs-string">&quot;superhero&quot;</span>]<br>输出：[<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-string">&quot;hero&quot;</span>]<br>解释：<span class="hljs-string">&quot;as&quot;</span> 是 <span class="hljs-string">&quot;mass&quot;</span> 的子字符串，<span class="hljs-string">&quot;hero&quot;</span> 是 <span class="hljs-string">&quot;superhero&quot;</span> 的子字符串。<br>[<span class="hljs-string">&quot;hero&quot;</span>,<span class="hljs-string">&quot;as&quot;</span>] 也是有效的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;leetcode&quot;</span>,<span class="hljs-string">&quot;et&quot;</span>,<span class="hljs-string">&quot;code&quot;</span>]<br>输出：[<span class="hljs-string">&quot;et&quot;</span>,<span class="hljs-string">&quot;code&quot;</span>]<br>解释：<span class="hljs-string">&quot;et&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 都是 <span class="hljs-string">&quot;leetcode&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-string">&quot;bu&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 仅包含小写英文字母。</li><li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题本以为有高论，想着kmp算法啥的，不过是在不太会，就直接暴力了，稍微做了一点点优化，把字符串数组按照长度从小到大排序，然后从排序的字符开始查看之后的字符串中是否包含该字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">stringMatching</span><span class="hljs-params">(String[] words)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        Arrays.sort(words, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> &#123;<br>                <span class="hljs-keyword">return</span> a.length() - b.length();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (words[j].indexOf(words[i]) &gt;= <span class="hljs-number">0</span>) &#123;<br>                    ans.add(words[i]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2 \times m^2)$</li><li>空间复杂度：$O(l)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806171141233.png" alt="image-20220806171141233"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>字符串</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团2023届笔试第一批</title>
    <link href="/2022/08/06/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%BE%8E%E5%9B%A22023%E5%B1%8A%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/08/06/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%BE%8E%E5%9B%A22023%E5%B1%8A%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>记录一下美团笔试的编程题，两个小时五道编程题，时间有点赶，思路经常转不过弯来，还得好好努力努力</p><span id="more"></span><h1 id="美团2023届秋招笔试记录"><a href="#美团2023届秋招笔试记录" class="headerlink" title="美团2023届秋招笔试记录"></a>美团2023届秋招笔试记录</h1><h1 id="编程题1-小美的礼盒包装-x3D-x3D-AC-x3D-x3D"><a href="#编程题1-小美的礼盒包装-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题1-小美的礼盒包装&#x3D;&#x3D;AC?&#x3D;&#x3D;"></a>编程题1-小美的礼盒包装&#x3D;&#x3D;AC?&#x3D;&#x3D;</h1><p><strong>题目描述</strong></p><p>小美开的西点屋子举办一周年活动，她准备制作一批礼盒作为对消费者的回馈，每个礼盒中都有三枚西点屋的招牌点心。为了让消费者能品尝到两种点心，因此每个礼盒中都要包含至少一批A点心和一枚B点心，现在小美的西点屋内共有x枚A点心和y枚B点心，请问小美最多可以制作多少礼盒</p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入第一行包含一个正整数 <span class="hljs-built_in">T</span>, 表示数据组数 (<span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">T</span> &lt;= <span class="hljs-number">10000</span>)<br>然后有<span class="hljs-built_in">T</span>行，每行包括两个整数 x 和 y, 空格隔开，表示有 x 枚 A 点心和 y 枚 B 点心 （<span class="hljs-number">1</span> &lt;= x, y &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">输出包含<span class="hljs-built_in">T</span>行，每行一个整数，表示最多可以制作的礼盒数量<br></code></pre></td></tr></table></figure><p><strong>样例输入</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">44 </span><span class="hljs-number">85</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">49</span><br></code></pre></td></tr></table></figure><p><strong>样例输出</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">43<br>9<br></code></pre></td></tr></table></figure><p>对于这一道题，对于任意一个盒子，只能有两种放点心的方式：</p><ul><li>A点心放一个，B点心放两个</li><li>A点心放两个，B点心放一个</li></ul><p>对于以上两种情况分别定义为 $\alpha, \beta$，则可以得到以下公式<br>$$<br>2 \alpha + \beta \leq x \<br>\alpha + 2 \beta \leq y<br>$$<br>将上面两个式子相加，得到<br>$$<br>3(\alpha+\beta)\leq x+y<br>\rightarrow \alpha + \beta \leq \frac{x+y}{3}<br>$$</p><p>这是一个限制条件，另外如果是A点心太少，只能尽可能的每个盒子只选一枚点心来装盒，即 $\alpha&#x3D;0$，那么根据不等式方程组就有<br>$$\beta\leq x$$<br>反之，也有B点心太少，$\beta&#x3D;0$，也有<br>$$\alpha \leq y$$</p><p>所以综合得到判断公式是<br>$$<br>\min(x, y, \frac{x+y}{3})<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> scanner.nextInt(), B = scanner.nextInt();<br>            System.out.println(calcgift(A, B));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcgift</span><span class="hljs-params">(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.min(A, B, (A+B)/<span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806102300911.png" alt="image-20220806102300911"></p><p>提交前代码没有完全AC，不保证修改后的代码完全AC</p><h1 id="编程题2-x3D-x3D-AC-x3D-x3D"><a href="#编程题2-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题2&#x3D;&#x3D;AC?&#x3D;&#x3D;"></a>编程题2&#x3D;&#x3D;AC?&#x3D;&#x3D;</h1><p><strong>题目描述</strong></p><p>小美在做一个实验，这个实验会在纸带上打印出若干个数字，已知该实验所呈现出的正确结果应该是存在某一个分割出k，在k之前打印出的数字都是小于0的，而在k之后的数字应该都是大于0的，那么在k之前如果某一个数据大于等于0，那么我们认为这个数组是异常的，同理，在k之后如果某一个数据小于等于0，那么我们也认为这个数据是异常的。</p><p>现在给出小美打印的纸带，且k是未知的，那么请问在最乐观的情况下至少有多少个实验数据是异常的（显然如果出现0，无论k为哪个时刻，这个0数据都是异常的)</p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入第一行包含一个正整数<span class="hljs-built_in">n</span>，表示小美在纸带上打印的数字数量，(<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">100000</span>)<br>输入第二行包含<span class="hljs-built_in">n</span>个整数，即小美在纸带上打印的数字，中间用空格隔开，数字仅会-<span class="hljs-number">1</span>， <span class="hljs-number">0</span>， <span class="hljs-number">1</span>中的一个<br></code></pre></td></tr></table></figure><p><strong>样例输入</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span>-<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>在最乐观的情况下，k应该在第二个和第三个数字之间，此时第一个和最后一个数据是异常的</p></blockquote><p>动态规划分别设置两个数组，记录的是当前 i 前异常的数和 i 后异常的数，比较最小的异常数，返回对应索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span>)<br>                prev[i+<span class="hljs-number">1</span>] = prev[i] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                prev[i+<span class="hljs-number">1</span>] = prev[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min_err</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, idex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= <span class="hljs-number">0</span>)<br>                next[i] = next[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                next[i] = next[i+<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span> (min_err &gt; next[i] + prev[i+<span class="hljs-number">1</span>]) &#123;<br>                min_err = next[i] + prev[i+<span class="hljs-number">1</span>];<br>                idex = i;<br>            &#125;<br>        &#125;<br><br>        System.out.println(idex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806111140299.png" alt="image-20220806111140299"></p><p>提交前的代码没有完全AC，不保证修改后的代码能够AC</p><h1 id="编程题3-x3D-x3D-AC-x3D-x3D"><a href="#编程题3-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题3&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题3&#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p><strong>题目描述</strong></p><p>小美有n块魔法石，每块魔法石都有正反两面，每一面都刻有一个魔法阵，初始状态下，n块魔法石都是正面向上。这n块魔法石的能量刚好可以构建一个大型魔法阵，但是需要至少一般的魔法石向上的一面铭刻的阵法相同才能触发大型魔法阵的效果。</p><p>小美希望反转最少数量的魔法石，使得这个大型魔法阵被触发，请问她最少需要翻转多少块魔法石。</p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入第一行包含一个正整数<span class="hljs-built_in">n</span>，表示魔法石的数量<br>（<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">100000</span>)<br>输入第二行包含<span class="hljs-built_in">n</span>个正整数，表示<span class="hljs-built_in">n</span>块魔法石正面铭刻的魔法阵种类，由于魔法书上记载的魔法阵数量太多，所以魔法阵编号可能是从<span class="hljs-number">1</span>到<span class="hljs-number">10</span>^<span class="hljs-number">9</span>的任何一个正整数<br>输入第三行包含<span class="hljs-built_in">n</span>个正整数，表示<span class="hljs-built_in">n</span>块魔法石反而正面铭刻的魔法阵种类，魔法阵编号同样在<span class="hljs-number">1</span>到<span class="hljs-number">10</span>^<span class="hljs-number">9</span>之间<br>数字间两两有空格隔开<br></code></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输出仅包含一个整数，如果有解则输出最少翻转的魔法石数量，如果无解则输出<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>计每个牌出现的数量，因为能出现一半以上的最多四种吧，然后去遍历能出现一半以上的数量，然后去扣掉正面牌上这个数的数量，就是需要翻牌的数量。然后找最小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Q3</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> up[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> down[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            up[i] = sc.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            down[i] = sc.nextInt();<br>        &#125;<br>        System.out.println(minOps(n,up,down));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOps</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] up, <span class="hljs-type">int</span>[] down)</span>&#123;<br>        HashMap&lt;Integer,Integer&gt; allMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Integer,Integer&gt; upMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//先统计个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//两面相同统计一次</span><br>            allMap.put(up[i],allMap.getOrDefault(up[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(up[i]!=down[i])&#123;<br>                allMap.put(down[i],allMap.getOrDefault(down[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            &#125;<br>            upMap.put(up[i],upMap.getOrDefault(up[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>?n/<span class="hljs-number">2</span>:n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (Integer key : allMap.keySet()) &#123;<br>            <span class="hljs-keyword">if</span>(allMap.get(key)&gt;=target)&#123;<br>                ans = Math.min(ans,upMap.getOrDefault(key,<span class="hljs-number">0</span>)&gt;=target?<span class="hljs-number">0</span>:target-upMap.getOrDefault(key,<span class="hljs-number">0</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==n+<span class="hljs-number">1</span>?-<span class="hljs-number">1</span>:ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806110149606.png" alt="image-20220806110149606"></p><p>不保证完全AC</p><h1 id="编程题4-x3D-x3D-AC-x3D-x3D"><a href="#编程题4-x3D-x3D-AC-x3D-x3D" class="headerlink" title="编程题4&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>编程题4&#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p>按顺序给你一堆训练集（只有类别编号），就是给了一个数组，然后每个类别中，前（类别数据个数）&#x2F;2向上取整为训练集，后面的是测试集，让我们按顺序拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(), m = scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] samples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>            samples[nums[i]-<span class="hljs-number">1</span>]++;<br>        &#125;<br>        <span class="hljs-type">int</span>[] trains = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[] tests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            trains[i] = samples[i]/<span class="hljs-number">2</span>;<br>            tests[i] = samples[i]/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (samples[i] % <span class="hljs-number">2</span> !=<span class="hljs-number">0</span>) &#123;<br>                trains[i]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[nums[i]-<span class="hljs-number">1</span>]++ &lt; trains[nums[i]-<span class="hljs-number">1</span>])<br>                System.out.print(i+<span class="hljs-number">1</span> + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br><br>        cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        System.out.println();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[nums[i]-<span class="hljs-number">1</span>] &lt; trains[nums[i]-<span class="hljs-number">1</span>]) &#123;<br>                cnt[nums[i] - <span class="hljs-number">1</span>]++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[nums[i]-<span class="hljs-number">1</span>] - trains[nums[i]-<span class="hljs-number">1</span>] &lt; tests[nums[i] - <span class="hljs-number">1</span>])&#123;<br>                System.out.print(i+<span class="hljs-number">1</span> + <span class="hljs-string">&quot; &quot;</span>);<br>                cnt[nums[i]-<span class="hljs-number">1</span>]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806105111868.png" alt="image-20220806105111868"></p><h1 id="专项编程题-x3D-x3D-AC-x3D-x3D"><a href="#专项编程题-x3D-x3D-AC-x3D-x3D" class="headerlink" title="专项编程题&#x3D;&#x3D;AC&#x3D;&#x3D;"></a>专项编程题&#x3D;&#x3D;AC&#x3D;&#x3D;</h1><p>初始字符串为MetTuan，每次对字符串做 str &#x3D; str + str.reverse() + “wow”的操作，无限循环。后面给你一个k，问你位置k的字符为什么。</p><p>这一道题就是找规律：</p><p>第一次循环后字符串为：s+s’+“wow”</p><p>第二次循环后字符串为：s+s’+“wow”+“wow”+s+s’+“wow”</p><p>第三次循环后字符串为：s+s’+“wow”+“wow”+s+s’+“wow”+“wow”+s+s’+“wow”+“wow”+s+s’+“wow”</p><p>后续的无限循环字符串基本上都是s+s’+“wow”+“wow”重复出现，所以直接输入数字对这个字符串长度取余，然后取出对应字符输出即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Q5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">T</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MeiTuan&quot;</span>;<br>        str = str + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str).reverse().toString())+<span class="hljs-string">&quot;wowwow&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; T; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> sc.nextLong()-<span class="hljs-number">1</span>;<br>            pos = pos % str.length();<br>            System.out.println(str.charAt((<span class="hljs-type">int</span>)pos));<br>       &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>美团</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>623在二叉树中增加一行</title>
    <link href="/2022/08/05/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/623.%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/"/>
    <url>/2022/08/05/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/623.%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623.在二叉树中增加一行"></a><a href="https://leetcode.cn/problems/add-one-row-to-tree/">623.在二叉树中增加一行</a></h1><p>难度中等184收藏分享切换为英文接收动态反馈</p><p>给定一个二叉树的根 <code>root</code> 和两个整数 <code>val</code> 和 <code>depth</code> ，在给定的深度 <code>depth</code> 处添加一个值为 <code>val</code> 的节点行。</p><p>注意，根节点 <code>root</code> 位于深度 <code>1</code> 。</p><p>加法规则如下:</p><ul><li>给定整数 <code>depth</code>，对于深度为 <code>depth - 1</code> 的每个非空树节点 <code>cur</code> ，创建两个值为 <code>val</code> 的树节点作为 <code>cur</code> 的左子树根和右子树根。</li><li><code>cur</code> 原来的左子树应该是新的左子树根的左子树。</li><li><code>cur</code> 原来的右子树应该是新的右子树根的右子树。</li><li>如果 <code>depth == 1 </code>意味着 <code>depth - 1</code> 根本没有深度，那么创建一个树节点，值 <code>val </code>作为整个原始树的新根，而原始树就是新根的左子树。</li></ul><p><strong>示例 1:</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/addrow-tree.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: root = [<span class="hljs-number">4,2,6,3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], val = <span class="hljs-number">1</span>, depth = <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">4,1,1,2</span>,null,null,<span class="hljs-number">6,3,1,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/add2-tree.jpg" alt="img"></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">输入<span class="hljs-operator">:</span> root <span class="hljs-operator">=</span> [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, depth <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出<span class="hljs-operator">:</span>  [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 104]</code> 范围内</li><li>树的深度在 <code>[1, 104]</code>范围内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>-105 &lt;= val &lt;= 105</code></li><li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二叉树的层序遍历，遍历到对应的层时，添加一个新层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">addOneRow</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newRoot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>            newRoot.left = root;<br>            <span class="hljs-keyword">return</span> newRoot;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size();i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (level == depth - <span class="hljs-number">1</span>) &#123;<br>                    <br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val, temp.left, <span class="hljs-literal">null</span>);<br>                        temp.left = leftNode;<br>                    <br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val, <span class="hljs-literal">null</span>, temp.right);<br>                        temp.right = rightNode;<br>                    <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-literal">null</span>)<br>                        queue.add(temp.left);<br>                    <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-literal">null</span>) <br>                       queue.add(temp.right);<br>                    &#125;<br>                &#125;<br>                level++;<br>            &#125;  <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$-二叉树结点数</li><li>空间复杂度：$O(n)$-二叉树结点数</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220806164907966.png" alt="image-20220806164907966"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>层序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1403非递增顺序的最小至序列</title>
    <link href="/2022/08/04/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1403.%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/08/04/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1403.%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403.非递增顺序的最小子序列"></a><a href="https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/">1403.非递增顺序的最小子序列</a></h1><p>难度简单71收藏分享切换为英文接收动态反馈</p><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p><p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p><p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p><p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,3,10,9,8]</span><br>输出：<span class="hljs-comment">[10,9]</span> <br>解释：子序列 <span class="hljs-comment">[10,9]</span> 和 <span class="hljs-comment">[10,8]</span> 是最小的、满足元素之和大于其他各元素之和的子序列。但是 <span class="hljs-comment">[10,9]</span> 的元素之和最大。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,4,7,6,7]</span><br>输出：<span class="hljs-comment">[7,7,6]</span> <br>解释：子序列 <span class="hljs-comment">[7,7]</span> 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，<span class="hljs-comment">[7,6,7]</span> 是满足题意的最小子序列。注意，元素按非递增顺序返回。  <br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[6]</span><br>输出：<span class="hljs-comment">[6]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将数组进行排序，然后从末尾开始添加元素到数据中，计算添加元素的和以及所有元素的和是否满足要求，如果满足，返回添加的元素，否则，继续添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">minSubsequence</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 求和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>        &#125;<br><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp_sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, idx = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(temp_sum &lt;= sum-temp_sum) &#123;<br>            temp_sum += nums[idx];<br>            ans.add(nums[idx]);<br>            idx--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \log n)$</li><li>空间复杂度：$O(l)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220804133649428.png" alt="image-20220804133649428"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>899有序队列</title>
    <link href="/2022/08/04/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/899.%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    <url>/2022/08/04/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/899.%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="899-有序队列"><a href="#899-有序队列" class="headerlink" title="899.有序队列"></a><a href="https://leetcode.cn/problems/orderly-queue/">899.有序队列</a></h1><p>难度困难157收藏分享切换为英文接收动态反馈</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以从 <code>s</code> 的前 <code>k</code> 个字母中选择一个，并把它加到字符串的末尾。</p><p>返回 <em>在应用上述步骤的任意数量的移动后，字典上最小的字符串</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：s = <span class="hljs-string">&quot;cba&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;acb&quot;</span><br>解释：<br>在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “<span class="hljs-keyword">bac”。</span><br><span class="hljs-keyword"></span>在第二步中，我们将第一个字符（“<span class="hljs-keyword">b”）移动到最后，获得最终结果 </span>“acb”。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;baaca&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;aaabc&quot;</span><br>解释：<br>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。<br>在第二步中，我们将第三个字符（“<span class="hljs-keyword">c</span>”）移动到最后，获得最终结果 “aaabc”。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= S.length &lt;= 1000</code></li><li><code>s</code> 只由小写字母组成。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>可以分为两种情况：</p><ul><li>k&#x3D;1的时候，可能的变化是循环的将第一个字符放在末尾，只可能出现n种字符串，可以直接遍历这些字符串，然后存储最先字典序的字符串即可</li><li>k&gt;1的时候，可以生成任意顺序的字符串，所以可以直接对字符串的字符进行排序，得到字典序最小的字符串返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">orderlyQueue</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> s;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.substring(i) + s.substring(<span class="hljs-number">0</span>, i);<br>                <span class="hljs-keyword">if</span> (t.compareTo(ans) &lt; <span class="hljs-number">0</span>) ans = t;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-type">char</span>[] c = s.toCharArray();<br>        Arrays.sort(c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220804103255451.png"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度2023届北京Java研发工程师面试凉经</title>
    <link href="/2022/08/03/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%99%BE%E5%BA%A62023%E5%B1%8A%E5%8C%97%E4%BA%ACJava%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/"/>
    <url>/2022/08/03/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%99%BE%E5%BA%A62023%E5%B1%8A%E5%8C%97%E4%BA%ACJava%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>记录一下2022年8月1日百度北京Java后端研发工程师的面试，已凉</p><p>面试了接近一个小时，基础知识掌握的太差了，面试官找不到啥深入聊，什么都问了一点，什么都没答上来</p><span id="more"></span><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>聊了下专业背景和课题，课题主要研究的是生物医学相关的，以及为什么想来做Java后端</p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"><a href="#你说你用过python-x2F-C-这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点" class="headerlink" title="你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点"></a>你说你用过python&#x2F;C++这些语言，说一下和Java有什么区别，或者说一下Java有什么缺点</h2><ul><li>Java是面向对象的，比较符合人的认知</li><li>Java和C++都是面向对象的，都支持封装、继承和多态</li><li>Java不是通过指针访问内存的，程序的内存自动通过垃圾回收算法回收</li><li>Java单继承，C++支持多重继承，虽然Java不可以多继承，但是接口可以多继承</li></ul><h2 id="说一下Java的八种基本类型"><a href="#说一下Java的八种基本类型" class="headerlink" title="说一下Java的八种基本类型"></a>说一下Java的八种基本类型</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220801221127384.png" alt="image-20220801221127384"></p><h2 id="讲一下int和Integer的区别"><a href="#讲一下int和Integer的区别" class="headerlink" title="讲一下int和Integer的区别"></a>讲一下int和Integer的区别</h2><ul><li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li><li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li><li>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java 虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素 boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字 节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的 是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</li></ul><h2 id="有了解过Java中ArrayList和LinkedList的区别"><a href="#有了解过Java中ArrayList和LinkedList的区别" class="headerlink" title="有了解过Java中ArrayList和LinkedList的区别"></a>有了解过Java中ArrayList和LinkedList的区别</h2><ul><li>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有 数据, (因为删除数据以后, 需要把后面所有的数据前移)</li><li>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于 ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</li></ul><h2 id="关于Java多线程的synchronized和ThreadLocal有了解过吗"><a href="#关于Java多线程的synchronized和ThreadLocal有了解过吗" class="headerlink" title="关于Java多线程的synchronized和ThreadLocal有了解过吗"></a>关于Java多线程的synchronized和ThreadLocal有了解过吗</h2><p>ThreadLocal<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java多线程同步之ThreadLocal与Synchromized](https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142^v39^pc_rank_v37&spm=1018.2226.3001.4187)">[1]</span></a></sup>和Synchronized都是为了解决多线程中相同变量的访问冲突问题，只是二者处理问题的思路和角度不同。</p><ul><li><p>ThreadLocal是Java类，是通过每个线程单独一份存储空间，牺牲空间来弥补时间来解决多线程访问冲突，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlConnectionUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;SqlConnection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;SqlConnection&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SqlConnection</span> <span class="hljs-variable">initSqlConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            initSqlConnection = DriverManager.getSqlConnection(<span class="hljs-string">&quot;url, name and password&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> SqlConnection <span class="hljs-title function_">getSqlConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SqlConnection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> tl.get();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> == c) tl.set(initSqlConnection);<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Synchronized是Java保留关键字，通过线程等待，牺牲时间来解决访问冲突。依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程的访问变量，此时被用作锁机制的变量被多个线程共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlConnectionUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlPool instance=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SqlConnection <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>            instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPool</span>();<br>        <span class="hljs-keyword">return</span> instance.getSqlConnection();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="说一下你对Java虚拟机的理解"><a href="#说一下你对Java虚拟机的理解" class="headerlink" title="说一下你对Java虚拟机的理解"></a>说一下你对Java虚拟机的理解</h2><h3 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802212445262.png"></p><p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p><ul><li>Java堆（Heap），是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li><li>方法区（Method Area），方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li></ul><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p><ul><li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li><li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、ParallelScavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802213622688.png" alt="image-20220802213622688"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li><li>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<ul><li>优点：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小。</li><li>缺点：浮动垃圾目前使用的非常少，真正普及还是需要写时间的。</li></ul></li></ul><p><strong>新生代收集器</strong>：Serial、ParNew、Parallel Scavenge</p><p><strong>老年代收集器</strong>：CMS、Serial Old、Parallel Old</p><p><strong>整堆收集器</strong>：G1，ZGC(因为不涉年代不在图中)。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="排序算法了解过吗，可以详细介绍一下吗"><a href="#排序算法了解过吗，可以详细介绍一下吗" class="headerlink" title="排序算法了解过吗，可以详细介绍一下吗"></a>排序算法了解过吗，可以详细介绍一下吗</h2><p>了解过一点，例如冒泡排序和选择排序</p><ul><li><p>冒泡排序：每一轮循环都是和相邻的元素比较，然后一步步的将最小的元素或者最大的元素排在前面，时间复杂度是 $O(n^2)$</p></li><li><p>选择排序：每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。每一趟通过不断地比较交换来使得首元素为当前最小，交换是一个比较耗时间的操作，我们可以通过设置一个值来记录较小元素的下标，循环结束后存储的就是当前最小元素的下标，这时再进行交换就可以了。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220802214609664.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[a];<br>arr[a] = arr[b];<br>arr[b] = tmp;<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">SimpleSelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span><br>&#123;<br><span class="hljs-type">int</span> min, len = arr.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len - <span class="hljs-number">1</span>;i++)<br>&#123;<br>min = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;j &lt; len;j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[min] &gt; arr[j])<br>&#123;<br>min = j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (min != i)<br>&#123;<br>Swap(arr,min,i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="写一下反转链表的代码，伪代码即可"><a href="#写一下反转链表的代码，伪代码即可" class="headerlink" title="写一下反转链表的代码，伪代码即可"></a>写一下反转链表的代码，伪代码即可</h2><p>了解的链表反转有两种方法：</p><ul><li>第一种是<strong>递归</strong>，递归的写法是需要明确两个条件：边界条件和递推关系<ul><li>先说一下<strong>递推关系</strong>：假设递归的顺序是先调整后面的结点，当前结点的后续结点都已经反转了，只需要反转当前结点和其后继结点的关系，这时候只需要将当前结点的后继结点的后继指向当前结点，即<code>cur.next.next = cur</code>，然后将当前结点的后继变为<code>null</code>，防止循环链表的出现，然后返回反转之后的头结点</li><li><strong>边界条件</strong>则是递归到最后一个节点，同时加上判断链表头结点是否为空的判断</li></ul></li><li>另一种就是<strong>双指针</strong>，双指针比起递归来说要更好理解一些<ul><li>首先设置两个指针<code>pre, cur</code>，分别表示前一个结点和当前结点</li><li>先设置一个临时变量保存当前结点的后继<code>Node temp = cur.next</code>，然后将当前结点的后继指向前一个结点<code>cur.next = pre</code>，这样实现了后继关系的反转，然后判断下一个，这时候的<code>pre = cur; cur = temp</code></li><li>反转结束之后返回<code>pre</code>为反转后链表的头结点</li></ul></li></ul><p>具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduInterview</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归实现链表反转</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 链表头结点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回反转后链表的头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newroot</span> <span class="hljs-operator">=</span> reverseLinkedList(root.next);<br>        root.next.next = root;<br>        root.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newroot;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseLinkedList2</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.next == <span class="hljs-literal">null</span> || root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过数组构建链表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> head 链表头结点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">constructLinkedList</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(num);<br>            temp.next = <span class="hljs-literal">null</span>;<br>            cur.next = temp;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> constructLinkedList(nums);<br><span class="hljs-comment">//        Node reversed2 = reverseLinkedList(root);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">reversed3</span> <span class="hljs-operator">=</span> reverseLinkedList2(root);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义链表结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">public</span> Node next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79980618)">[5]</span></a></sup>，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:</p><ol><li>每个节点都有红色或黑色</li><li>树的根始终是黑色的 (黑土地孕育黑树根， )</li><li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，<strong>并没有说不能出现连续的黑色节点</strong>）</li><li>从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</li></ol><p>一棵典型的红黑树如下图所示</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803220406437.png" alt="image-20220803220406437"></p><p>关于红黑树的左旋右旋操作过多，后续再来详细记载，可以先查看这篇文章</p><p><a href="https://blog.csdn.net/u014454538/article/details/120120216">红黑树详解_晓之木初的博客-CSDN博客_红黑树</a></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="有了解过Java的设计模式吗，手写一个单例模式"><a href="#有了解过Java的设计模式吗，手写一个单例模式" class="headerlink" title="有了解过Java的设计模式吗，手写一个单例模式"></a>有了解过Java的设计模式吗，手写一个单例模式</h2><p>了解过一些，设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它<br>不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p><p>单例模式、代理模式、模板方法模式、装饰器模式、工厂模式、责任链模式、观察者模式、原型模<br>式。</p><p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。<br>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>单例模式有很多种的写法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[我给面试官讲解了单例模式后，他对我竖起了大拇指！](https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142^v39^pc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187)">[2]</span></a></sup>：</p><ul><li><p><strong>饿汉式单例模式</strong>的写法：线程安全</p><p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创建</strong>。</p><p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803141933702.png" alt="image-20220803141933702"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>懒汉式单例模式</strong>的写法：非线程安全</p><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象。，否则则先执行实例化操作。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803141920683.png" alt="image-20220803141920683"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这个单例模式是较为简单的写法，写完之后，面试官问如果在多线程的任务下，很多线程请求，可能会出现线程不安全的情况，都到达<code>if(singleton == null)</code>，可能会有复数个线程创建了不同的实例</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803142100572.png" alt="image-20220803142100572"></p><p>如何解决这个问题，这个时候需要考虑加锁，也就是下面这个方式</p></li><li><p><strong>双检锁单例模式</strong>的写法：线程安全</p><p>一般在懒汉单例非线程的代码上进行修改有两种简便的方式：一种是给对象加锁，一种是给方法加锁</p><ul><li><p><strong>对象上锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></li><li>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</li></ul></blockquote><p>直接在方法上加锁的方式被废除掉了，这种方式无论如何都需要先获取锁，所以在对象加锁代码的基础上进行优化</p><p>优化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>        <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经完美地解决了并发安全+性能低效问题：</p><ul><li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li><li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li></ul><p>上面这段代码已经近似完美了，但是还存在最后一个问题：<strong>指令重排</strong>，这个时候可以使用<code>volatile</code>防止指令重排</p><p>创建一个对象，在JVM中会经过三步：</p><ul><li><p>为singleton分配内存空间</p></li><li><p>初始化singleton对象</p></li><li><p>将singleton指向分配好的内存空间</p></li></ul><p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p><p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803143240854.png" alt="image-20220803143240854"></p><p>使用volatile关键字可以<strong>防止指令重排序</strong>，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了</p><blockquote><p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p></blockquote><p>最终的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>拓展的方式，<strong>枚举实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是枚举类型的单例模式！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举实现的优点：</p><ul><li>对比饿汉和懒汉式来说，更加简洁</li><li>不需要做任何额外的操作去保证对象单一性与线程安全性</li><li>使用枚举可以防止调用者使用<strong>反射、序列化和反序列化</strong>机制强制生成多个单例对象，以此破坏单例模式</li></ul><blockquote><ul><li>单例模式常见的写法有两种：懒汉式、饿汉式</li><li>懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</li><li>饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</li><li>在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</li><li>如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</li><li>为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加volatile关键字防止指令重排序</li><li>最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</li></ul></blockquote><h2 id="有在项目中用到过这种设计模式吗"><a href="#有在项目中用到过这种设计模式吗" class="headerlink" title="有在项目中用到过这种设计模式吗"></a>有在项目中用到过这种设计模式吗</h2><p>在个人网站的开发过程中，每一个页面设置了一个head-img，使用的是枚举的单例模式实现的，在每一篇文章和每一个页面加载的时候创建图片的实例，并获取实例，为了加速访问数据，还将对应图片的路径&#x2F;链接保存在redis数据库中</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>HTTP<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HTTP 和 HTTPS 的区别（面试常考题）](https://blog.csdn.net/qq_36667170/article/details/121656279)">[3]</span></a></sup>：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p><p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803144740620.png" alt="image-20220803144740620"></p><p>简要概括一下两者的区别就是：</p><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><h2 id="说一下加密算法，即https如何实现加密传输的"><a href="#说一下加密算法，即https如何实现加密传输的" class="headerlink" title="说一下加密算法，即https如何实现加密传输的"></a>说一下加密算法，即https如何实现加密传输的</h2><p>加密方法：SSL采用一种叫作公开秘钥加密的加密处理方式，近代的加密方法中加密算法是公开的，而秘钥是保密的，通过这种方式可以保持加密方法的安全性。</p><p>共享秘钥加密：加密和解密使用同一个秘钥的方式，在加密时必须要将秘钥也发给对方，在互联网转发秘钥时，如果通信被监听那么秘钥就可能会落入攻击者之手，同时也失去了加密的意义。</p><p>使用两把秘钥的公开秘钥加密：公开秘钥加密使用一堆非对称的秘钥，一把叫做私有秘钥，另一把叫做公开秘钥；发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有秘钥进行解密，利用这种方式，不需要发送用来解密的私有秘钥，也不必担心秘钥被攻击者窃听而盗走；但是他的处理速度相对共享秘钥来说很慢。</p><p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p><p>https采用对称加密与非对称加密的混合加密方式</p><p>混合加密方式原理：</p><ol><li>服务端将非对称加密的公钥发送给客户端；</li><li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li><li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li><li>二者利用对称加密的key对需要传输的消息做加解密传输。</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"><a href="#有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗" class="headerlink" title="有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗"></a>有用过数据库吗，例如MySQL，可以讲一下MySQL的索引和他的索引引擎吗</h2><p>官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[一文搞懂MySQL索引所有知识点（建议收藏）](https://blog.csdn.net/qq_35190492/article/details/109257302)">[4]</span></a></sup>。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul><li><p>主键索引：索引列中的值必须是唯一的，不允许有空值</p></li><li><p>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p></li><li><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</p></li><li><p>全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。 MyISAM和InnoDB中都可以使用全文索引。</p></li><li><p>空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p></li><li><p>前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p></li><li><p>其他（按照索引列数量分类）</p><ul><li><p>单列索引</p></li><li><p>组合索引</p><p>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。</p></li></ul></li></ul><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><p>Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803151811292.png" alt="image-20220803151811292"></p><p>每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。</p><p>这个特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这就很难受很不稳定。</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋&#x2F;右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。</p><p>使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。查询id&#x3D;6，只需要两次IO。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803152915087.png" alt="image-20220803152915087"></p><p>就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：</p><p>时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10&#x3D;0.2s）</p><p>平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。</p><h4 id="B树：改造二叉树"><a href="#B树：改造二叉树" class="headerlink" title="B树：改造二叉树"></a>B树：改造二叉树</h4><p>MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。</p><p>为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k&#x2F;16&#x3D;1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000&#x3D;1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。</p><p>这种数据结构我们称为B树，B树是一种多叉平衡查找树，如下图主要特点：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803155515665.png" alt="image-20220803155515665"></p><ol><li>B树的节点中存储着多个元素，每个内节点有多个分叉。</li><li>节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。</li><li>父节点当中的元素不会出现在子节点中。</li><li>所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。</li></ol><p>在B树中查询数据的例子：</p><blockquote><p>假如我们查询值等于10的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。</p><p>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10&lt;15，走左路，到磁盘寻址磁盘块2。</p><p>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;10，到磁盘中寻址定位到磁盘块5。</p><p>第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10&#x3D;10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。</p><p>相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162233851.png" alt="image-20220803162233851"></p><p>虽然B树看来已经很理想了，但是仍然存在许多可以优化的地方：</p><ul><li>B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。</li><li>如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</li></ul></blockquote><h4 id="B-树：改造B树"><a href="#B-树：改造B树" class="headerlink" title="B+树：改造B树"></a>B+树：改造B树</h4><p>B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于<strong>非叶子节点是否存储数据</strong>的问题</p><ul><li>B树：非叶子节点和叶子节点都会存储数据。</li><li>B+树：<strong>只有叶子节点才会存储数据</strong>，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162526549.png" alt="image-20220803162526549"></p><blockquote><p>B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟着增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点</p></blockquote><p><strong>等值查询</strong><br>假如我们查询值等于9的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块6。</p><ul><li>第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，9&lt;15，走左路，到磁盘寻址磁盘块2。</li><li>第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;9&lt;12，到磁盘中寻址定位到磁盘块6。</li><li>第三次磁盘IO：将磁盘块6加载到内存中，在内存中从头遍历比较，在第三个索引中找到9，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。（这里需要区分的是在InnoDB中Data存储的为行数据，而MyIsam中存储的是磁盘地址。）</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162810055.png" alt="image-20220803162810055"></p><p><strong>范围查询</strong></p><p>假如我们想要查找9和26之间的数据。查找路径是磁盘块1-&gt;磁盘块2-&gt;磁盘块6-&gt;磁盘块7。</p><ul><li>首先查找值等于9的数据，将值等于9的数据缓存到结果集。这一步和前面等值查询流程一样，发生了三次磁盘IO。</li><li>查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块6，键值9开始向后遍历筛选所有符合筛选条件的数据。</li><li>第四次磁盘IO：根据磁盘6后继指针到磁盘中寻址定位到磁盘块7，将磁盘7加载到内存中，在内存中从头遍历比较，9&lt;25&lt;26，9&lt;26&lt;&#x3D;26，将data缓存到结果集。</li><li>主键具备唯一性（后面不会有&lt;&#x3D;26的数据），不需再向后查找，查询终止。将结果集返回给用户。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803162902012.png" alt="image-20220803162902012"></p><p><strong>可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构</strong></p><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><h4 id="MyIsam索引"><a href="#MyIsam索引" class="headerlink" title="MyIsam索引"></a>MyIsam索引</h4><p>以一个简单的user表为例。user表存在两个索引，id列为主键索引，age列为普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = MyISAM<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8;<br><br></code></pre></td></tr></table></figure><p>MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。</p><p>主键索引的B+树如下图所示：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803163454024.png" alt="image-20220803163454024"></p><p>表user的索引存储在索引文件<code>user.MYI</code>中，数据文件存储在数据文件 <code>user.MYD</code>中</p><p><strong>主键等值索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 28;<br></code></pre></td></tr></table></figure><ul><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于30的索引项。（1次磁盘IO）</li><li>从索引项中获取磁盘地址，然后到数据文件user.MYD中获取对应整行记录。（1次磁盘IO）</li><li>将记录返给客户端。</li></ul><p><strong>磁盘IO次数：3次索引检索+记录数据检索。</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803164712589.png" alt="image-20220803164712589"></p><p><strong>主键返回查询数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id between 28 and 47;<br></code></pre></td></tr></table></figure><ul><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历比较16&lt;28，18&lt;28，28&#x3D;28&lt;47。查找到值等于28的索引项。</li><li>根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li><li>我们的查询语句时范围查找，需要向后遍历底层叶子链表，直至到达最后一个不满足筛选条件。</li><li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，28&lt;47&#x3D;47，根据磁盘地址从数据文件中获取行记录缓存到结果集中。（1次磁盘IO）</li><li>最后得到两条符合筛选条件，将查询结果集返给客户端。</li></ul><p><strong>磁盘IO次数：4次索引检索+记录数据检索</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165338794.png" alt="image-20220803165338794"></p><blockquote><p>在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。</p><p>查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。</p></blockquote><h4 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h4><p>每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：</p><ul><li>在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。</li><li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li><li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li></ul><p>这里以user_innodb为例，user_innodb的id列为主键，age列为普通索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `user_innodb`<br>(<br>  `id`       int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(20) DEFAULT NULL,<br>  `age`      int(11)     DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_age` (`age`) USING BTREE<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure><p><strong>InnoDB主键索引</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803165717554.png" alt="image-20220803165717554"></p><p><strong>查询等值数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user_innodb where id = 28;<br></code></pre></td></tr></table></figure><ul><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28&#x3D;28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205600971.png" alt="image-20220803205600971"></p><p><strong>辅助索引</strong></p><p>除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。</p><p>以表user_innodb的age列为例，age索引的索引结果如下图</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205628315.png" alt="image-20220803205628315"></p><p>底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。</p><p>使用辅助索引需要<strong>检索两遍索引</strong>：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记录。</p><p><strong>辅助索引等值查询的情况</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where age=19;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803205904722.png" alt="image-20220803205904722"></p><p>根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为<strong>回表</strong>查询。</p><p><strong>磁盘IO数：辅助索引3次+获取记录回表3次</strong></p><p><strong>组合索引</strong></p><p>还是以自己创建的一个表为例：表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `abc_innodb`<br>(<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `a`  int(11)     DEFAULT NULL,<br>  `b`  int(11)     DEFAULT NULL,<br>  `c`  varchar(10) DEFAULT NULL,<br>  `d`  varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE,<br>  KEY `idx_abc` (`a`, `b`, `c`)<br>) ENGINE = InnoDB;<br></code></pre></td></tr></table></figure><p>组合索引的数据结构</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210223424.png" alt="image-20220803210223424"></p><p><strong>组合索引的查询过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from abc_innodb where a = 13 and b = 16 and c = 4;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803210836339.png" alt="image-20220803210836339"></p><p><strong>最左匹配原则</strong></p><p>最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。</p><p>在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。</p><p>就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。</p><p>可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。、</p><p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong></p><p><strong>覆盖索引</strong></p><p>覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。</p><h2 id="可以讲一下如何优化数据库查询吗"><a href="#可以讲一下如何优化数据库查询吗" class="headerlink" title="可以讲一下如何优化数据库查询吗"></a>可以讲一下如何优化数据库查询吗</h2><h3 id="避免回表"><a href="#避免回表" class="headerlink" title="避免回表"></a>避免回表</h3><p>在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？</p><p>使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）</p><p>如果在一个场景下，<code>select id,name,sex from user where name =&#39;zhangsan&#39;;</code>这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。</p><p>这里就是一个典型的使用覆盖索引的优化策略减少回表的情况。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><strong>联合索引</strong>，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。</p><p><strong>联合索引的创建原则</strong>，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。</p><p><strong>联合索引的使用</strong></p><p>考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。<br>当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="看你项目中有用到SpringBoot和Mybatis，可以聊一下Spring的IOC和AOP吗"><a href="#看你项目中有用到SpringBoot和Mybatis，可以聊一下Spring的IOC和AOP吗" class="headerlink" title="看你项目中有用到SpringBoot和Mybatis，可以聊一下Spring的IOC和AOP吗"></a>看你项目中有用到SpringBoot和Mybatis，可以聊一下Spring的IOC和AOP吗</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（面向切面）是一种编程范式，提供从另一个角度来考虑程序结构以完善面向对象编程（OOP）。<br>AOP为开发者提供了一种描述横切关注点的机制，并能够自动将横切关注点织入到面向对象的软件系统中，从而实现了横切关注点的模块化。<br>AOP能够将那些与业务无关，却为业务模块所共同调用的<a href="https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E6%88%96&spm=1001.2101.3001.7020">逻辑或</a>责任，例如事务处理、日志管理、权限控制等，封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><p><strong>使用AOP的好处</strong></p><ul><li>降低模块的耦合度</li><li>使系统容易扩展</li><li>提高代码复用性</li></ul><p><strong>AOP的基本概念</strong></p><ul><li>连接点（JoinPoint）：需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点。</li><li>切入点（Pointcut）：一组相关连接点的集合。</li><li>通知（Advice）：在连接点上执行的行为，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置增强（before advice）、后置增强 (after advice)、环绕增强 （around advice）。</li><li>切面（Aspect）：通知和切入点的结合。</li><li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</li><li>代理（Proxy）：通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</li><li>目标对象（Target）：需要被织入关注点的对象。即被代理的对象。</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803214934226.png" alt="image-20220803214934226"></p><p>实现AOP的主要设计模式就是动态代理。</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（控制反转）就是依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。<br>Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是<strong>工厂模式</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803215056912.png" alt="image-20220803215056912"></p><p><strong>使用IOC的好处</strong></p><ul><li>集中管理，实现类的可配置和易管理。</li><li>降低了类与类之间的耦合度</li></ul><h1 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h1><h2 id="在百度的业务中，爬取了大量的页面，这些页面无法全部放在内存中，如何优化查找"><a href="#在百度的业务中，爬取了大量的页面，这些页面无法全部放在内存中，如何优化查找" class="headerlink" title="在百度的业务中，爬取了大量的页面，这些页面无法全部放在内存中，如何优化查找"></a>在百度的业务中，爬取了大量的页面，这些页面无法全部放在内存中，如何优化查找</h2><p>在面试的时候，只能想到哈希映射或者二叉树索引之类的，或者是数据库索引的B+树的实现方式</p><p>面试官最后介绍了一种布隆过滤器算法（站在布隆后面&amp;心脏是最强壮的肌肉）</p><h3 id="布隆过滤器算法"><a href="#布隆过滤器算法" class="headerlink" title="布隆过滤器算法"></a>布隆过滤器算法</h3><p>布隆过滤器（Bloom Filter）<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/94433082)">[6]</span></a></sup>是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。</p><p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p><p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p><p>根据定义，布隆过滤器可以检查值是 <strong>“可能在集合中”</strong> 还是 <strong>“绝对不在集合中”</strong>。“可能” 表示有一定的概率，也就是说可能存在一定为误判率。那为什么会存在误判呢？下面我们来分析一下具体的原因。</p><p>布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，如下图所示。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221423444.png" alt="image-20220803221423444"></p><p>为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。在前面所提到的哈希表中，我们使用的是单个哈希函数，因此只能输出单个索引值。而对于布隆过滤器来说，我们将使用多个哈希函数，这将会产生多个索引值。</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221528106.png" alt="image-20220803221528106"></p><p>如上图所示，当输入 “semlinker” 时，预设的 3 个哈希函数将输出 2、4、6，我们把相应位置 1。假设另一个输入 ”kakuqo“，哈希函数输出 3、4 和 7。你可能已经注意到，索引位 4 已经被先前的 “semlinker” 标记了。此时，我们已经使用 “semlinker” 和 ”kakuqo“ 两个输入值，填充了位向量。当前位向量的标记状态为：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221601391.png" alt="image-20220803221601391"></p><p>当对值进行搜索时，与哈希表类似，我们将使用 3 个哈希函数对 ”搜索的值“ 进行哈希运算，并查看其生成的索引值。假设，当我们搜索 ”fullstack“ 时，3 个哈希函数输出的 3 个索引值分别是 2、3 和 7：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803221742464.png" alt="image-20220803221742464"></p><p>从上图可以看出，相应的索引位都被置为 1，这意味着我们可以说 ”fullstack“ 可能已经插入到集合中。事实上这是误报的情形，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。幸运的是，布隆过滤器有一个可预测的误判率（FPP）：<br>$$<br>P_{fpp} \approx (1-e^{-\frac{kn}{m}})^k<br>$$</p><ul><li>n 是已经添加元素的数量；</li><li>k 哈希的次数；</li><li>m 布隆过滤器的长度（如比特数组的大小）；</li></ul><p><strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在实际工作中，布隆过滤器常见的应用场景如下：</p><ul><li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li><li>Google Chrome 使用布隆过滤器识别恶意 URL；</li><li>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</li><li>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。 除了上述的应用场景之外，布隆过滤器还有一个应用场景就是解决缓存穿透的问题。所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。</li></ul><p>利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>可以创建一个Maven项目，在pom文件中引入以下坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.0-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后创建一个测试代码，初始化一百万条数据到过滤器中，然后在原有的基础上增加一万条数据，并且判断这些数据是否存在布隆过滤器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Charsets;<br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 总数量</span><br>        BloomFilter&lt;CharSequence&gt; bf = <br>          BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total);<br>        <span class="hljs-comment">// 初始化 1000000 条数据到过滤器中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total; i++) &#123;<br>            bf.put(<span class="hljs-string">&quot;&quot;</span> + i);<br>        &#125;<br>        <span class="hljs-comment">// 判断值是否存在过滤器中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total + <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bf.mightContain(<span class="hljs-string">&quot;&quot;</span> + i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;已匹配数量 &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">已匹配数量 <span class="hljs-number">1000309</span><br></code></pre></td></tr></table></figure><p>上述结果出现了五宝，误报率比预期多了309个元素<br>$$<br>\frac{309}{1000000+10000} \times 100% \approx 3.059%<br>$$</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/u012675150/article/details/104109509?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84synchronized%E5%92%8Cthreadloc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104109509.142%5Ev39%5Epc_rank_v37&spm=1018.2226.3001.4187">Java多线程同步之ThreadLocal与Synchromized</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165950992516781667817752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165950992516781667817752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v37-1-107296517-null-null.142%5Ev39%5Epc_rank_v37&utm_term=java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%E9%9D%A2%E8%AF%95%E5%AE%98%E7%AB%96%E8%B5%B7%E5%A4%A7%E6%8B%87%E6%8C%87&spm=1018.2226.3001.4187">我给面试官讲解了单例模式后，他对我竖起了大拇指！</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/qq_36667170/article/details/121656279">HTTP 和 HTTPS 的区别（面试常考题）</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/qq_35190492/article/details/109257302">一文搞懂MySQL索引所有知识点（建议收藏）</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/79980618">红黑树，超强动静图详解，简单易懂 - 知乎 (zhihu.com)</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/94433082">5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - 知乎 (zhihu.com)</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>百度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用友2023届秋招Java笔试-S2卷</title>
    <link href="/2022/08/03/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%8F%8B2023%E5%B1%8A%E7%A7%8B%E6%8B%9BJava%E7%AC%94%E8%AF%95-S2%E5%8D%B7/"/>
    <url>/2022/08/03/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%8F%8B2023%E5%B1%8A%E7%A7%8B%E6%8B%9BJava%E7%AC%94%E8%AF%95-S2%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<p>用友的笔试题，几道选择题，包括行测、逻辑推理、数学和计算机相关的知识，编程题两道，难度简单</p><span id="more"></span><h1 id="用友2023届秋招Java笔试-S2卷"><a href="#用友2023届秋招Java笔试-S2卷" class="headerlink" title="用友2023届秋招Java笔试-S2卷"></a>用友2023届秋招Java笔试-S2卷</h1><p>其他的选择和多选不允许跳出</p><p>另外还有一道关于数据库查询的题：</p><p>有两个表，一个学生表，一个成绩表包含学生各个科目的成绩，学生表根据学生id和成绩表关联，要求的是通过两个表联查，得到每个学生的总成绩，并根据总成绩得到学生的评级，分为A、B、C、D、E</p><p>需要用到</p><ul><li>多表联查</li><li>分组函数求和</li><li>case when then else end语句</li><li>order by</li></ul><p>等</p><p>好像评测系统用的是mysql5.X的版本，在自己电脑数据库查询语句没有问题，不知道为什么复制到评测系统出现一些bug，没有时间改这个bug了，直接跳过了</p><h1 id="编程题一"><a href="#编程题一" class="headerlink" title="编程题一"></a>编程题一</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803200010103.png" alt="image-20220803200010103"></p><p><strong>题解</strong></p><p>这道题的解决方式暂时只能想到通过<code>HashMap</code>映射对应字符的按键以及按键次数，在初始化的时候初始化一个<code>HashMap</code>，其中<code>key</code>是对应的字符，<code>value</code>是一个两位的整型数字，十位表示的是哪个按键，个位表示按键次数</p><p>这样直接遍历要处理的字符串，得到对应的按键和按键次数，累加每个按键的次数</p><p>为了去除没有按键的结果，将有按键的结果存放在<code>ArrayList</code>中，然后再将其转换为<code>int[][]</code>数组返回即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> String[] keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;@!./&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    <span class="hljs-keyword">static</span> Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-type">char</span>[] chars = keys[i-<span class="hljs-number">1</span>].toCharArray();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; chars.length; j++) &#123;<br>                map.put(chars[j], i*<span class="hljs-number">10</span>+j+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 数字键按从小到大输出</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str string字符串 包含英文26个字母和@!./标点符号的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型二维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] count (String str) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;chars.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> map.get(chars[i]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> temp/<span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> temp%<span class="hljs-number">10</span>;<br>            res[key] += cnt;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">int</span>[]&gt; res2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (res[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, res[i]&#125;;<br>                res2.add(temp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res2.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res2.size(); i++) &#123;<br>            ans2[i][<span class="hljs-number">0</span>] = res2.get(i)[<span class="hljs-number">0</span>];<br>            ans2[i][<span class="hljs-number">1</span>] = res2.get(i)[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过全部测试案例，AC成功</p><h1 id="编程题二"><a href="#编程题二" class="headerlink" title="编程题二"></a>编程题二</h1><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/interview/image-20220803200121842.png" alt="image-20220803200121842"></p><p>这道题是典型的双指针，虽然说是双指针，但是感觉也像是暴力循环和模拟了</p><p>假设城管目前处于第 i 栋楼，那么他可以看到的楼顶除了当前第 i 栋楼，尽可能有两种情况：</p><ul><li><p>向前看，也就是(0, i-1)，从第 i-1 栋楼开始，设置指针 left 指向向前看的楼，设置一个之前最高楼层的高度 leftmax，初始为0</p><ul><li>如果当前楼高度大于 leftmax，说明该栋楼在城管可见，计数加1，并更行 leftmax 为当前楼高度</li><li>如果当前楼高度小于等于leftmax，说明不可见，跳过该楼层到一下层楼</li></ul><p>向前看则表示<code>left--</code></p></li><li><p>向后看和向前看基本类似，同样设置一个向后看的指针 right，向后看之前最高楼层的高度 rightmax，初始也为零，不过向后看是 <code>right++</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 采用单调递减栈，栈顶元素最小，因为前面楼层低，不会挡住后面；前面高，才会挡住后面，栈顶是最接近当前位置的楼，所以要最小，代表此时栈顶所在位置向某一方向能看到其它楼的楼顶。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> heights int整型一维数组 n座楼的楼层高度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findBuilding (<span class="hljs-type">int</span>[] heights) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(ans, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i-<span class="hljs-number">1</span>, right = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftmax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightmax = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (heights[left] &gt; leftmax) &#123;<br>                    leftmax = heights[left];<br>                    ans[i]++;<br>                &#125;<br>                left--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (heights[right] &gt; rightmax) &#123;<br>                    rightmax = heights[right];<br>                    ans[i]++;<br>                &#125;<br>                right++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过所有测试案例，AC成功</p>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
      <tag>用友</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>622设计循环队列</title>
    <link href="/2022/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/633.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/633.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622.设计循环队列"></a><a href="https://leetcode.cn/problems/design-circular-queue/">622.设计循环队列</a></h1><p>难度中等359收藏分享切换为英文接收动态反馈</p><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><ul><li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code>isEmpty()</code>: 检查循环队列是否为空。</li><li><code>isFull()</code>: 检查循环队列是否已满。</li></ul><p><strong>示例：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">MyCircularQueue circularQueue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyCircularQueue(3)</span>; <span class="hljs-comment">// 设置长度为 3</span><br>circularQueue.en<span class="hljs-constructor">Queue(1)</span>;  <span class="hljs-comment">// 返回 true</span><br>circularQueue.en<span class="hljs-constructor">Queue(2)</span>;  <span class="hljs-comment">// 返回 true</span><br>circularQueue.en<span class="hljs-constructor">Queue(3)</span>;  <span class="hljs-comment">// 返回 true</span><br>circularQueue.en<span class="hljs-constructor">Queue(4)</span>;  <span class="hljs-comment">// 返回 false，队列已满</span><br>circularQueue.<span class="hljs-constructor">Rear()</span>;  <span class="hljs-comment">// 返回 3</span><br>circularQueue.is<span class="hljs-constructor">Full()</span>;  <span class="hljs-comment">// 返回 true</span><br>circularQueue.de<span class="hljs-constructor">Queue()</span>;  <span class="hljs-comment">// 返回 true</span><br>circularQueue.en<span class="hljs-constructor">Queue(4)</span>;  <span class="hljs-comment">// 返回 true</span><br>circularQueue.<span class="hljs-constructor">Rear()</span>;  <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有的值都在 0 至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>经典的循环队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] elements;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        capacity = k + <span class="hljs-number">1</span>;<br>        elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>        rear = front = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        elements[rear] = value;<br>        rear = (rear+<span class="hljs-number">1</span>) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        front = (front + <span class="hljs-number">1</span>) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> elements[front];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Rear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> elements[(rear - <span class="hljs-number">1</span> + capacity) %capacity];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rear == front;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ((rear + <span class="hljs-number">1</span>) % capacity == front);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCircularQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span><br><span class="hljs-comment"> * boolean param_1 = obj.enQueue(value);</span><br><span class="hljs-comment"> * boolean param_2 = obj.deQueue();</span><br><span class="hljs-comment"> * int param_3 = obj.Front();</span><br><span class="hljs-comment"> * int param_4 = obj.Rear();</span><br><span class="hljs-comment"> * boolean param_5 = obj.isEmpty();</span><br><span class="hljs-comment"> * boolean param_6 = obj.isFull();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220802170554362.png" alt="image-20220802170554362"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>设计</tag>
      
      <tag>数组</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1374生成每种字符串都是奇数个的字符串</title>
    <link href="/2022/08/01/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1374.%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/08/01/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1374.%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1374-生成每种字符都是奇数个的字符串"><a href="#1374-生成每种字符都是奇数个的字符串" class="headerlink" title="1374.生成每种字符都是奇数个的字符串"></a><a href="https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/">1374.生成每种字符都是奇数个的字符串</a></h1><p>难度简单59收藏分享切换为英文接收动态反馈</p><p>给你一个整数 <code>n</code>，请你返回一个含 <em><code>n</code></em> 个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> <em><strong>。</strong></em></p><p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：n = <span class="hljs-number">4</span><br>输出：<span class="hljs-string">&quot;pppz&quot;</span><br>解释：<span class="hljs-string">&quot;pppz&quot;</span> 是一个满足题目要求的字符串，因为 &#x27;p&#x27; 出现 <span class="hljs-number">3</span> 次，且 &#x27;z&#x27; 出现 <span class="hljs-number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="hljs-string">&quot;ohhh&quot;</span> 和 <span class="hljs-string">&quot;love&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;xy&quot;</span><br>解释：<span class="hljs-string">&quot;xy&quot;</span> 是一个满足题目要求的字符串，因为 &#x27;x&#x27; 和 &#x27;y&#x27; 各出现 <span class="hljs-number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="hljs-string">&quot;ag&quot;</span> 和 <span class="hljs-string">&quot;ur&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">7</span><br>输出：<span class="hljs-string">&quot;holasss&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 500</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>$n$ 为奇数时，返回 $n$ 个 <code>a</code> 组成的字符串</li><li>$n$ 为偶数时，返回 $n-1$ 个 <code>a</code> 和一个<code>b</code> 组成的字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">generateTheString</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&quot;a&quot;</span>.repeat(n)).toString();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&quot;a&quot;</span>.repeat(n-<span class="hljs-number">1</span>)).append(<span class="hljs-string">&quot;b&quot;</span>).toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220801215504239.png" alt="image-20220801215504239"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1161.最大层内元素和</title>
    <link href="/2022/07/31/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1161.%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/"/>
    <url>/2022/07/31/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1161.%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1161-最大层内元素和"><a href="#1161-最大层内元素和" class="headerlink" title="1161. 最大层内元素和"></a><a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/">1161. 最大层内元素和</a></h1><p>难度中等84收藏分享切换为英文接收动态反馈</p><p>给你一个二叉树的根节点 <code>root</code>。设根节点位于二叉树的第 <code>1</code> 层，而根节点的子节点位于第 <code>2</code> 层，依此类推。</p><p>请返回层内元素之和 <strong>最大</strong> 的那几层（可能只有一层）的层号，并返回其中 <strong>最小</strong> 的那个。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/capture.jpeg" alt="img"></strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,7,0,7,-8,null,null]<br>输出：2<br>解释：<br>第<span class="hljs-number"> 1 </span>层各元素之和为 1，<br>第<span class="hljs-number"> 2 </span>层各元素之和为<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 0 </span>= 7，<br>第<span class="hljs-number"> 3 </span>层各元素之和为<span class="hljs-number"> 7 </span>+ -8 = -1，<br>所以我们返回第<span class="hljs-number"> 2 </span>层的层号，它的层内元素之和最大。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">989</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">10250</span>,<span class="hljs-number">98693</span>,-<span class="hljs-number">89388</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,-<span class="hljs-number">32127</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在 <code>[1, 104]</code>范围内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二叉树的层序遍历的变形，注意遍历一层的时候可以首先获取队列的长度，然后递减指针，这样就可以遍历所有上一层的结点</p><p>遍历每一层的时候，累加该层的结点的值，保留最大的和以及对应的层数</p><p>最后返回最大的层数集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxLevelSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_sum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, max_level = <span class="hljs-number">0</span>, current_level = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp_sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp_sum += temp.val;<br>                <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-literal">null</span>) queue.add(temp.left);<br>                <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-literal">null</span>) queue.add(temp.right);<br>            &#125;<br>            current_level++;<br>            <span class="hljs-keyword">if</span> (temp_sum &gt; max_sum) &#123;<br>                max_sum = temp_sum;<br>                max_level = current_level;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$ 二叉树结点数</li><li>空间复杂度：$O(n)$ 二叉树结点数</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220731173509827.png" alt="image-20220731173509827"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>952按公因数计算最大组件大小</title>
    <link href="/2022/07/30/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/952.%E6%8C%89%E5%85%AC%E5%9B%A0%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%A4%A7%E5%B0%8F/"/>
    <url>/2022/07/30/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/952.%E6%8C%89%E5%85%AC%E5%9B%A0%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%A4%A7%E5%B0%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="952-按公因数计算最大组件大小"><a href="#952-按公因数计算最大组件大小" class="headerlink" title="952. 按公因数计算最大组件大小"></a><a href="https://leetcode.cn/problems/largest-component-size-by-common-factor/">952. 按公因数计算最大组件大小</a></h1><p>难度困难133</p><p>给定一个由不同正整数的组成的非空数组 <code>nums</code> ，考虑下面的图：</p><ul><li>有 <code>nums.length</code> 个节点，按从 <code>nums[0]</code> 到 <code>nums[nums.length - 1]</code> 标记；</li><li>只有当 <code>nums[i]</code> 和 <code>nums[j]</code> 共用一个大于 1 的公因数时，<code>nums[i]</code> 和 <code>nums[j]</code>之间才有一条边。</li></ul><p>返回 <em>图中最大连通组件的大小</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/ex1.png" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,6,15,35]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/ex2.png" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[20,50,9,63]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/ex3.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">2,3,6,7</span>,<span class="hljs-number">4,12,21,39</span>]<br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>nums</code> 中所有值都 <strong>不同</strong></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>枚举质因数，并查集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">20010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], sz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (find(a) == find(b)) <span class="hljs-keyword">return</span> ;<br>        sz[find(a)] += sz[find(b)];<br>        p[find(b)] = p[find(a)];<br>        ans = Math.max(ans, sz[find(a)]);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestComponentSize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; j * j &lt;= cur; j++) &#123;<br>                <span class="hljs-keyword">if</span> (cur % j == <span class="hljs-number">0</span>) add(map, j, i);<br>                <span class="hljs-keyword">while</span> (cur % j == <span class="hljs-number">0</span>) cur /= j;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur &gt; <span class="hljs-number">1</span>) add(map, cur, i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            p[i] = i; sz[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>            List&lt;Integer&gt; list = map.get(key);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; list.size(); i++) union(list.get(<span class="hljs-number">0</span>), list.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Map&lt;Integer, List&lt;Integer&gt;&gt; map, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>        List&lt;Integer&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        list.add(val);<br>        map.put(key, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n\sqrt{M})$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220730222257702.png" alt="image-20220730222257702"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数学</tag>
      
      <tag>并查集</tag>
      
      <tag>公因子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>593.有效的正方形</title>
    <link href="/2022/07/29/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/593.%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/07/29/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/593.%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="593-有效的正方形"><a href="#593-有效的正方形" class="headerlink" title="593.有效的正方形"></a><a href="https://leetcode.cn/problems/valid-square/">593.有效的正方形</a></h1><p>难度中等131</p><p>给定2D空间中四个点的坐标 <code>p1</code>, <code>p2</code>, <code>p3</code> 和 <code>p4</code>，如果这四个点构成一个正方形，则返回 <code>true</code> 。</p><p>点的坐标 <code>pi</code> 表示为 <code>[xi, yi]</code> 。输入 <strong>不是</strong> 按任何顺序给出的。</p><p>一个 <strong>有效的正方形</strong> 有四条等边和四个等角(90度角)。</p><p><strong>示例 1:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入: <span class="hljs-built_in">p1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-built_in">p2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-built_in">p3</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], <span class="hljs-built_in">p4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出: True<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">p1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-built_in">p2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-built_in">p3</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], <span class="hljs-built_in">p4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">12</span>]<br>输出：false<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">p1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], <span class="hljs-built_in">p2</span> = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], <span class="hljs-built_in">p3</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], <span class="hljs-built_in">p4</span> = [<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>p1.length == p2.length == p3.length == p4.length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>四个点两两组合有6中组合，也就是可以通过四个点得到六条线段的长度，计算得到六条线段的长度，按从小到大排序，则如果是正方形，则有，前四条线段长度相等，后两条线段长度相等，即四边长相等，对象线相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validSquare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2, <span class="hljs-type">int</span>[] p3, <span class="hljs-type">int</span>[] p4)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] &amp;&amp; p1[<span class="hljs-number">1</span>] == p2[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span>[] l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">6</span>];<br>        l[<span class="hljs-number">0</span>] = distance(p1, p2);<br>        l[<span class="hljs-number">1</span>] = distance(p1, p3);<br>        l[<span class="hljs-number">2</span>] = distance(p1, p4);<br>        l[<span class="hljs-number">3</span>] = distance(p2, p3);<br>        l[<span class="hljs-number">4</span>] = distance(p2, p4);<br>        l[<span class="hljs-number">5</span>] = distance(p3, p4);<br>        Arrays.sort(l);<br>        <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>] == l[<span class="hljs-number">1</span>] &amp;&amp; l[<span class="hljs-number">0</span>] == l[<span class="hljs-number">2</span>] &amp;&amp; l[<span class="hljs-number">0</span>] == l[<span class="hljs-number">3</span>] &amp;&amp; l[<span class="hljs-number">0</span>] == l[<span class="hljs-number">3</span>] &amp;&amp; l[<span class="hljs-number">4</span>] == l[<span class="hljs-number">5</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) (p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) * (p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) + (<span class="hljs-type">long</span>) (p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]) * (p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(l)$</li><li>空间复杂度：$O(l)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220729125016703.png" alt="image-20220729125016703"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数学</tag>
      
      <tag>几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中望龙腾提前批7-28</title>
    <link href="/2022/07/28/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E4%B8%AD%E6%9C%9B%E9%BE%99%E8%85%BE%E6%8F%90%E5%89%8D%E6%89%B97-28/"/>
    <url>/2022/07/28/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E4%B8%AD%E6%9C%9B%E9%BE%99%E8%85%BE%E6%8F%90%E5%89%8D%E6%89%B97-28/</url>
    
    <content type="html"><![CDATA[<p>中望龙腾的笔试题，做出来两道，另外一道实在是不会了</p><span id="more"></span><h1 id="选择多选题"><a href="#选择多选题" class="headerlink" title="选择多选题"></a>选择多选题</h1><ul><li>java类相关知识</li><li>static块</li><li>抽象类和接口</li><li>面向对象特点</li><li>多线程ThreadLocal</li><li>JVM常量池</li><li>IP字段计算</li></ul><p>唉，这些东西，背了又忘，忘了又背，背了还忘</p><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728132608431.png" alt="image-20220728132608431"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>直接遍历获取主对角线和副对角线元素的和</li><li>然后如果矩阵为奇数方阵，需要减去重复的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> mat int整型二维数组</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diagonalSum</span> <span class="hljs-params">(<span class="hljs-type">int</span>[][] mat)</span> &#123;<br>            <span class="hljs-comment">// write code here</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat.length;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                res += mat[i][i] + mat[n-<span class="hljs-number">1</span>-i][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>                res -= mat[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728133014404.png" alt="image-20220728133014404"></p><h2 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728133053946.png" alt="image-20220728133053946"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728133105299.png" alt="image-20220728133105299"></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这道题其实还挺常见的，特别是在游戏相关的岗位面试，结果我这菜鸡还是第一次遇到，直接蒙了…</p><p>现在下来想的话，有以下几种方法判断点是否在三角形内部：</p><ul><li>三角形内角和为360度，也就是点和三角形任意两边组成一个角，这三个角的和为360度，但是浮点数计算存在误差，无法严格等于360度，该方法舍弃</li><li>三角形面积和，同样也是上一种方法，三角形内的点和三个顶点分别做直线，连接划分三个三角形，这三个三角形的面积和同原三角形面积相等，同样也存在浮点数计算误差的问题</li><li>第三种方法就是叉乘法，这一种方法比较适用，不会因为浮点数计算误差出现结果混淆的情况</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728142659982.png" alt="image-20220728142659982"></p><p>如上图所示，三角形的各个边的向量方向是逆时针方向，计算边和三角形内点o的叉乘，例如<br>$$<br>\overrightarrow{CO} \times \overrightarrow{CA}<br>$$<br>如果点在三角形内部，按照叉乘的计算方式，上式的结果为正数，这就是叉乘判断的原理</p><p>但是在题目中，可能存在给的三角形顶点的顺序不是逆时针的顺序，所以需要进行判断</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728143834067.png" alt="image-20220728143834067"></p><p>同样的也是判断叉乘公式<br>$$<br>\overrightarrow{p_1 p_2} \times \overrightarrow{p_1 p_3}<br>$$<br>如果为正数，则说明为逆时针方向，否则，调换 $p2, p3$ 的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-title function_">product</span><span class="hljs-params">(<span class="hljs-type">double</span> p1,<span class="hljs-type">double</span> p2,<span class="hljs-type">double</span> p3)</span> &#123;<br>    <span class="hljs-comment">//首先根据坐标计算p1p2和p1p3的向量，然后再计算叉乘</span><br>    <span class="hljs-keyword">return</span> (p2[<span class="hljs-number">0</span>]-p1[<span class="hljs-number">0</span>])*(p3[<span class="hljs-number">1</span>]-p1[<span class="hljs-number">0</span>]) - (p2[<span class="hljs-number">1</span>]-p1[<span class="hljs-number">1</span>])*(p3[<span class="hljs-number">0</span>]-p1[<span class="hljs-number">0</span>]);<br>&#125;<br>bool <span class="hljs-title function_">isInTriangle</span><span class="hljs-params">(<span class="hljs-type">double</span> p1,<span class="hljs-type">double</span> p2, <span class="hljs-type">double</span> p3, <span class="hljs-type">double</span> o)</span> &#123;<br>    <span class="hljs-comment">//保证p1，p2，p3是逆时针顺序</span><br>    <span class="hljs-keyword">if</span>(product(p1, p2, p3)&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> isInTriangle(p1,p3,p2,o);<br>    <span class="hljs-keyword">if</span>(product(p1, p2, o)&gt;<span class="hljs-number">0</span> &amp;&amp; product(p2, p3, o)&gt;<span class="hljs-number">0</span> &amp;&amp; product(p3, p1, o)&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728140707145.png" alt="image-20220728140707145"></p><h2 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728140720631.png" alt="image-20220728140720631"></p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>这道题和 <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091.二进制矩阵中的最短路径</a> 不能说不像，只能说是一摸一样，唉，做了的题没做出来，太菜了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length, m = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 起点或终点不连通，直接返回-1</span><br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][m];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-type">int</span>[] start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        queue.add(start);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] temp = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span> (temp[<span class="hljs-number">0</span>] == n-<span class="hljs-number">1</span> &amp;&amp; temp[<span class="hljs-number">1</span>] == m-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> weight;<br>                <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == <span class="hljs-number">0</span> &amp;&amp; !visited[x][y]) &#123;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, temp[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>&#125;);<br>                    visited[x][y] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1331数组序号转换</title>
    <link href="/2022/07/28/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1331.%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/07/28/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1331.%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="1331-数组序号转换"><a href="#1331-数组序号转换" class="headerlink" title="1331. 数组序号转换"></a><a href="https://leetcode.cn/problems/rank-transform-of-an-array/">1331. 数组序号转换</a></h1><p>难度简单85</p><p>给你一个整数数组 <code>arr</code> ，请你将数组中的每个元素替换为它们排序后的序号。</p><p>序号代表了一个元素有多大。序号编号的规则如下：</p><ul><li>序号从 1 开始编号。</li><li>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。</li><li>每个数字的序号都应该尽可能地小。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [40,10,20,30]<br>输出：[4,1,2,3]<br>解释：40 是最大的元素。<span class="hljs-number"> 10 </span>是最小的元素。<span class="hljs-number"> 20 </span>是第二小的数字。<span class="hljs-number"> 30 </span>是第三小的数字。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[100,100,100]</span><br>输出：<span class="hljs-comment">[1,1,1]</span><br>解释：所有元素有相同的序号。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">37,12,28,9</span>,<span class="hljs-number">100,56,80,5</span>,<span class="hljs-number">12</span>]<br>输出：[<span class="hljs-number">5,3,4,2</span>,<span class="hljs-number">8,6,7,1</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= arr.length &lt;= 105</code></li><li><code>-109 &lt;= arr[i] &lt;= 109</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>首先使用克隆 <code>clone</code> 复制原数组</li><li>对克隆的数组进行排序</li><li>遍历排序后的克隆数组，将对应元素的值作为键，顺序作为值放进哈希表<code>HashMap</code>中</li><li>然后遍历原数组，在哈希表<code>HashMap</code>中查找对应的元素，将顺序放在另一个数组中，返回该数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] arrayRankTransform(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span>[] clone = arr.clone();<br>        Arrays.sort(clone);<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idex</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, n = arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(!map.containsKey(clone[i]))<br>                map.put(clone[i], idex++);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res[i] = map.get(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n\log n)$ ，其中排序花费 $O(n \times \log n)$ 时间</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220728124736213.png" alt="image-20220728124736213"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>排序</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-最大公约数计算</title>
    <link href="/2022/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>辗转相除法是求最大公约数的一种方法。它的具体做法是：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。这个和更相减损术有着异曲同工之处</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>对于两个数 $(a, b)$，如果有最大公约数 $g$，那么 $(kb+a, b)$ 同样有最大公约数 $g$</p><p>因为对于 $(kb+a, b)$ ，同样也有</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220727101522543.png" alt="image-20220727101522543"></p><p>所以求公约数可以通过上述的公式迭代进行，迭代的时候是两数相互取余</p><p>java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> a % b;<br>        <span class="hljs-keyword">while</span>(remainder != <span class="hljs-number">0</span>) &#123;<br>            a = b;<br>            b = remainder;<br>            remainder = a % b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数学</tag>
      
      <tag>最大公约数</tag>
      
      <tag>辗转相除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>592.分数相减运算</title>
    <link href="/2022/07/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/592.%E5%88%86%E6%95%B0%E7%9B%B8%E5%87%8F%E8%BF%90%E7%AE%97/"/>
    <url>/2022/07/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/592.%E5%88%86%E6%95%B0%E7%9B%B8%E5%87%8F%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="592-分数加减运算"><a href="#592-分数加减运算" class="headerlink" title="592.分数加减运算"></a><a href="https://leetcode.cn/problems/fraction-addition-and-subtraction/">592.分数加减运算</a></h1><p>难度中等76</p><p>给定一个表示分数加减运算的字符串 <code>expression</code> ，你需要返回一个字符串形式的计算结果。 </p><p>这个结果应该是不可约分的分数，即<a href="https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0">最简分数</a>。 如果最终结果是一个整数，例如 <code>2</code>，你需要将它转换成分数形式，其分母为 <code>1</code>。所以在上述例子中, <code>2</code> 应该被转换为 <code>2/1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入: <span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;-1/2+1/2&quot;</span><br>输出: <span class="hljs-string">&quot;0/1&quot;</span><br></code></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入: <span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;-1/2+1/2+1/3&quot;</span><br>输出: <span class="hljs-string">&quot;1/3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入: <span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;1/3-1/2&quot;</span><br>输出: <span class="hljs-string">&quot;-1/6&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>输入和输出字符串只包含 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code> 的数字，以及 <code>&#39;/&#39;</code>, <code>&#39;+&#39;</code> 和 <code>&#39;-&#39;</code>。 </li><li>输入和输出分数格式均为 <code>±分子/分母</code>。如果输入的第一个分数或者输出的分数是正数，则 <code>&#39;+&#39;</code> 会被省略掉。</li><li>输入只包含合法的<strong>最简分数</strong>，每个分数的<strong>分子</strong>与<strong>分母</strong>的范围是 [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。</li><li>输入的分数个数范围是 [1,10]。</li><li><strong>最终结果</strong>的分子与分母保证是 32 位整数范围内的有效整数。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>主要的还是字符串处理有些麻烦，一些相关的API记不住，分子分母的计算方法可以直接采用数学的模拟来实现</p><ul><li><p>分数相加<br>$$<br>\frac{x_1 \times y_2 + x_2 \times y_1}{y_1 \times y_2}<br>$$</p></li><li><p>化简则是分子分母除以两者的公约数，公约数的计算可以使用辗转相除法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fractionAddition</span><span class="hljs-params">(String expression)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">numerator</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, denominator = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = expression.length();<br>        <span class="hljs-keyword">while</span>(index &lt; n) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">numerator1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (expression.charAt(index) == <span class="hljs-string">&#x27;-&#x27;</span> || expression.charAt(index) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = expression.charAt(index) == <span class="hljs-string">&#x27;-&#x27;</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>                index++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(index &lt; n &amp;&amp; Character.isDigit(expression.charAt(index))) &#123;<br>                numerator1 = numerator1 * <span class="hljs-number">10</span> + expression.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                index++;<br>            &#125;<br>            numerator1 = sign * numerator1;<br>            index++;<br><br>            <span class="hljs-type">long</span> <span class="hljs-variable">denominator1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(index &lt; n &amp;&amp; Character.isDigit(expression.charAt(index))) &#123;<br>                denominator1 = denominator1 * <span class="hljs-number">10</span> + expression.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                index++;<br>            &#125;<br>            numerator = denominator * numerator1 + denominator1 * numerator;<br>            denominator *= denominator1;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (numerator == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0/1&quot;</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> gcd(Math.abs(numerator), denominator);<br>        <span class="hljs-keyword">return</span> Long.toString(numerator/g) + <span class="hljs-string">&quot;/&quot;</span> + Long.toString(denominator/g);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> a % b;<br>        <span class="hljs-keyword">while</span>(remainder != <span class="hljs-number">0</span>) &#123;<br>            a = b;<br>            b = remainder;<br>            remainder = a % b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n + logC)$，其中 $n$ 是字符串 expression 的长度，$C$ 是化简前结果分子分母的最大值。求最大公约数需要 $O(logC)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220727093059174.png" alt="image-20220727093059174"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>数学</tag>
      
      <tag>最大公约数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>636.函数的独占时间</title>
    <link href="/2022/07/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/636.%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/"/>
    <url>/2022/07/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/636.%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="636-函数的独占时间"><a href="#636-函数的独占时间" class="headerlink" title="636.函数的独占时间"></a><a href="https://leetcode.cn/problems/exclusive-time-of-functions/">636.函数的独占时间</a></h1><p>难度中等203</p><p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于 <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p><p>函数调用 <strong>存储在一个 <a href="https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p><p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>&quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot;</code> 进行格式化的字符串。例如，<code>&quot;0:start:3&quot;</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>&quot;1:end:2&quot;</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用</strong> 。</p><p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p><p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p><p><strong>示例 1：</strong></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/diag1b.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]<br>输出：[3,4]<br>解释：<br>函数<span class="hljs-number"> 0 </span>在时间戳<span class="hljs-number"> 0 </span>的起始开始执行，执行<span class="hljs-number"> 2 </span>个单位时间，于时间戳<span class="hljs-number"> 1 </span>的末尾结束执行。 <br>函数<span class="hljs-number"> 1 </span>在时间戳<span class="hljs-number"> 2 </span>的起始开始执行，执行<span class="hljs-number"> 4 </span>个单位时间，于时间戳<span class="hljs-number"> 5 </span>的末尾结束执行。 <br>函数<span class="hljs-number"> 0 </span>在时间戳<span class="hljs-number"> 6 </span>的开始恢复执行，执行<span class="hljs-number"> 1 </span>个单位时间。 <br>所以函数<span class="hljs-number"> 0 </span>总共执行<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 3 </span>个单位时间，函数<span class="hljs-number"> 1 </span>总共执行<span class="hljs-number"> 4 </span>个单位时间。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 1, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]<br>输出：[8]<br>解释：<br>函数<span class="hljs-number"> 0 </span>在时间戳<span class="hljs-number"> 0 </span>的起始开始执行，执行<span class="hljs-number"> 2 </span>个单位时间，并递归调用它自身。<br>函数 0（递归调用）在时间戳<span class="hljs-number"> 2 </span>的起始开始执行，执行<span class="hljs-number"> 4 </span>个单位时间。<br>函数 0（初始调用）恢复执行，并立刻再次调用它自身。<br>函数 0（第二次递归调用）在时间戳<span class="hljs-number"> 6 </span>的起始开始执行，执行<span class="hljs-number"> 1 </span>个单位时间。<br>函数 0（初始调用）在时间戳<span class="hljs-number"> 7 </span>的起始恢复执行，执行<span class="hljs-number"> 1 </span>个单位时间。<br>所以函数<span class="hljs-number"> 0 </span>总共执行<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 8 </span>个单位时间。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]<br>输出：[7,1]<br>解释：<br>函数<span class="hljs-number"> 0 </span>在时间戳<span class="hljs-number"> 0 </span>的起始开始执行，执行<span class="hljs-number"> 2 </span>个单位时间，并递归调用它自身。<br>函数 0（递归调用）在时间戳<span class="hljs-number"> 2 </span>的起始开始执行，执行<span class="hljs-number"> 4 </span>个单位时间。<br>函数 0（初始调用）恢复执行，并立刻调用函数<span class="hljs-number"> 1 </span>。<br>函数 1在时间戳<span class="hljs-number"> 6 </span>的起始开始执行，执行<span class="hljs-number"> 1 </span>个单位时间，于时间戳<span class="hljs-number"> 6 </span>的末尾结束执行。<br>函数 0（初始调用）在时间戳<span class="hljs-number"> 7 </span>的起始恢复执行，执行<span class="hljs-number"> 1 </span>个单位时间，于时间戳<span class="hljs-number"> 7 </span>的末尾结束执行。<br>所以函数<span class="hljs-number"> 0 </span>总共执行<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>个单位时间，函数<span class="hljs-number"> 1 </span>总共执行<span class="hljs-number"> 1 </span>个单位时间。 <br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">2</span>, logs = [<span class="hljs-string">&quot;0:start:0&quot;</span>,<span class="hljs-string">&quot;0:start:2&quot;</span>,<span class="hljs-string">&quot;0:end:5&quot;</span>,<span class="hljs-string">&quot;1:start:7&quot;</span>,<span class="hljs-string">&quot;1:end:7&quot;</span>,<span class="hljs-string">&quot;0:end:8&quot;</span>]<br>输出：[<span class="hljs-number">8</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">1</span>, logs = [<span class="hljs-string">&quot;0:start:0&quot;</span>,<span class="hljs-string">&quot;0:end:0&quot;</span>]<br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= logs.length &lt;= 500</code></li><li><code>0 &lt;= function_id &lt; n</code></li><li><code>0 &lt;= timestamp &lt;= 109</code></li><li>两个开始事件不会在同一时间戳发生</li><li>两个结束事件不会在同一时间戳发生</li><li>每道函数都有一个对应 <code>&quot;start&quot;</code> 日志的 <code>&quot;end&quot;</code> 日志</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看起来有点像是JVM里面的虚拟栈，每次函数调用的时候都进行压栈，运行结束之后弹栈</p><p>可以设置一个栈，其中存放二维数组，数组第一个数字表示函数标识号，第二个字符表示函数运行开始的时间戳，方便计算函数运行时间</p><ul><li>当新来一个运行的函数时，查看当前栈是否为空，若为空，直接压栈，若不为空，计算之前还在运行函数的运行时间，再压栈</li><li>收到函数运行结束的日志，弹出该函数，并累加运行时间，如果栈中不为空，则开始运行栈顶的函数，即将其时间戳置为当前时间戳+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exclusiveTime(<span class="hljs-type">int</span> n, List&lt;String&gt; logs) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (String log : logs) &#123;<br>            String[] info = log.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">fid</span> <span class="hljs-operator">=</span> Integer.parseInt(info[<span class="hljs-number">0</span>]), time = Integer.parseInt(info[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">if</span> (info[<span class="hljs-number">1</span>].equals(<span class="hljs-string">&quot;start&quot;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span>[] top = stack.peek();<br>                    ans[top[<span class="hljs-number">0</span>]] += time - top[<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;fid, time&#125;;<br>                stack.push(temp);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span>[] temp = stack.pop();<br>                ans[temp[<span class="hljs-number">0</span>]] += time - temp[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span>[] top = stack.pop();<br>                    top[<span class="hljs-number">1</span>] = time + <span class="hljs-number">1</span>;<br>                    stack.push(top);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220807144828270.png" alt="image-20220807144828270"></p><p>运行时间有点拉胯:laughing:</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1206设计跳表</title>
    <link href="/2022/07/26/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1206.%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/"/>
    <url>/2022/07/26/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1206.%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1206-设计跳表"><a href="#1206-设计跳表" class="headerlink" title="1206. 设计跳表"></a><a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></h1><p>难度困难140收藏分享切换为英文接收动态反馈</p><p>不使用任何库函数，设计一个 <strong>跳表</strong> 。</p><p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/1506_skiplist.gif"></p><p>Artyom Kalinin [CC BY-SA 3.0], via <a href="https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif">Wikimedia Commons</a></p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <code>O(n)</code>。跳表的每一个操作的平均时间复杂度是 <code>O(log(n))</code>，空间复杂度是 <code>O(n)</code>。</p><p>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a></p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li><code>bool search(int target)</code> : 返回target是否存在于跳表中。</li><li><code>void add(int num)</code>: 插入一个元素到跳表。</li><li><code>bool erase(int num)</code>: 在跳表中删除一个值，如果 <code>num</code> 不存在，直接返回false. 如果存在多个 <code>num</code> ，删除其中任意一个即可。</li></ul><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p><strong>示例 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;Skiplist&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;search&quot;, &quot;add&quot;, &quot;search&quot;, &quot;erase&quot;, &quot;erase&quot;, &quot;search&quot;]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>], [<span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>]<br><br>解释<br>Skiplist skiplist = <span class="hljs-built_in">new</span> Skiplist();<br>skiplist.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>skiplist.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br>skiplist.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br>skiplist.<span class="hljs-keyword">search</span>(<span class="hljs-number">0</span>);   // 返回 <span class="hljs-keyword">false</span><br>skiplist.<span class="hljs-keyword">add</span>(<span class="hljs-number">4</span>);<br>skiplist.<span class="hljs-keyword">search</span>(<span class="hljs-number">1</span>);   // 返回 <span class="hljs-keyword">true</span><br>skiplist.erase(<span class="hljs-number">0</span>);    // 返回 <span class="hljs-keyword">false</span>，<span class="hljs-number">0</span> 不在跳表中<br>skiplist.erase(<span class="hljs-number">1</span>);    // 返回 <span class="hljs-keyword">true</span><br>skiplist.<span class="hljs-keyword">search</span>(<span class="hljs-number">1</span>);   // 返回 <span class="hljs-keyword">false</span>，<span class="hljs-number">1</span> 已被擦除<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>0 &lt;= num, target &lt;= 2 * 104</code></li><li>调用<code>search</code>, <code>add</code>,  <code>erase</code>操作次数不大于 <code>5 * 104</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>完全超出我的理解范围，先摆着</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Skiplist</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">P_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.25</span>;<br>    <span class="hljs-keyword">private</span> SkiplistNode head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> level;<br>    <span class="hljs-keyword">private</span> Random random;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Skiplist</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>(-<span class="hljs-number">1</span>, MAX_LEVEL);<br>        <span class="hljs-built_in">this</span>.level = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/* 找到第 i 层小于且最接近 target 的元素*/</span><br>            <span class="hljs-keyword">while</span> (curr.forward[i] != <span class="hljs-literal">null</span> &amp;&amp; curr.forward[i].val &lt; target) &#123;<br>                curr = curr.forward[i];<br>            &#125;<br>        &#125;<br>        curr = curr.forward[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">/* 检测当前元素的值是否等于 target */</span><br>        <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span> &amp;&amp; curr.val == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        SkiplistNode[] update = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>[MAX_LEVEL];<br>        Arrays.fill(update, head);<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/* 找到第 i 层小于且最接近 num 的元素*/</span><br>            <span class="hljs-keyword">while</span> (curr.forward[i] != <span class="hljs-literal">null</span> &amp;&amp; curr.forward[i].val &lt; num) &#123;<br>                curr = curr.forward[i];<br>            &#125;<br>            update[i] = curr;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> randomLevel();<br>        level = Math.max(level, lv);<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>(num, lv);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lv; i++) &#123;<br>            <span class="hljs-comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span><br>            newNode.forward[i] = update[i].forward[i];<br>            update[i].forward[i] = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        SkiplistNode[] update = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>[MAX_LEVEL];<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/* 找到第 i 层小于且最接近 num 的元素*/</span><br>            <span class="hljs-keyword">while</span> (curr.forward[i] != <span class="hljs-literal">null</span> &amp;&amp; curr.forward[i].val &lt; num) &#123;<br>                curr = curr.forward[i];<br>            &#125;<br>            update[i] = curr;<br>        &#125;<br>        curr = curr.forward[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">/* 如果值不存在则返回 false */</span><br>        <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">null</span> || curr.val != num) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>            <span class="hljs-keyword">if</span> (update[i].forward[i] != curr) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span><br>            update[i].forward[i] = curr.forward[i];<br>        &#125;<br>        <span class="hljs-comment">/* 更新当前的 level */</span><br>        <span class="hljs-keyword">while</span> (level &gt; <span class="hljs-number">1</span> &amp;&amp; head.forward[level - <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span>) &#123;<br>            level--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/* 随机生成 lv */</span><br>        <span class="hljs-keyword">while</span> (random.nextDouble() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;<br>            lv++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lv;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkiplistNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    SkiplistNode[] forward;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkiplistNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> maxLevel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.forward = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>[maxLevel];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(log n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/leetcode/image-20220726101423865.png" alt="image-20220726101423865"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>跳表</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>919完全二叉树插入器</title>
    <link href="/2022/07/25/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/919.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/"/>
    <url>/2022/07/25/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/919.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="919-完全二叉树插入器"><a href="#919-完全二叉树插入器" class="headerlink" title="919. 完全二叉树插入器"></a><a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a></h1><p>难度中等119收藏分享切换为英文接收动态反馈</p><p><strong>完全二叉树</strong> 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p><p>实现 <code>CBTInserter</code> 类:</p><ul><li><code>CBTInserter(TreeNode root)</code> 使用头节点为 <code>root</code> 的给定树初始化该数据结构；</li><li><code>CBTInserter.insert(int v)</code> 向树中插入一个值为 <code>Node.val == val</code>的新节点 <code>TreeNode</code>。使树保持完全二叉树的状态，<strong>并返回插入节点</strong> <code>TreeNode</code> <strong>的父节点的值</strong>；</li><li><code>CBTInserter.get_root()</code> 将返回树的头节点。</li></ul><p><strong>示例 1：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/lc-treeinsert.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;CBTInserter&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;get_root&quot;</span>]<br>[[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>], []]<br>输出<br>[null, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br><br>解释<br><span class="hljs-symbol">CBTInserter</span> cBTInserter = new <span class="hljs-symbol">CBTInserter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br>cBTInserter.insert(<span class="hljs-number">3</span>);  // 返回 <span class="hljs-number">1</span><br>cBTInserter.insert(<span class="hljs-number">4</span>);  // 返回 <span class="hljs-number">2</span><br>cBTInserter.get_root(); // 返回 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数量范围为 <code>[1, 1000]</code> </li><li><code>0 &lt;= Node.val &lt;= 5000</code></li><li><code>root</code> 是完全二叉树</li><li><code>0 &lt;= val &lt;= 5000</code> </li><li>每个测试用例最多调用 <code>insert</code> 和 <code>get_root</code> 操作 <code>104</code> 次</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>要想找到完全二叉树的插入位置，可以想到主要是找到未满的一层的上一层的父节点，也就是按照<strong>层序遍历中存在的左右子节点缺失的结点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CBTInserter</span> &#123;<br>    TreeNode root;<br>    List&lt;TreeNode&gt; travelList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CBTInserter</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>        travelList.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur &lt; travelList.size()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> travelList.get(cur);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) travelList.add(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) travelList.add(node.right);<br>            cur++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">while</span>(travelList.get(idx).left != <span class="hljs-literal">null</span> &amp;&amp; travelList.get(idx).right != <span class="hljs-literal">null</span>)<br>            idx++;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">fa</span> <span class="hljs-operator">=</span> travelList.get(idx);<br>        <span class="hljs-keyword">if</span> (fa.left == <span class="hljs-literal">null</span>) fa.left = node;<br>        <span class="hljs-keyword">else</span> fa.right = node;<br>        travelList.add(node);<br>        <span class="hljs-keyword">return</span> fa.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">get_root</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CBTInserter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CBTInserter obj = new CBTInserter(root);</span><br><span class="hljs-comment"> * int param_1 = obj.insert(val);</span><br><span class="hljs-comment"> * TreeNode param_2 = obj.get_root();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$-二叉树结点数</li><li>空间复杂度：$O(n)$-二叉树结点数</li></ul><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220725153418499.png" alt="image-20220725153418499"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1184公交站间的距离</title>
    <link href="/2022/07/24/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1184.%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/07/24/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1184.%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1184-公交站间的距离"><a href="#1184-公交站间的距离" class="headerlink" title="1184. 公交站间的距离"></a><a href="https://leetcode.cn/problems/distance-between-bus-stops/">1184. 公交站间的距离</a></h1><p>难度简单82收藏分享切换为英文接收动态反馈</p><p>环形公交路线上有 <code>n</code> 个站，按次序从 <code>0</code> 到 <code>n - 1</code> 进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code> 表示编号为 <code>i</code> 的车站和编号为 <code>(i + 1) % n</code> 的车站之间的距离。</p><p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p><p>返回乘客从出发点 <code>start</code> 到目的地 <code>destination</code> 之间的最短距离。</p><p><strong>示例 1：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/untitled-diagram-1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：distance = [1,2,3,4], start = 0, destination = 1<br>输出：1<br>解释：公交站<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>之间的距离是<span class="hljs-number"> 1 </span>或 9，最小值是 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/untitled-diagram-1-1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：distance = [1,2,3,4], start = 0, destination = 2<br>输出：3<br>解释：公交站<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>之间的距离是<span class="hljs-number"> 3 </span>或 7，最小值是 3。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/untitled-diagram-1-2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：distance = [1,2,3,4], start = 0, destination = 3<br>输出：4<br>解释：公交站<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>之间的距离是<span class="hljs-number"> 6 </span>或 4，最小值是 4。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>distance.length == n</code></li><li><code>0 &lt;= start, destination &lt; n</code></li><li><code>0 &lt;= distance[i] &lt;= 10^4</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>只有两种方式可以从起点到终点：</p><ul><li>顺时针，遍历从起点到终点，累加所有的距离得到temp1</li><li>逆时针，简单的来说可以是所有的路程减去temp1得到temp2</li></ul><p>比较两个距离，得到最短的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distanceBetweenBusStops</span><span class="hljs-params">(<span class="hljs-type">int</span>[] distance, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> destination)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (start &gt; destination) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> destination;<br>            destination = start;<br>            start = temp;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; destination; i++) &#123;<br>            temp += distance[i];<br>        &#125;<br>        res = Math.min(res, temp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; distance.length; i++) &#123;<br>            sum += distance[i];<br>        &#125;<br>        res = Math.min(res, sum-res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220724200207958.png" alt="image-20220724200207958"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offerII115重建序列</title>
    <link href="/2022/07/23/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%89%91%E6%8C%87OfferII115.%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97/"/>
    <url>/2022/07/23/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%89%91%E6%8C%87OfferII115.%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-II-115-重建序列"><a href="#剑指-Offer-II-115-重建序列" class="headerlink" title="剑指 Offer II 115. 重建序列"></a><a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h1><p>难度中等84收藏分享切换为英文接收动态反馈</p><p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 是范围为 <code>[1，n]</code> 的整数的排列。还提供了一个 2D 整数数组 <code>sequences</code> ，其中 <code>sequences[i]</code> 是 <code>nums</code> 的子序列。<br>检查 <code>nums</code> 是否是唯一的最短 <strong>超序列</strong> 。最短 <strong>超序列</strong> 是 <strong>长度最短</strong> 的序列，并且所有序列 <code>sequences[i]</code> 都是它的子序列。对于给定的数组 <code>sequences</code> ，可能存在多个有效的 <strong>超序列</strong> 。</p><ul><li>例如，对于 <code>sequences = [[1,2],[1,3]]</code> ，有两个最短的 <strong>超序列</strong> ，<code>[1,2,3]</code> 和 <code>[1,3,2]</code> 。</li><li>而对于 <code>sequences = [[1,2],[1,3],[1,2,3]]</code> ，唯一可能的最短 <strong>超序列</strong> 是 <code>[1,2,3]</code> 。<code>[1,2,3,4]</code> 是可能的超序列，但不是最短的。</li></ul><p><em>如果 <code>nums</code> 是序列的唯一最短 <strong>超序列</strong> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</em><br><strong>子序列</strong> 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span>, sequences = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>]</span><br>输出：false<br>解释：有两种可能的超序列：<span class="hljs-comment">[1,2,3]</span>和<span class="hljs-comment">[1,3,2]</span>。<br>序列 <span class="hljs-comment">[1,2]</span> 是<span class="hljs-comment">[1,2,3]</span>和<span class="hljs-comment">[1,3,2]</span>的子序列。<br>序列 <span class="hljs-comment">[1,3]</span> 是<span class="hljs-comment">[1,2,3]</span>和<span class="hljs-comment">[1,3,2]</span>的子序列。<br>因为 nums 不是唯一最短的超序列，所以返回false。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], sequences = <span class="hljs-string">[[1,2]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：最短可能的超序列为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]。<br>序列 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 是它的子序列：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]。<br>因为 nums 不是最短的超序列，所以返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span>, sequences = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：true<br>解释：最短可能的超序列为<span class="hljs-comment">[1,2,3]</span>。<br>序列 <span class="hljs-comment">[1,2]</span> 是它的一个子序列：<span class="hljs-comment">[1,2,3]</span>。<br>序列 <span class="hljs-comment">[1,3]</span> 是它的一个子序列：<span class="hljs-comment">[1,2,3]</span>。<br>序列 <span class="hljs-comment">[2,3]</span> 是它的一个子序列：<span class="hljs-comment">[1,2,3]</span>。<br>因为 nums 是唯一最短的超序列，所以返回true。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>nums</code> 是 <code>[1, n]</code> 范围内所有整数的排列</li><li><code>1 &lt;= sequences.length &lt;= 104</code></li><li><code>1 &lt;= sequences[i].length &lt;= 104</code></li><li><code>1 &lt;= sum(sequences[i].length) &lt;= 105</code></li><li><code>1 &lt;= sequences[i][j] &lt;= n</code></li><li><code>sequences</code> 的所有数组都是 <strong>唯一</strong> 的</li><li><code>sequences[i]</code> 是 <code>nums</code> 的一个子序列</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>官方给的解法是拓扑排序，但是没有理解</p><p>简单的方法是构造一棵树，在树中验证是否存在一条链或者路径和nums吻合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] sequences)</span> &#123;<br>        Map&lt;Integer, Set&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Set&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] sequence : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; sequence.length; i++) &#123;<br>                hashMap.putIfAbsent(sequence[i-<span class="hljs-number">1</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;());<br>                hashMap.get(sequence[i-<span class="hljs-number">1</span>]).add(sequence[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!hashMap.getOrDefault(nums[i-<span class="hljs-number">1</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;()).contains(nums[i]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220723185317963.png" alt="image-20220723185317963"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数组</tag>
      
      <tag>图</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>757设置交集大小至少为2</title>
    <link href="/2022/07/22/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/757.%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/"/>
    <url>/2022/07/22/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/757.%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/</url>
    
    <content type="html"><![CDATA[<h1 id="757-设置交集大小至少为2"><a href="#757-设置交集大小至少为2" class="headerlink" title="757. 设置交集大小至少为2"></a><a href="https://leetcode.cn/problems/set-intersection-size-at-least-two/">757. 设置交集大小至少为2</a></h1><p>难度困难93收藏分享切换为英文接收动态反馈</p><p>一个整数区间 <code>[a, b]</code> ( <code>a &lt; b</code> ) 代表着从 <code>a</code> 到 <code>b</code> 的所有连续整数，包括 <code>a</code> 和 <code>b</code>。</p><p>给你一组整数区间<code>intervals</code>，请找到一个最小的集合 S，使得 S 里的元素与区间<code>intervals</code>中的每一个整数区间都至少有2个元素相交。</p><p>输出这个最小集合S的大小。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[<span class="hljs-comment">[1, 3]</span>, <span class="hljs-comment">[1, 4]</span>, <span class="hljs-comment">[2, 5]</span>, <span class="hljs-comment">[3, 5]</span>]</span><br>输出: 3<br>解释:<br>考虑集合 S = &#123;2, 3, 4&#125;. S与intervals中的四个区间都有至少2个相交的元素。<br>且这是S最小的情况，故我们输出3。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: intervals = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<br>输出: <span class="hljs-number">5</span><br>解释:<br>最小的集合<span class="hljs-symbol">S</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;.<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><code>intervals</code> 的长度范围为<code>[1, 3000]</code>。</li><li><code>intervals[i]</code> 长度为 <code>2</code>，分别代表左、右边界。</li><li><code>intervals[i][j]</code> 的值是 <code>[0, 10^8]</code>范围内的整数。</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题是典型贪心算法，和其他的排序贪心不同的是，在考虑区间的时候需要从每个区间的右边考虑</p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220722100552483.png" alt="image-20220722100552483"></p><ul><li>对原数据按照右边界大小开始排序</li><li>排序结束之后，查看两个边界是否相交<ul><li>相交元素超过两个，则不需要添加新的元素</li><li>相交元素为1个，需要额外添加一个新的元素</li><li>没有相交元素，需要额外添加两个元素</li></ul></li><li>输出总共元素个数</li></ul><p>代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">intersectionSizeTwo</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] interval = intervals[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> interval[<span class="hljs-number">0</span>], r = interval[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (l &gt; b) &#123;<br>                ans += <span class="hljs-number">2</span>;<br>                a = r - <span class="hljs-number">1</span>;<br>                b = r;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == b || l &gt; a) &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                a = b;<br>                b = r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$ O(n) $</li><li>空间复杂度：$ O(l) $</li></ul><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220722095626827.png" alt="image-20220722095626827"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>814二叉树剪枝</title>
    <link href="/2022/07/21/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/814.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/"/>
    <url>/2022/07/21/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/814.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="814-二叉树剪枝"><a href="#814-二叉树剪枝" class="headerlink" title="814. 二叉树剪枝"></a><a href="https://leetcode.cn/problems/binary-tree-pruning/">814. 二叉树剪枝</a></h1><p>难度中等284</p><p>给你二叉树的根结点 <code>root</code> ，此外树的每个结点的值要么是 <code>0</code> ，要么是 <code>1</code> 。</p><p>返回移除了所有不包含 <code>1</code> 的子树的原二叉树。</p><p>节点 <code>node</code> 的子树为 <code>node</code> 本身加上所有 <code>node</code> 的后代。</p><p><strong>示例 1：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1028_2.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>解释：<br>只有红色节点满足条件“所有不包含 <span class="hljs-number">1</span> 的子树”。 右图为返回的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1028_1.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1028.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：root = [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1,0,1,0</span>]<br>输出：[<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1</span>,null,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 200]</code> 内</li><li><code>Node.val</code> 为 <code>0</code> 或 <code>1</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接利用递归的方式解决</p><ul><li>先递归左子树，然后递归右子树，递归前先判断是否为空</li><li>递归出口是：<strong>左右子树都为空，且当前结点值为0</strong></li></ul><p>Java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 左子树不为空，递归左子树</span><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) root.left = pruneTree(root.left);<br>        <span class="hljs-comment">// 右子树不为空，递归右子树</span><br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) root.right = pruneTree(root.right);<br>        <span class="hljs-comment">// 递归出口判断</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; root.val == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$ -递归使用的栈</li></ul><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220721190339116.png" alt="image-20220721190339116"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode初级算法刷题记录</title>
    <link href="/2022/07/21/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/21/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>这是由 LeetCode 官方推出的经典面试题目清单初级算法版本</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">删除排序数组中的重复项</a></h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>判题标准:</p><p>系统会用下面的代码来测试你的<strong>题解</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = [...]; <span class="hljs-comment">// 输入数组</span><br><span class="hljs-type">int</span>[] expectedNums = [...]; <span class="hljs-comment">// 长度正确的期望答案</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> removeDuplicates(nums); <span class="hljs-comment">// 调用</span><br><br><span class="hljs-keyword">assert</span> k == expectedNums.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>    <span class="hljs-keyword">assert</span> nums[i] == expectedNums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的<strong>题解</strong>将被通过。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：2, nums = <span class="hljs-comment">[1,2,_]</span><br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,2,2,3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p><p><strong>题解</strong></p><p>原数组已经按照升序排列，所以相同的元素必定是相邻的，可以设置两个指针，一个指针<code>ans</code>指向不重复数组元素的最后一位，一个指针<code>cur</code>指向遍历的元素，判断两个指针指向元素是否相同</p><ul><li>如果相同，则<code>cur++</code>，继续查找下一个元素</li><li>如果不同，那么<code>ans</code>下一位元素变更为<code>cur</code>当前指向元素</li></ul><p>最后数组遍历结束，返回不重复数组元素的长度，<code>ans</code>指向的是不重复元素的最后一位的索引，为了获取长度，还需要+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, ans = <span class="hljs-number">0</span>, cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(cur &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[ans] != nums[cur])<br>                nums[++ans] = nums[cur];<br>            cur++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ++ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184822895.png" alt="image-20220428184822895"></p><h3 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">买卖股票的最佳时机II</a></h3><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>相关标签</strong></p><ul><li>贪心</li><li>数组</li><li>动态规划</li></ul><p><strong>题解</strong></p><p>如下图是表示的一个股票价格上涨曲线，要计算这段时间内股票的最大利润，可以直接将股票所有上涨时间段内的利润累加起来就得到了</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428101138044.png" alt="image-20220428101138044"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length, ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            ans += Math.max(prices[i] - prices[i-<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184811158.png" alt="image-20220428184811158"></p><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/">旋转数组</a></h3><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[5,6,7,1,2,3,4]</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">向右轮转 1 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[7,1,2,3,4,5,6]</span><br><span class="hljs-attribute">向右轮转 2 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[6,7,1,2,3,4,5]</span><br><span class="hljs-attribute">向右轮转 3 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[5,6,7,1,2,3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3,99], k = 2<br>输出：[3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br>解释: <br>向右轮转 1 步: [99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3]<br>向右轮转 2 步: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为<code>O(1)</code>的 原地 算法解决这个问题吗？</li></ul><p><strong>题解</strong></p><p>可以转换一下思路：</p><ul><li>首先将整个数组进行反转</li><li>然后将数组<code>[0, k-1]</code>位置的元素进行反转</li><li>最后将剩下的<code>[k, length - 1]</code>位置的元素进行反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        k %= len;<br>        <span class="hljs-keyword">if</span> (len&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        reverse(nums, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>);<br>        reverse(nums,<span class="hljs-number">0</span>, k-<span class="hljs-number">1</span>);<br>        reverse(nums, k, len-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start, right = end;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>            ++left;<br>            --right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184623433.png" alt="image-20220428184623433"></p><h3 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">存在重复元素</a></h3><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,1,3</span>,<span class="hljs-number">3,4,3,2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p><strong>相关标签</strong></p><ul><li>数组</li><li>哈希表</li><li>排序</li></ul><p><strong>题解</strong></p><p><strong>HashSet实现</strong></p><p>将元素添加到<code>HashSet</code>中，如果无法添加说明已经存在，直接返回<code>true</code>，如果数组遍历结束那么返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>            <span class="hljs-keyword">if</span> (!set.add(num))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184517850.png" alt="image-20220428184517850"></p><p><strong>先排序然后比较两个相邻的元素</strong></p><p>排序原数组，相同的元素必定相邻，判断相邻的元素是否相等，如果相等返回<code>true</code>，所有元素遍历之后都不相等，返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p>主要还是排序的时间开销过大导致的执行时间太高，这样对比还是利用<code>HashSet</code>更为高效</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184203724.png" alt="image-20220428184203724"></p><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">只出现一次的数字</a></h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>相关标签</strong></p><ul><li>位运算</li><li>数组</li></ul><p><strong>题解</strong></p><p>所有的元素都出现两次，相同的元素异或为0，剩下的只出现一次的元素和0异或的结果还是其本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            res ^= num;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184147570.png" alt="image-20220428184147570"></p><h3 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/">两个数组的交集 II</a></h3><p>给你两个整数数组 <code>nums1 </code>和 <code>nums2 </code>，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[4,9]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong></p><ul><li><p>如果给定的数组已经排好序呢？你将如何优化你的算法？</p></li><li><p>如果 nums1 的大小比 nums2 小，哪种方法更优？</p></li><li><p>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p></li></ul><p><strong>题解</strong></p><p>首先对两个数组进行排序，然后设置两个指针分别指向排序后数组开头，在两个指针都分别不超过数组的情况下，比较两个指针指向元素的大小</p><ul><li>如果相等，添加到结果数组中，两个指针都自增1</li><li>如果不等，指向元素小的指针自增</li></ul><p>最后将保存结果的列表转换为数组输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersect(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Arrays.sort(nums1);<br>        Arrays.sort(nums2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length, len2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (index1 &lt; len1 &amp;&amp; index2 &lt; len2) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[index1] &lt; nums2[index2])<br>                index1++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[index1] &gt; nums2[index2])<br>                index2++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans.add(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>            res[i] = ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184132539.png" alt="image-20220428184132539"></p><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/">加一</a></h3><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,2,4]</span><br>解释：输入数组表示数字 123。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：digits = [<span class="hljs-number">4,3,2,1</span>]<br>输出：[<span class="hljs-number">4,3,2,2</span>]<br>解释：输入数组表示数字 <span class="hljs-number">4321</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><p><strong>题解</strong></p><p>这道题就是模拟加法进位，注意的是在执行加法进位的时候，需要从最后一位开始计算</p><ul><li>如果有进位，那么当前位结果必定为<code>0</code>，进位为<code>1</code></li><li>没有进位，就将当前结果和上一次的进位相加保存</li></ul><p>因为可能会出现进位后数位加一的情况，所以暂存结果可以用<code>List</code>来保存，然后<strong>逆序</strong>输出结果至<code>int</code>数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] plusOne(<span class="hljs-type">int</span>[] digits) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> digits.length-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (digits[i] + carry &gt; <span class="hljs-number">9</span>) &#123;<br>                carry = <span class="hljs-number">1</span>;<br>                res.add(<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                res.add(digits[i] + carry);<br>                carry = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry != <span class="hljs-number">0</span>)<br>            res.add(carry);<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=res.size()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>            ans[res.size() - <span class="hljs-number">1</span> - i] = res.get(i); <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184119444.png" alt="image-20220428184119444"></p><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/">移动零</a></h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p>提示:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p><p><strong>题解</strong></p><p>设置一个指针<code>index</code>保存不为0的元素，然后遍历数组中的所有元素，将其保存到<code>index</code>位置，然后<code>index++</code>，最后将<code>index, nums.length-1</code>位置的数组全部改为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; left &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(left &lt; n &amp;&amp; nums[left] != <span class="hljs-number">0</span>)<br>                left++;<br>            right = left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; nums[right] == <span class="hljs-number">0</span>)<br>                right++;<br>            <span class="hljs-keyword">if</span> (right &gt;= n)<br>                <span class="hljs-keyword">return</span> ;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>            left++;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184104388.png" alt="image-20220428184104388"></p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/">两数之和</a></h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target  </code>的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><p><strong>题解</strong></p><p><strong>HashMap法</strong></p><p>首先遍历一遍数组，将对应的差值和索引保存在<code>HashMap</code>中，然后再次遍历<code>HashMap</code>，如果有数组元素在<code>HashMap</code>中，取出<code>HashMap</code>中的元素以及当前遍历索引，返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            map.put(target-nums[i], i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> map.getOrDefault(nums[i], -<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (temp != -<span class="hljs-number">1</span> &amp;&amp; temp != i) &#123;<br>                res[<span class="hljs-number">0</span>] = temp;<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2n)$ 包括两次数组遍历</li><li>空间复杂度：$O(n)$ 主要是<code>HashMap</code>空间</li></ul><p><strong>一次遍历</strong></p><p>可以通过一次遍历获取结果，可以看做前半部分的遍历是获取其中一般元素，后一半的遍历就是查看<code>HashMap</code>中是否存在和当前元素和为<code>target</code>的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(target - nums[i]) != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, map.get(target-nums[i])&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428184045437.png" alt="image-20220428184045437"></p><h3 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/">有效的数独</a></h3><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><ul><li><p>数字 1-9 在每一行只能出现一次。</p></li><li><p>数字 1-9 在每一列只能出现一次。</p></li><li><p>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p></li></ul><p><strong>注意：</strong></p><ul><li><p>一个有效的数独（部分已被填充）不一定是可解的。</p></li><li><p>只需要根据以上规则，验证已经填入的数字是否有效即可。</p></li><li><p>空白格用 ‘.’ 表示。</p></li></ul><p>示例 1：</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428171517947.png" alt="image-20220428171517947"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = <br>[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = <br>[[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：false<br>解释：除了第一行的第一个数字从 <span class="hljs-number">5</span> 改为 <span class="hljs-number">8</span> 以外，空格内其他数字均与 示例<span class="hljs-number">1</span> 相同。 但由于位于左上角的 <span class="hljs-number">3</span>x3 宫内有两个 <span class="hljs-number">8</span> 存在, 因此这个数独是无效的。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j] 是一位数字（1-9）或者 &#39;.&#39;</code></li></ul><p><strong>题解</strong></p><p>表格固定形状大小为<code>9 x 9</code>，需要查看每一行，每一列，以及<code>3 x 3</code> 大小表格是否有相同元素，可以设定3个2维数组分别表示对应行、列以及小网格内<code>0-9</code>是否存在，如果有任意一个出现重复元素则返回<code>false</code>，遍历结束返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.length, m = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">10</span>], col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][<span class="hljs-number">10</span>], cell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (i/<span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + (j/<span class="hljs-number">3</span>);<br>                <span class="hljs-keyword">if</span> (row[i][num] == <span class="hljs-number">1</span> || col[j][num] == <span class="hljs-number">1</span> || cell[k][num] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                row[i][num] = col[j][num] = cell[k][num] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(10 \cdot n)$ 主要是三个二维数组</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428183921926.png" alt="image-20220428183921926"></p><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/">旋转图像</a></h3><p>给定一个<code> n × n</code> 的二维矩阵 <code>matrix </code>表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p>示例 1：</p><p><img src="/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/mat2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><p><strong>题解</strong></p><p>如下图所示</p><p><img src="/1615651665-WFwYuH-leet0048.png" alt="leet0048.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-i][j];<br>                matrix[n-<span class="hljs-number">1</span>-i][j] = temp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220428183855572-16511423372634.png" alt="image-20220428183855572"></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/">反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用<code>O(1)</code>的额外空间解决这一问题。</p><p>示例 1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]<br>输出：[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br>输出：[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <code>ASCII </code>码表中的可打印字符</li></ul><p><strong>题解</strong></p><p>设置两个指针：左指针，右指针，分别指向字符串数组的开头和结尾，交换两个指针指向的字符，然后两个指针同时向中间移动，移动一次交换一次指向的字符，直到两个指针相遇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>            s[left] = s[right];<br>            s[right] = temp;<br>            ++left;<br>            --right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429093337990.png" alt="image-20220429093337990"></p><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/">整数反转</a></h3><p>给你一个 32 位的有符号整数 <code>x </code>，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围<code>[−231,  231 − 1]</code>，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：x <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br>输出：<span class="hljs-number">321</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：x = <span class="hljs-string">-123</span><br>输出：<span class="hljs-string">-321</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：x <span class="hljs-operator">=</span> <span class="hljs-number">120</span><br>输出：<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：x <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><p><strong>题解</strong></p><p><strong>使用java API来实现</strong></p><p>时间开销很大，空间开销也很大，具体的思路是：</p><ul><li>记录数字符号，并将数字绝对化</li><li>然后将数字转换为字符串，然后再转换为字符串数组</li><li>将字符串数组进行反转</li><li>然后将字符串数组转换为字符串</li><li>然后将字符串根据符号和对应最大数字字符串进行比较，如果大于，返回0，不大于就转换为数字返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">max_str</span> <span class="hljs-operator">=</span> String.valueOf(Integer.MAX_VALUE);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            x = -x;<br>            sign = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> String.valueOf(x);<br>        <span class="hljs-type">char</span>[] s = temp.toCharArray();<br>        <span class="hljs-keyword">if</span> (s.length &gt; <span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        reverseString(s);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> String.valueOf(s);<br>        <span class="hljs-keyword">if</span> (s.length == <span class="hljs-number">10</span> &amp;&amp; (sign ? res.compareTo(max_str) &gt;= <span class="hljs-number">0</span> : res.compareTo(max_str) &gt;= <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.parseInt(res);<br><br>        <span class="hljs-keyword">return</span> sign ? ans : -ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>            s[left] = s[right];<br>            s[right] = temp;<br>            ++left;<br>            --right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(log10(x))$ 时间复杂度和输入数字的位数成线性关系</li><li>空间复杂度：$O(log10(x))$ 空间复杂度也主要和输入数字的位数</li></ul><img src="image-20220429100740337.png" alt="image-20220429100740337" style="zoom:80%;" /><p><strong>直接利用long</strong></p><p>使用<code>long</code>暂存中间值，从<code>x</code>的个位开始反向保存，最后将中间值转换为<code>int</code>比较是否和中间值相等，如果相等，则直接返回转换为<code>int</code>的值，否则返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            res = res * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res == res ? (<span class="hljs-type">int</span>)res : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(log10(x))$ 时间复杂度和输入数字的位数成线性关系</li><li>空间复杂度：$O(log10(x))$ 空间复杂度也主要和输入数字的位数</li></ul><img src="image-20220429102733040.png" alt="image-20220429102733040" style="zoom:80%;" /><h3 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/">字符串中的第一个唯一字符</a></h3><p>给定一个字符串 <code>s</code> ，找到 <strong>它的第一个不重复的字符，并返回它的索引</strong> 。如果不存在，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;leetcode&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;loveleetcode&quot;</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;aabb&quot;</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s </code>只包含小写字母</li></ul><p><strong>题解</strong></p><p><strong>数组作为set</strong></p><p>设置一个26长度的数组，分别保存小写字母出现的次数，首先遍历一次字符串，将对应字符出现的次数填写该数组中，然后再次遍历该数组，获取第一次出现次数为1的字符，返回当前索引，不存在就返回<code>-1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">char</span>[] sarr = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sarr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> sarr[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            ++set[ch];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> sarr[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (set[ch] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(26)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429103936846.png" alt="image-20220429103936846"></p><p><strong>可以使用string api实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.indexOf(s.charAt(i)) == s.lastIndexOf(s.charAt(i)))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O()$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429104326355.png" alt="image-20220429104326355"></p><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/">有效的字母异位词</a></h3><p>给定两个字符串 <code>s </code>和 <code>t</code> ，编写一个函数来判断 <code>t </code>是否是 <code>s</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>s</code> 和<code> t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t </code>互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;anagram&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;nagaram&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;rat&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;car&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s </code>和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p><strong>题解</strong></p><p>首先比较两个字符串长度是否相同，不同返回<code>false</code></p><p>使用26长度的数组保存字符串中字符出现的次数，首先遍历第一个字符串保存其字符出现次数，然后遍历第二个字符串，如果遍历过程中出现数组小于0，返回<code>false</code>，遍历结束之后返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span>[] set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-type">char</span>[] cs = s.toCharArray(), ct = t.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)<br>            set[cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ct[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (--set[temp] &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(26)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429110247575.png" alt="image-20220429110247575"></p><blockquote><p>测试发现，对于字符串遍历，先转换为<code>char[]</code>数组遍历效率比直接遍历<code>string</code>要快很多</p></blockquote><h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/">验证回文串</a></h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;amanaplanacanalpanama&quot;</span> 是回文串<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;race a car&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;raceacar&quot;</span> 不是回文串<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 105</code></li><li>字符串 <code>s</code> 由 ASCII 字符组成</li></ul><p><strong>题解</strong></p><p>使用双指针分别指向字符串开头和结尾，如果不属于字母或者数字就跳过，然后比较两个指针指向的字符是否相等，不等则返回<code>false</code>，两个指针相遇返回<code>true</code></p><p>注意大小写转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; !isLegal(cs[left]))<br>                ++left;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; !isLegal(cs[right]))<br>                --right;<br><br>            <span class="hljs-keyword">if</span> (isUpper(cs[left]))<br>                cs[left] = toLowerCase(cs[left]);<br>            <span class="hljs-keyword">if</span> (isUpper(cs[right]))<br>                cs[right] = toLowerCase(cs[right]);<br>            <span class="hljs-keyword">if</span> (cs[left] != cs[right])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++left;<br>            --right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLegal</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUpper</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">return</span> ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">toLowerCase</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>) ((<span class="hljs-type">int</span>)ch+<span class="hljs-number">32</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429113314237.png" alt="image-20220429113314237"></p><p><strong>使用Java自带api</strong></p><p>使用api简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(cs[left]))<br>                ++left;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(cs[right]))<br>                --right;<br><br><br>            <span class="hljs-keyword">if</span> (Character.toLowerCase(cs[left]) != Character.toLowerCase(cs[right]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++left;<br>            --right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429113631076.png" alt="image-20220429113631076"></p><h3 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/">字符串转换整数 (atoi)</a></h3><p>请你来实现一个<code>myAtoi(string s)</code>函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p><p>函数 <code>myAtoi(string s) </code>的算法如下：</p><ul><li><p>读入字符串并丢弃无用的前导空格</p></li><li><p>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</p></li><li><p>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</p></li><li><p>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为<code> 0</code> 。必要时更改符号（从步骤 2 开始）。</p></li><li><p>如果整数数超过 32 位有符号整数范围<code>[−231,  231 − 1]</code>，需要截断这个整数，使其保持在这个范围内。具体来说，小于$ −2^{31}$ 的整数应该被固定为$ −2^{31}$ ，大于 $2^{31} − 1 $的整数应该被固定为$2^{31} − 1$ 。</p></li><li><p>返回整数作为最终结果。</p></li></ul><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li><li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;42&quot;</span><br>输出：<span class="hljs-number">42</span><br>解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">&quot;42&quot;</span>（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">&quot;42&quot;</span>（当前没有读入字符，因为这里不存在 <span class="hljs-string">&#x27;-&#x27;</span> 或者 <span class="hljs-string">&#x27;+&#x27;</span>）<br>         ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">&quot;42&quot;</span>（读入 <span class="hljs-string">&quot;42&quot;</span>）<br>           ^<br>解析得到整数 <span class="hljs-number">42</span> 。<br>由于 <span class="hljs-string">&quot;42&quot;</span> 在范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 内，最终结果为 <span class="hljs-number">42</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：s = &quot;   <span class="hljs-string">-42</span>&quot;<br>输出：<span class="hljs-string">-42</span><br>解释：<br>第 1 步：&quot;   <span class="hljs-string">-42</span>&quot;（读入前导空格，但忽视掉）<br>            ^<br>第 2 步：&quot;   <span class="hljs-string">-42</span>&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）<br>             ^<br>第 3 步：&quot;   <span class="hljs-string">-42</span>&quot;（读入 &quot;42&quot;）<br>               ^<br>解析得到整数 <span class="hljs-string">-42</span> 。<br>由于 &quot;<span class="hljs-string">-42</span>&quot; 在范围 [<span class="hljs-string">-231</span>, 231 - 1] 内，最终结果为 <span class="hljs-string">-42</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;4193 with words&quot;</span><br>输出：<span class="hljs-number">4193</span><br>解释：<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为这里不存在 <span class="hljs-string">&#x27;-&#x27;</span> 或者 <span class="hljs-string">&#x27;+&#x27;</span>）<br>         ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">&quot;4193 with words&quot;</span>（读入 <span class="hljs-string">&quot;4193&quot;</span>；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 <span class="hljs-number">4193</span> 。<br>由于 <span class="hljs-string">&quot;4193&quot;</span> 在范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 内，最终结果为 <span class="hljs-number">4193</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s </code>由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39; </code>组成</li></ul><p><strong>题解</strong></p><p>可以分为以下三个步骤来解决</p><ul><li>首先通过空格去除函数去除字符串中的空格</li><li>查看是否存在符号，如果存在，记录符号</li><li>然后读取剩余字符串中的数字，并组合为结果，在组合之前，判断是否可能出现越界，如果越界，输出最大或最小的可能值，如果没有越界，添加符号，输出组合后的值</li></ul><p>为了方便组合，符号用<code>+1</code>和<code>-1</code>表示，并且为了提高运行速度，在去除空格之后将剩余的字符串转换为<code>char[]</code>类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim();<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (cs[index] == <span class="hljs-string">&#x27;-&#x27;</span> || cs[index] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>            sign = cs[index++] == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(index &lt; len) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> cs[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (digit &lt; <span class="hljs-number">0</span> || digit &gt; <span class="hljs-number">9</span>)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span> || (res == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; digit &gt; Integer.MAX_VALUE % <span class="hljs-number">10</span>))<br>                <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>            <span class="hljs-keyword">else</span><br>                res = res * <span class="hljs-number">10</span> + digit;<br>            ++index;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign * res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429130633928.png" alt="image-20220429130633928"></p><h3 id="实现-strStr-x3D-x3D-KMP算法-x3D-x3D"><a href="#实现-strStr-x3D-x3D-KMP算法-x3D-x3D" class="headerlink" title="实现 strStr()-&#x3D;&#x3D;KMP算法&#x3D;&#x3D;"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnr003/">实现 strStr()</a>-&#x3D;&#x3D;KMP算法&#x3D;&#x3D;</h3><p>实现<code>strStr()</code>函数。</p><p>给你两个字符串 <code>haystack </code>和 needle<code> </code>，请你在 <code>haystack </code>字符串中找出 needle<code> </code>字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p><strong>说明：</strong></p><p>当 <code>needle </code>是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle </code>是空字符串时我们应当返回 0 。这与 C 语言的<code>strstr()</code>以及 Java 的 <code>indexOf() </code>定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;ll&quot;</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;aaaaa&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;bba&quot;</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack </code>和 <code>needle </code>仅由小写英文字符组成</li></ul><p><strong>题解</strong></p><p>可以使用kmp算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 数组next表示pattern指定的下标前具有相同的字符串数量，语言组织能力不好，可能不是太好理解，我举个例子吧</span><br><span class="hljs-comment">         * ，比如ABCABA，数组next[0]是-1，这个是固定的，因为第一个A前面是没有字符的，next[1]是0，因为B的前面就一个A，没有</span><br><span class="hljs-comment">         * 重复的，所以是0,同理next[2]也是,next[3]也是0,而next[4]是1，因为next[4]所指向的是第二个B，第二个B前面有一个A和</span><br><span class="hljs-comment">         * 第一个A相同，所以是1,next[5]是2，因为next[5]所指向的是最后一个Ａ，因为前面的Ａ对比成功，并且Ｂ也对比成功，所以是２，</span><br><span class="hljs-comment">         * 也就是ＡＢ两个字符串匹配成功,再举个例子，比如WABCABA，数组除了第一个为-1，其他的都是为0，因为只有第一个匹配成功之后</span><br><span class="hljs-comment">         * 才能匹配后面的，虽然后面的AB和前面的AB匹配成功，但是后面AB的前面是C和前面AB的前面一个W不匹配，所以后面的匹配都是0.</span><br><span class="hljs-comment">         * 要记住只有指定字符前面的字符和第一个字符匹配成功的时候才能往后匹配，否则后面的永远都是先和第一个匹配。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>        getNext(needle, next);<br>        <span class="hljs-keyword">while</span> (i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 这里j等于-1的时候也只有在下面next数组赋值的时候才会出现，并且只有在数组next[0]的时候才会等于-1，</span><br><span class="hljs-comment">             其他时候是没有的，这一点要谨记，待会下面求next数组的时候就会用到。这里可以这样来理解，如果j不等于-1，</span><br><span class="hljs-comment">             并且下标i和j所指向的字符相等，那么i和j分别往后移一位继续比较，这个很好理解，那么如果j==-1的时候，就表示</span><br><span class="hljs-comment">             就表示前面没有匹配成功的，同时i往后移一位，j置为0（j==-1的时候，j++为0），再从0开始比较。</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * i = i - j + 1;</span><br><span class="hljs-comment">                 j = 0;</span><br><span class="hljs-comment">                 返回到指定的位置，不是返回到匹配失败的下一个位置，这里都好理解，重点是求数组next。</span><br><span class="hljs-comment">                 这里只要j等于0，在next[j]赋值的之后，j就会等于-1；因为next[0]等于-1</span><br><span class="hljs-comment">                 */</span><br>                j = next[j]; <span class="hljs-comment">// j回到指定位置</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == needle.length())<br>                <span class="hljs-keyword">return</span> i - j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(String p, <span class="hljs-type">int</span> next[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<span class="hljs-comment">//这个默认的，</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匹配的时候是当前字符的前一个和前面的匹配，所以最后一个是不参与匹配的，可以看strStr方法的注释，</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || p.charAt(i) == p.charAt(j)) &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 如果j不等于-1，指定的字符相等，那么i和j要往后移一位，这点很好理解，如果j为-1的时候，i往后移移位，j置为0</span><br><span class="hljs-comment">                 * 重新开始匹配。next[i]是匹配成功的数量</span><br><span class="hljs-comment">                 */</span><br>                i++;<br>                j++;<br>                next[i] = j;<br>            &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 关键是这里不好理解，为什么匹配失败要让next[j]等于j，要记住这里的next[j]是指匹配成功的数量，有可能为0，也有可能是其他数.比如</span><br><span class="hljs-comment">             * 字符串ABCABXYABCABATDM,对应的next数组为&#123;-1000120012345100&#125;</span><br><span class="hljs-comment">             */</span><br>                j = next[j];<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnpvdm/">外观数列</a></h3><p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n </code>项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n) </code>是对 <code>countAndSay(n-1) </code>的描述，然后转换成另一个数字字符串。</li></ul><p>前五项如下：</p><ol><li>&#96;&#96;&#96;<ol><li><pre><code class="hljs">1</code></pre></li><li><pre><code class="hljs">11</code></pre></li><li><pre><code class="hljs">21</code></pre></li><li><pre><code class="hljs">1211</code></pre></li><li><pre><code class="hljs">111221第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</code></pre><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。<br><br>例如，数字字符串 <span class="hljs-string">&quot;3322251&quot;</span> 的描述如下图：<br><br>![img](<span class="hljs-number">1629874763</span>-TGmKUh-image.png)<br><br>**示例 <span class="hljs-number">1</span>：**<br><br></code></pre></td></tr></table></figure>输入：n &#x3D; 1<br>输出：”1”<br>解释：这是一个基本样例。<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**示例 2：**</span><br><br></code></pre></td></tr></table></figure>输入：n &#x3D; 4<br>输出：”1211”<br>解释：<br>countAndSay(1) &#x3D; “1”<br>countAndSay(2) &#x3D; 读 “1” &#x3D; 一 个 1 &#x3D; “11”<br>countAndSay(3) &#x3D; 读 “11” &#x3D; 二 个 1 &#x3D; “21”<br>countAndSay(4) &#x3D; 读 “21” &#x3D; 一 个 2 + 一 个 1 &#x3D; “12” + “11” &#x3D; “1211”<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>**提示：**<br><br>- `<span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">30</span>`<br><br><br>**题解**<br><br>使用递归处理，递归出口为`<span class="hljs-number">1</span>`<br><br>```java<br><span class="hljs-keyword">class</span> Solution &#123;<br>    public String count<span class="hljs-constructor">AndSay(<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) return <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            String lastStr = count<span class="hljs-constructor">AndSay(<span class="hljs-params">n</span> - 1)</span>; <span class="hljs-comment">// 1 2 1 1</span><br>            StringBuilder ans = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>            <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>, len = lastStr.length<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; len) &#123;<br>                <span class="hljs-keyword">if</span> (lastStr.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != lastStr.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>) &#123;<br>                    ans.append(j - i).append(lastStr.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>                    i = j;<br>                &#125;<br>                j++;<br>            &#125;<br>            ans.append(j - i).append(lastStr.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>            return ans.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429133414150.png" alt="image-20220429133414150"></p><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnmav1/">最长公共前缀</a></h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i] </code>仅由小写英文字母组成</li></ul><p><strong>题解</strong></p><p>使用第一个字符串作为模板，然后判断最长公共前缀，设置一个<code>resLen</code>记录当前最长公共前缀的长度，最后通过子串裁剪输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">resLen</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">char</span>[] s1 = strs[<span class="hljs-number">0</span>].toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">char</span>[] s2 = strs[i].toCharArray();<br>            resLen = Math.min(resLen, s2.length);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; resLen; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s1[j] == s2[j])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    resLen = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, resLen);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times m)$</li><li>空间复杂度：$O(n \times m)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220429135416877.png" alt="image-20220429135416877"></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>链表中也常用<strong>双指针解法</strong></li><li>可以添加一个头结点指针简化链表操作</li></ul><h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnarn7/">删除链表中的节点</a></h3><p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 <strong>要被删除的节点</strong> 。</p><p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="/node1.jpg" alt="img"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 5</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]<br>解释：指定链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/node2.jpg" alt="img"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 1</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]<br>解释：指定链表中值为 <span class="hljs-number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是<code> [2, 1000]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>链表中每个节点的值都是 <strong>唯一</strong> 的</li><li>需要删除的节点 <code>node </code>是 <strong>链表中的节点</strong> ，且 <strong>不是末尾节点</strong></li></ul><p><strong>题解</strong></p><p>将要删除结点下一个结点的值覆盖到待删除结点，然后删除待删除节点的的下一个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.val = node.next.val;<br>        node.next = node.next.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220430042424887.png" alt="image-20220430042424887"></p><h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn2925/">删除链表的倒数第N个节点</a></h3><p>给你一个链表，删除链表的倒数第<code> n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="/remove_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>链表中结点的数目为 <code>sz</code></p></li><li><p><code>1 &lt;= sz &lt;= 30</code></p></li><li><p><code>0 &lt;= Node.val &lt;= 100</code></p></li><li><p><code>1 &lt;= n &lt;= sz</code></p></li></ul><p><strong>进阶</strong>：你能尝试使用一趟扫描实现吗？</p><p><strong>题解</strong></p><p>可以设置两个指针，一个快指针，一个慢指针，快指针提前<code>n</code>步移动，然后慢指针再移动，如果快指针移动到末尾，那么慢指针就指向要删除的结点，执行删除</p><p>注意如果快指针提前<code>n</code>步移动之后为<code>null</code>，说明<code>n</code>为当前链表长度，要删除的是头结点，可以直接返回<code>head.next</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>            cur = cur.next;<br>            --n;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            pre = pre.next;<br>        &#125;<br>        pre.next = pre.next.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220501172344682.png" alt="image-20220501172344682"></p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnhm6/">反转链表</a></h3><p>给你单链表的头节点<code> head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/rev1ex2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>链表中节点的数目范围是 [0, 5000]</p></li><li><p><code>-5000 &lt;= Node.val &lt;= 5000</code></p></li></ul><p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p><strong>题解</strong></p><p>可以使用一个辅助指针<code>pre</code>指向前一个结点的地址，然后反向修改<code>next</code>指向前一个结点的地址，之后将<code>pre</code>指针改为当前访问结点的地址，继续遍历下一个结点，直到所有结点都被遍历过结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220503203955275-16515815971581.png" alt="image-20220503203955275"></p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnbp2/">合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="/merge_ex1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>两个链表的节点数目范围是<code> [0, 50]</code></p></li><li><p><code>-100 &lt;= Node.val &lt;= 100</code></p></li><li><p><code>l1 </code>和 <code>l2</code> 均按 非递减顺序 排列</p></li></ul><p><strong>题解</strong></p><p>设置一个头结点<code>ans</code>方便操作，然后设置<code>cur</code>初始化等于<code>ans</code>，同时遍历两个链表开头的元素，小的元素插入到<code>ans</code>链表中，直到其中任意一个链表为空，然后将非空链表剩余部分再插入结果链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> ans;<br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>                cur = cur.next;<br>                cur.next = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>                cur = cur.next;<br>                cur.next = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span> || list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span>) &#123;<br>                cur.next = list1;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n+m)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220503211404945.png" alt="image-20220503211404945"></p><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnv1oc/">回文链表</a></h3><p>给你一个单链表的头节点 <code>head </code>，请你判断该链表是否为回文链表。如果是，返回 <code>true </code>；否则，返回 false<code> </code>。</p><p><strong>示例 1：</strong></p><p><img src="/pal1linked-list.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,2,1]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/pal2linked-list.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>链表中节点数目在范围$[1, 10^5] $内</p></li><li><p><code>0 &lt;= Node.val &lt;= 9</code></p></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n) </code>时间复杂度和<code> O(1)</code> 空间复杂度解决此题？</p><p><strong>题解</strong></p><p>首先找到链表的中间结点，然后反转中间结点开始之后的结点，之后比较反转之后的一半链表和前一半是否相同，不同返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        middle = reverseList(middle);<br>        <span class="hljs-keyword">while</span>(middle != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head.val != middle.val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            head = head.next;<br>            middle = middle.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220503214648725.png" alt="image-20220503214648725"></p><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnwzei/">环形链表</a></h3><p>给你一个链表的头节点 <code>head </code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos </code>不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true </code>。 否则，返回 <code>false </code>。</p><p><strong>示例 1：</strong></p><p><img src="/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>链表中节点的数目范围是<code> [0, 104]</code></p></li><li><p><code>-105 &lt;= Node.val &lt;= 105</code></p></li><li><p><code>pos</code> 为<code>-1</code>或者链表中的一个 <strong>有效索引</strong> 。</p></li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><p><strong>题解</strong></p><p>设置两个指针，一个慢指针<code>slow</code>，一个快指针<code>fast</code>，其中<code>slow</code>从<code>head</code>开始，一个从<code>head.next</code>开始</p><p><code>slow</code>指针一次移动一个节点，<code>fast</code>一次移动两个节点，如果<code>slow</code>节点追上<code>fast</code>节点说明链表中存在环，否则不存在环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head.next;<br>        <span class="hljs-keyword">while</span>(slow != fast) &#123;<br>            <span class="hljs-keyword">if</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)<br>                fast = fast.next.next;    <br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505095938927.png" alt="image-20220505095938927"></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树比链表稍微复杂，因为链表是线性数据结构，而树不是。 树的问题可以由 <strong>广度优先搜索</strong>或 <strong>深度优先搜索</strong> 解决</p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnd69e/">二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树<code> [3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br>/ <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>题解</strong></p><p>直接使用递归实现</p><ul><li>如果当前根节点为<code>null</code>，返回0</li><li>如果当前左右子树都为<code>null</code>，即表示当前根节点为叶子结点，直接返回1</li><li>如果不是叶子结点，返回左右子树中最大深度+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$ 递归调用的栈深度</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505100552861.png" alt="image-20220505100552861"></p><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn08xg/">验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 <code>root </code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。<br>节点的右子树只包含 <strong>大于</strong> 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="/tree1.jpg" alt="img"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/tree2.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中节点数目范围在<code>[1, 104] </code>内</p></li><li><p>$-2^{31} &lt;&#x3D; Node.val &lt;&#x3D; 2^{31} - 1$</p></li></ul><p><strong>题解</strong></p><p>将二叉搜索树的中序遍历存放在数组中，然后判断数组是否有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        dfs(root, path);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; path.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (path.get(i) &lt;= path.get(i-<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        dfs(root.left, path);<br>        path.add(root.val);<br>        dfs(root.right, path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505102952985-16517177946343.png" alt="image-20220505102952985"></p><p><strong>使用栈辅助实现二叉树的中序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">inorder</span> <span class="hljs-operator">=</span> -Double.MAX_VALUE;<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>              <span class="hljs-comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br>            <span class="hljs-keyword">if</span> (root.val &lt;= inorder) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            inorder = root.val;<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505103627497-16517181886724.png" alt="image-20220505103627497"></p><p><strong>递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> Long.MIN_VALUE, upper = Long.MAX_VALUE;<br>        <span class="hljs-keyword">return</span> dfs(root, lower, upper);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt;= lower || root.val &gt;= upper)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(root.left, lower, root.val) &amp;&amp; dfs(root.right, root.val, upper);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505104736338.png" alt="image-20220505104736338"></p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn7ihv/">对称二叉树</a></h3><p>给你一个二叉树的根节点 <code>root </code>， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="/symtree1.jpg" alt="img"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/symtree2.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中节点数目在范围<code>[1, 1000]</code>内</p></li><li><p><code>-100 &lt;= Node.val &lt;= 100</code></p></li></ul><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p><p><strong>题解</strong></p><p><strong>递归实现</strong></p><p>对称的二叉树可以看到是一个树的左右子树镜像对称，也就是判断两个子树是否镜像对称可以判断两棵树是否镜像，所以可以将判断二叉树对称简化为判断二叉树左右子树是否对称，设置两个指针，<code>p</code>和<code>q</code>指针，一开始都指向这棵树的根，然后<code>p</code>右移，<code>q</code>左移，<code>p</code>左移，<code>q</code>右移，每次检查当前<code>p</code>和<code>q</code>结点的值是否相等，如果相等再判断左右子树是否对称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505105820822.png" alt="image-20220505105820822"></p><p><strong>迭代的方式</strong></p><p>使用队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span> || p.val != q.val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <br>            queue.add(p.left);<br>            queue.add(q.right);<br><br>            queue.add(p.right);<br>            queue.add(q.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505110903493.png" alt="image-20220505110903493"></p><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnldjj/">二叉树的层序遍历</a></h3><p>给你二叉树的根节点 <code>root </code>，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><p><img src="/tree1-16517201816487.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 <code>[0, 2000] </code>内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>题解</strong></p><p><strong>使用栈来辅助完成二叉树的层序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                level.add(temp.val);<br>                <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-literal">null</span>) queue.add(temp.left);<br>                <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-literal">null</span>) queue.add(temp.right);<br>            &#125;<br>            ans.add(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505111606212.png" alt="image-20220505111606212"></p><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xninbt/">将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 <code>nums </code>，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="/btree1.jpg" alt="img"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></table></figure><p><img src="/btree2.jpg" alt="img"></p><p><strong>示例 2：</strong></p><p><img src="/btree.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,null,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums </code>按 严格递增 顺序排列</li></ul><p><strong>题解</strong></p><p>本来以为还需要进行左旋右旋这些操作来的，其实这一道题的解法可以直接将数组中间的值当做根节点，然后迭代建树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = helper(nums, l, mid - <span class="hljs-number">1</span>);<br>        root.right = helper(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220505113143917.png" alt="image-20220505113143917"></p><h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnumcr/">合并两个有序数组</a></h3><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1 </code>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1 </code>和 <code>nums2 </code>中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2 </code>到 <code>nums1 </code>中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1 </code>中。为了应对这种情况，<code>nums1 </code>的初始长度为 <code>m + n</code>，其中前<code>m</code>个元素表示应合并的元素，后<code>n</code>个元素为 <code>0 </code>，应忽略。<code>nums2 </code>的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br>解释：需要合并 <span class="hljs-comment">[1,2,3]</span> 和 <span class="hljs-comment">[2,5,6]</span> 。<br>合并结果是 <span class="hljs-comment">[1,2,2,3,5,6]</span> ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并 <span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[0]</span>, m = 0, nums2 = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并的数组是 <span class="hljs-comment">[]</span> 和 <span class="hljs-comment">[1]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p><p><strong>题解</strong></p><p>可以看到<code>nums1</code>数组长度为<code>n+m</code>，其中有<code>m</code>个元素，<code>n</code>个零，可以考虑从最大的开始查找，将最大的依次填在最末尾</p><p>这种方式并不会覆盖<code>nums1</code>中已经存在的元素，因为就算<code>nums2</code>中最小的元素也大于<code>nums1</code>中最大元素，也就是<code>nums2</code>中的<code>n</code>个全部放在末尾，也不会覆盖<code>nums1</code>中的元素，也就是末尾始终有足够的空位用于填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>, p2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cur;<br>        <span class="hljs-keyword">while</span>(p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1 == -<span class="hljs-number">1</span>)<br>                cur = nums2[p2--];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == -<span class="hljs-number">1</span>)<br>                cur = nums1[p1--];<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span> (nums1[p1] &lt; nums2[p2])<br>                    cur = nums2[p2--];<br>                <span class="hljs-keyword">else</span><br>                    cur = nums1[p1--];<br>            &#125;<br>            nums1[tail--] = cur;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506153500058.png" alt="image-20220506153500058"></p><h3 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnto1s/">第一个错误的版本</a></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有<code> n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version </code>是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：n = <span class="hljs-number">5</span>, bad = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>调用 isBadVersion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-literal">false</span> <br>调用 isBadVersion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5</span>)</span> -&gt;</span> <span class="hljs-literal">true</span> <br>调用 isBadVersion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>)</span> -&gt;</span> <span class="hljs-literal">true</span><br>所以，<span class="hljs-number">4</span> 是第一个错误的版本。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>, bad = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bad &lt;= n &lt;= 231 - 1</code></li></ul><p><strong>题解</strong></p><p>使用二分查找实现，注意临界条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="hljs-comment">      boolean isBadVersion(int version); */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">VersionControl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstBadVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = n;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (isBadVersion(mid))<br>                right = mid;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(log_2(n))$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这些是基本的动态规划题目</p><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn854d/">爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br><br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br><br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><p><strong>题解</strong></p><p>定义<code>dp[n]</code>为<code>n</code>阶台阶有多少种方法爬到，可以由<code>dp[n-1]+dp[n+2]</code>得到，并且易得<br>$$<br>dp[1]&#x3D;1 \<br>dp[2]&#x3D;2<br>$$<br>所以可以得到当前<code>n</code>阶台阶有多少种方法仅和前两个台阶多少种方法相关，可以定义两个变量分别表示前两个台阶的方法，进行递推计算得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, q = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            temp = q;<br>            q = p + q;<br>            p = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506155642458.png" alt="image-20220506155642458"></p><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn8fsh/">买卖股票的最佳时机</a></h3><p>给定一个数组 <code>prices </code>，它的第 <code>i </code>个元素 <code>prices[i] </code>表示一支给定股票第 <code>i </code>天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code> 0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解</strong></p><p>简单的来说要想获得当前股票价格最大的利润，也就是判断在当前日期之前最低的价格买入股票，然后计算两个差值，如果当前利润最高，就记为历史最高，所以需要一个变量记录前些时刻股票价格的最低值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre_low</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            res = Math.max(res, price - pre_low);<br>            pre_low = Math.min(pre_low, price);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506161331627.png" alt="image-20220506161331627"></p><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h3><p>难度简单</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><p><strong>题解</strong></p><p>定义 $f(i)$ 为以 $nums[i]$ 结尾的连续子数组的最大和，所以结果就是遍历求得<br>$$<br>\max_{i&#x3D;1}^n f(i)<br>$$<br>那么 $f(i)$ 如何求得，可以考虑对于 $nums[i]$ 是单独一段还是加入之前的连续子数组 $nums[i] + f(i-1)$，也就是<br>$$<br>f(i) &#x3D; \max(nums[i], nums[i] + f(i-1))<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            pre = Math.max(num, pre + num);<br>            res = Math.max(res, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506162653125.png" alt="image-20220506162653125"></p><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><p>难度中等2105收藏分享切换为英文接收动态反馈</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p><strong>题解</strong></p><p>对于第 <code>n</code> 个房间，可以考虑抢和不抢两种，那么定义第 <code>n</code> 间房屋偷到的金额为：<br>$$<br>dp[n] &#x3D; Math.max(nums[n] + dp[n-2], dp[n-1])<br>$$<br>其中初始条件为：<br>$$<br>dp[0] &#x3D; 0<br>dp[1] &#x3D; nums[1]<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> q;<br>            q = Math.max(nums[i] + p, q);<br>            p = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506164529132.png" alt="image-20220506164529132"></p><h2 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h2><p>这类问题通常要求你实现一个给定的类的接口，并可能涉及使用一种或多种数据结构。 这些问题对于提高数据结构是很好的练习。</p><h3 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a><a href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h3><p>难度中等</p><p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的。</p><p>实现 <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li><li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li><li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;Solution&quot;</span>, <span class="hljs-string">&quot;shuffle&quot;</span>, <span class="hljs-string">&quot;reset&quot;</span>, <span class="hljs-string">&quot;shuffle&quot;</span>]<br>[[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [], [], []]<br>输出<br>[null, [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]<br><br>解释<br><span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>solution.shuffle();    // 打乱数组 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 并返回结果。任何 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]的排列返回的概率应该相同。例如，返回 [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>solution.reset();      // 重设数组到它的初始状态 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] 。返回 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>solution.shuffle();    // 随机返回数组 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] 打乱后的结果。例如，返回 [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>-106 &lt;= nums[i] &lt;= 106</code></li><li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li><li>最多可以调用 <code>104</code> 次 <code>reset</code> 和 <code>shuffle</code></li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span>[] original;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-built_in">this</span>.original = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, original, <span class="hljs-number">0</span>, nums.length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reset() &#123;<br>        System.arraycopy(original, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, nums.length);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] shuffle() &#123;<br>        <span class="hljs-type">int</span>[] shuffled = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            list.add(nums[i]);<br>        &#125;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> random.nextInt(list.size());<br>            shuffled[i] = list.remove(j);<br>        &#125;<br>        System.arraycopy(shuffled, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, nums.length)<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506165325411.png" alt="image-20220506165325411"></p><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h3><p>难度简单1297收藏分享切换为英文接收动态反馈</p><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Deque&lt;Integer&gt; xStack;<br>    Deque&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        xStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack.push(Integer.MAX_VALUE);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        xStack.push(x);<br>        minStack.push(Math.min(minStack.peek(), x));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        xStack.pop();<br>        minStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> xStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506165637305.png" alt="image-20220506165637305"></p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a><a href="https://leetcode-cn.com/problems/fizz-buzz/">412. Fizz Buzz</a></h3><p>难度简单177收藏分享切换为英文接收动态反馈</p><p>给你一个整数 <code>n</code> ，找出从 <code>1</code> 到 <code>n</code> 各个整数的 Fizz Buzz 表示，并用字符串数组 <code>answer</code>（<strong>下标从 1 开始</strong>）返回结果，其中：</p><ul><li><code>answer[i] == &quot;FizzBuzz&quot;</code> 如果 <code>i</code> 同时是 <code>3</code> 和 <code>5</code> 的倍数。</li><li><code>answer[i] == &quot;Fizz&quot;</code> 如果 <code>i</code> 是 <code>3</code> 的倍数。</li><li><code>answer[i] == &quot;Buzz&quot;</code> 如果 <code>i</code> 是 <code>5</code> 的倍数。</li><li><code>answer[i] == i</code> （以字符串形式）如果上述条件全不满足。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">5</span><br>输出：[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;Buzz&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">15</span><br>输出：[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;Buzz&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>,<span class="hljs-string">&quot;Buzz&quot;</span>,<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>,<span class="hljs-string">&quot;13&quot;</span>,<span class="hljs-string">&quot;14&quot;</span>,<span class="hljs-string">&quot;FizzBuzz&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fizzBuzz</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)<br>                ans.add(<span class="hljs-string">&quot;FizzBuzz&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>                ans.add(<span class="hljs-string">&quot;Fizz&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)<br>                ans.add(<span class="hljs-string">&quot;Buzz&quot;</span>);<br>            <span class="hljs-keyword">else</span><br>                ans.add(String.valueOf(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$ 不算上返回结果的<code>List&lt;String&gt;</code></li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506170549759.png" alt="image-20220506170549759"></p><h3 id="204-计数质数-x3D-x3D-判断质数-x3D-x3D"><a href="#204-计数质数-x3D-x3D-判断质数-x3D-x3D" class="headerlink" title="204. 计数质数-&#x3D;&#x3D;判断质数&#x3D;&#x3D;"></a><a href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a>-&#x3D;&#x3D;判断质数&#x3D;&#x3D;</h3><p>难度中等883收藏分享切换为英文接收动态反馈</p><p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 10<br>输出：4<br>解释：小于<span class="hljs-number"> 10 </span>的质数一共有<span class="hljs-number"> 4 </span>个, 它们是 2, 3, 5,<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 106</code></li></ul><p><strong>题解</strong></p><p>一般使用<strong>埃氏筛</strong>算法</p><ul><li>初始化长度 <code>O(n)</code> 的标记数组，表示这个数组是否为质数。数组初始化所有的数都是质数.</li><li>从 2 开始将当前数字的倍数全都标记为合数。标记到 $\sqrt{n}$ 时停止即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] isPrim = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        Arrays.fill(isPrim, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 从 2 开始枚举到 sqrt(n)。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i * i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 如果当前是素数</span><br>            <span class="hljs-keyword">if</span> (isPrim[i]) &#123;<br>                <span class="hljs-comment">// 就把从 i*i 开始，i 的所有倍数都设置为 false。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; n; j+=i) &#123;<br>                    isPrim[j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isPrim[i]) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlog(log(n)))$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508194929288.png" alt="image-20220508194929288"></p><h3 id="326-3-的幂"><a href="#326-3-的幂" class="headerlink" title="326. 3 的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3 的幂</a></h3><p>难度简单252收藏分享切换为英文接收动态反馈</p><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3x</code></p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">27</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">9</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">45</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= n &lt;= 231 - 1</code></li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> != <span class="hljs-number">0</span> &amp;&amp; n != <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            n /= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(log_3(n))$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220506171945353.png" alt="image-20220506171945353"></p><h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h3><p>难度简单1861收藏分享切换为英文接收动态反馈</p><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">字符          数值<br><span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><br><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><br><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><br><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><br><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><br><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><br><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;III&quot;</span><br><span class="hljs-section">输出: 3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;IV&quot;</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;IX&quot;</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;LVIII&quot;</span><br><span class="hljs-section">输出: 58</span><br><span class="hljs-section">解释: L = 50, V= 5, III = 3.</span><br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;MCMXCIV&quot;</span><br><span class="hljs-section">输出: 1994</span><br><span class="hljs-section">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li><li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics </a>。</li></ul><p><strong>题解</strong></p><ul><li>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可</li><li>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    Map&lt;Character, Integer&gt; symbolValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-number">5</span>);<br>        put(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">10</span>);<br>        put(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">50</span>);<br>        put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">100</span>);<br>        put(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">500</span>);<br>        put(<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1000</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">romanToInt</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> symbolValues.get(s.charAt(i));<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="hljs-number">1</span>)))<br>                ans -= value;<br>            <span class="hljs-keyword">else</span><br>                ans += value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508212125663.png" alt="image-20220508212125663"></p><p>使用<code>switch-case</code>来转换罗马字符，时间复杂度和空间复杂度非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">romanToInt</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preNum</span> <span class="hljs-operator">=</span> getValue(s.charAt(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; s.length(); i ++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> getValue(s.charAt(i));<br>            <span class="hljs-keyword">if</span>(preNum &lt; num) &#123;<br>                sum -= preNum;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += preNum;<br>            &#125;<br>            preNum = num;<br>        &#125;<br>        sum += preNum;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">switch</span>(ch) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">500</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508195953309.png" alt="image-20220508195953309"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></h3><p>难度简单469收藏分享切换为英文接收动态反馈</p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">00000000000000000000000000001011</span><br>输出：<span class="hljs-number">3</span><br>解释：输入的二进制串 <span class="hljs-number">00000000000000000000000000001011</span> 中，共有三位为 &#x27;1&#x27;。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">00000000000000000000000010000000</span><br>输出：<span class="hljs-number">1</span><br>解释：输入的二进制串 <span class="hljs-number">00000000000000000000000010000000</span> 中，共有一位为 &#x27;1&#x27;。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串<span class="hljs-number"> 11111111111111111111111111111101 </span>中，共有<span class="hljs-number"> 31 </span>位为 &#x27;1&#x27;。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p><strong>进阶</strong>：</p><ul><li>如果多次调用这个函数，你将如何优化你的算法？</li></ul><p><strong>题解</strong></p><p>可以使用<code>n&amp;=n-1</code>将二进制位数的最高位<code>1</code>变为<code>0</code>，统计<code>n</code>变为零之前与的次数，返回次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= (n-<span class="hljs-number">1</span>);<br>            ++ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508201626903.png" alt="image-20220508201626903"></p><h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h3><p>难度简单598收藏分享切换为英文接收动态反馈</p><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">1</span>   (<span class="hljs-number">0 0 0 1</span>)<br><span class="hljs-number">4</span>   (<span class="hljs-number">0 1 0 0</span>)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：x </span>=<span class="hljs-string"> 3, y = 1</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= x, y &lt;= 231 - 1</code></li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> hammingWeight(x ^ y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= (n-<span class="hljs-number">1</span>);<br>            ++ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508202705604.png" alt="image-20220508202705604"></p><h3 id="190-颠倒二进制位-x3D-x3D-二进制位分治-x3D-x3D"><a href="#190-颠倒二进制位-x3D-x3D-二进制位分治-x3D-x3D" class="headerlink" title="190. 颠倒二进制位-&#x3D;&#x3D;二进制位分治&#x3D;&#x3D;"></a><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a>-&#x3D;&#x3D;二进制位分治&#x3D;&#x3D;</h3><p>难度简单531收藏分享切换为英文接收动态反馈</p><p>颠倒给定的 32 位无符号整数的二进制位。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">00000010100101000001111010011100</span><br>输出：<span class="hljs-number">964176192</span> (<span class="hljs-number">00111001011110000010100101000000</span>)<br>解释：输入的二进制串 <span class="hljs-number">00000010100101000001111010011100</span> 表示无符号整数 <span class="hljs-number">43261596</span>，<br>     因此返回 <span class="hljs-number">964176192</span>，其二进制表示形式为 <span class="hljs-number">00111001011110000010100101000000</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">11111111111111111111111111111101</span><br>输出：<span class="hljs-number">3221225471</span> (<span class="hljs-number">10111111111111111111111111111111</span>)<br>解释：输入的二进制串 <span class="hljs-number">11111111111111111111111111111101</span> 表示无符号整数 <span class="hljs-number">4294967293</span>，<br>     因此返回 <span class="hljs-number">3221225471</span> 其二进制表示形式为 <span class="hljs-number">10111111111111111111111111111111</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入是一个长度为 <code>32</code> 的二进制字符串</li></ul><p><strong>进阶</strong>: 如果多次调用这个函数，你将如何优化你的算法？</p><p><strong>题解</strong></p><p>二进制位分治</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x55555555</span>; <span class="hljs-comment">// 01010101010101010101010101010101</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x33333333</span>; <span class="hljs-comment">// 00110011001100110011001100110011</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0f0f0f0f</span>; <span class="hljs-comment">// 00001111000011110000111100001111</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M8</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x00ff00ff</span>; <span class="hljs-comment">// 00000000111111110000000011111111</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverseBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="hljs-number">1</span>;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="hljs-number">2</span>;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="hljs-number">4</span>;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">return</span> n &gt;&gt;&gt; <span class="hljs-number">16</span> | n &lt;&lt; <span class="hljs-number">16</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508203602158.png" alt="image-20220508203602158"></p><h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h3><p>难度简单751收藏分享切换为英文接收动态反馈</p><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: numRows = 5<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: numRows = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><p><strong>题解</strong></p><ul><li>第一行为<code>1</code></li><li>第二行为<code>1, 1</code></li><li>其余行开始和结尾都为<code>1</code>，该行其他位为前一行的对应列以及前一列数的和</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            temp.add(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                temp.add(ans.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>) + ans.get(i-<span class="hljs-number">1</span>).get(j));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>                temp.add(<span class="hljs-number">1</span>);<br>            ans.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508205956781.png" alt="image-20220508205956781"></p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><p>难度简单3235收藏分享切换为英文接收动态反馈</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;([)]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatched</span><span class="hljs-params">(<span class="hljs-type">char</span> c1, <span class="hljs-type">char</span>  c2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;]&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">(<span class="hljs-type">char</span> c1)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;(&#x27;</span> || c1 == <span class="hljs-string">&#x27;[&#x27;</span> || c1 == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] sarr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sarr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty() || isOpen(sarr[i])) &#123;<br>                stack.add(sarr[i]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isMatched(stack.peek(), sarr[i]))<br>                stack.pop();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stack.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508211244968.png" alt="image-20220508211244968"></p><h3 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h3><p>难度简单604收藏分享切换为英文接收动态反馈</p><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,0,1]</span><br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,3]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1]</span><br>输出：2<br>解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,2]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">9,6,4,2</span>,<span class="hljs-number">3,5,7,0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">8</span><br>解释：n = <span class="hljs-number">9</span>，因为有 <span class="hljs-number">9</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>] 内。<span class="hljs-number">8</span> 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：1<br>解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,1]</span> 内。1 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p><p><strong>题解</strong></p><p>简单的求和公式<br>$$<br>\sum_{i&#x3D;1}^n i &#x3D; \frac{n(n+1)}{2}<br>$$<br>直接求出总和，然后遍历<code>nums</code>数组，总和减去<code>nums</code>中每一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            ans -= num;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/leetcode-basic/image-20220508212043476.png" alt="image-20220508212043476"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识点</title>
    <link href="/2022/07/21/java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/21/java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><p>关于一些Java基础的知识点，主要用于面试快速复习</p><h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="Java语法规范"><a href="#Java语法规范" class="headerlink" title="Java语法规范"></a>Java语法规范</h3><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的&#x3D;&#x3D;首字母应该大写&#x3D;&#x3D;。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>FirstDemo</strong> 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li></ul><h3 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 <strong>-128（-2^7）</strong>；</li><li>最大值是 <strong>127（2^7-1）</strong>；</li><li>默认值是 <strong>0</strong>；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>例子：byte a &#x3D; 100，byte b &#x3D; -50。</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong>；</li><li>最大值是 <strong>32767（2^15 - 1）</strong>；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 <strong>0</strong>；</li><li>例子：short s &#x3D; 1000，short r &#x3D; -20000。</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 <strong>0</strong> ；</li><li>例子：int a &#x3D; 100000, int b &#x3D; -200000。</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 <strong>0L</strong>；</li><li>例子： long a &#x3D; 100000L，Long b &#x3D; -200000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是 <strong>0.0f</strong>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 &#x3D; 234.5f。</li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 <strong>0.0d</strong>；</li><li>例子：double d1 &#x3D; 123.4。</li></ul><p><strong>boolean：</strong></p><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true 和 false；</li><li>这种类型只作为一种标志来记录 true&#x2F;false 情况；</li><li>默认值是 <strong>false</strong>；</li><li>例子：boolean one &#x3D; true。</li></ul><p><strong>char：</strong></p><ul><li>char类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 <strong>\u0000</strong>（即为0）；</li><li>最大值是 <strong>\uffff</strong>（即为65,535）；</li><li>char 数据类型可以储存任何字符；</li><li>例子：char letter &#x3D; ‘A’;。</li></ul><p>对于数值类型的基本类型的取值范围，可以查看封装在对应包装类的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// byte  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：byte 二进制位数：&quot;</span> + Byte.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Byte&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;最小值：Byte.MIN_VALUE=&quot;</span> + Byte.MIN_VALUE);  <br>        System.out.println(<span class="hljs-string">&quot;最大值：Byte.MAX_VALUE=&quot;</span> + Byte.MAX_VALUE);  <br>        System.out.println();  <br><br>        <span class="hljs-comment">// short  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：short 二进制位数：&quot;</span> + Short.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Short&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;最小值：Short.MIN_VALUE=&quot;</span> + Short.MIN_VALUE);  <br>        System.out.println(<span class="hljs-string">&quot;最大值：Short.MAX_VALUE=&quot;</span> + Short.MAX_VALUE);  <br>        System.out.println();  <br><br>        <span class="hljs-comment">// int  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：int 二进制位数：&quot;</span> + Integer.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Integer&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;最小值：Integer.MIN_VALUE=&quot;</span> + Integer.MIN_VALUE);  <br>        System.out.println(<span class="hljs-string">&quot;最大值：Integer.MAX_VALUE=&quot;</span> + Integer.MAX_VALUE);  <br>        System.out.println();  <br><br>        <span class="hljs-comment">// long  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：long 二进制位数：&quot;</span> + Long.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Long&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;最小值：Long.MIN_VALUE=&quot;</span> + Long.MIN_VALUE);  <br>        System.out.println(<span class="hljs-string">&quot;最大值：Long.MAX_VALUE=&quot;</span> + Long.MAX_VALUE);  <br>        System.out.println();  <br><br>        <span class="hljs-comment">// float  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：float 二进制位数：&quot;</span> + Float.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Float&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;最小值：Float.MIN_VALUE=&quot;</span> + Float.MIN_VALUE);  <br>        System.out.println(<span class="hljs-string">&quot;最大值：Float.MAX_VALUE=&quot;</span> + Float.MAX_VALUE);  <br>        System.out.println();  <br><br>        <span class="hljs-comment">// double  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：double 二进制位数：&quot;</span> + Double.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Double&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;最小值：Double.MIN_VALUE=&quot;</span> + Double.MIN_VALUE);  <br>        System.out.println(<span class="hljs-string">&quot;最大值：Double.MAX_VALUE=&quot;</span> + Double.MAX_VALUE);  <br>        System.out.println();  <br><br>        <span class="hljs-comment">// char  </span><br>        System.out.println(<span class="hljs-string">&quot;基本类型：char 二进制位数：&quot;</span> + Character.SIZE);  <br>        System.out.println(<span class="hljs-string">&quot;包装类：java.lang.Character&quot;</span>);  <br>        <span class="hljs-comment">// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  </span><br>        System.out.println(<span class="hljs-string">&quot;最小值：Character.MIN_VALUE=&quot;</span>  <br>                + (<span class="hljs-type">int</span>) Character.MIN_VALUE);  <br>        <span class="hljs-comment">// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  </span><br>        System.out.println(<span class="hljs-string">&quot;最大值：Character.MAX_VALUE=&quot;</span>  <br>                + (<span class="hljs-type">int</span>) Character.MAX_VALUE);  <br>    &#125;  <br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本类型：byte 二进制位数：8<br>包装类：java.lang.Byte<br>最小值：Byte.MIN_VALUE=-128<br>最大值：Byte.MAX_VALUE=127<br><br>基本类型：short 二进制位数：16<br>包装类：java.lang.Short<br>最小值：Short.MIN_VALUE=-32768<br>最大值：Short.MAX_VALUE=32767<br><br>基本类型：int 二进制位数：32<br>包装类：java.lang.Integer<br>最小值：Integer.MIN_VALUE=-2147483648<br>最大值：Integer.MAX_VALUE=2147483647<br><br>基本类型：long 二进制位数：64<br>包装类：java.lang.Long<br>最小值：Long.MIN_VALUE=-9223372036854775808<br>最大值：Long.MAX_VALUE=9223372036854775807<br><br>基本类型：<span class="hljs-built_in">float</span> 二进制位数：32<br>包装类：java.lang.Float<br>最小值：Float.MIN_VALUE=1.4E-45<br>最大值：Float.MAX_VALUE=3.4028235E38<br><br>基本类型：double 二进制位数：64<br>包装类：java.lang.Double<br>最小值：Double.MIN_VALUE=4.9E-324<br>最大值：Double.MAX_VALUE=1.7976931348623157E308<br><br>基本类型：char 二进制位数：16<br>包装类：java.lang.Character<br>最小值：Character.MIN_VALUE=0<br>最大值：Character.MAX_VALUE=65535<br></code></pre></td></tr></table></figure><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li><code>Java</code>中，引用类型的变量类似于<code>C/C++</code>中的指针，引用类型指向一个对象</li><li>&#x3D;&#x3D;对象、数组都是引用数据类型&#x3D;&#x3D;</li><li>基本类型是值传递</li></ul><h3 id="Java常量"><a href="#Java常量" class="headerlink" title="Java常量"></a>Java常量</h3><ul><li><p>&#x3D;&#x3D;常量在程序运行时是不能被修改&#x3D;&#x3D;的。在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415927</span>;<br></code></pre></td></tr></table></figure></li><li><p>通常使用大写字母表示常量</p></li><li><p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。当使用常量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制, 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">decimal</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">octal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0144</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">hexa</span> <span class="hljs-operator">=</span>  <span class="hljs-number">0x64</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>数字转换一般是从&#x3D;&#x3D;低级到高级&#x3D;&#x3D;</p><p>数据类型转换必须满足如下规则：</p><ol><li>不能对boolean类型进行类型转换。</li><li>不能把对象类型转换成不相关类的对象。</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li><li>转换过程中可能导致溢出或损失精度，例如：</li></ol><p>&#x3D;&#x3D;自动类型转换&#x3D;&#x3D;：必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><p>&#x3D;&#x3D;强制类型转换&#x3D;&#x3D;：转换的类型必须是兼容的，一般是高转低，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>) val;<br></code></pre></td></tr></table></figure><h2 id="Java变量的类型"><a href="#Java变量的类型" class="headerlink" title="Java变量的类型"></a>Java变量的类型</h2><p>在Java语言中，所有的变量在使用前必须声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a, b, c;         <span class="hljs-comment">// 声明三个int型整数：a、 b、c</span><br><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, e = <span class="hljs-number">4</span>, f = <span class="hljs-number">5</span>; <span class="hljs-comment">// 声明三个整数并赋予初值</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;         <span class="hljs-comment">// 声明并初始化 z</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;nowcoder&quot;</span>;  <span class="hljs-comment">// 声明并初始化字符串 s</span><br><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// 声明了双精度浮点型变量 pi</span><br><span class="hljs-type">char</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;x&#x27;</span>;        <span class="hljs-comment">// 声明变量 x 的值是字符 &#x27;x&#x27;。</span><br></code></pre></td></tr></table></figure><p>Java语言支持的变量类型有：</p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> allClicks=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 类变量</span><br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;  <span class="hljs-comment">// 实例变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Java局部变量"><a href="#Java局部变量" class="headerlink" title="Java局部变量"></a>Java局部变量</h3><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>&#x3D;&#x3D;实例变量在对象创建的时候创建，在对象被销毁的时候销毁&#x3D;&#x3D;；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li><li>&#x3D;&#x3D;无论一个类创建了多少个对象，类只拥有类变量的一份拷贝&#x3D;&#x3D;。</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public&#x2F;private，final和static类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li><li>&#x3D;&#x3D;静态变量在第一次被访问时创建，在程序结束时销毁&#x3D;&#x3D;。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><p>Java语言主要分为两类修饰符：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><p>我们可以通过以下表来说明访问权限：</p><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同一包内</th><th align="center">子孙类(同一包)</th><th align="center">子孙类(不同包)</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center"><code>public</code></td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center"><code>protected</code></td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y&#x2F;N</td><td align="center">N</td></tr><tr><td align="center"><code>default</code></td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="center"><code>private</code></td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr></tbody></table><h2 id="Java-Scanner类"><a href="#Java-Scanner类" class="headerlink" title="Java Scanner类"></a>Java Scanner类</h2><p><code>next()</code>与<code>nextLine()</code>区别</p><p><code>next()</code></p><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，<code>next() </code>方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><code>next() </code>不能得到带有空格的字符串。</li></ul><p><code>nextLine()</code></p><ul><li>以<code>Enter</code>为结束符,也就是说 <code>nextLine()</code>方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul><p>如果要输入 <code>int </code>或 <code>float</code> 类型的数据，在 <code>Scanner </code>类中也有支持，但是在输入之前最好先使用 <code>hasNextXxx() </code>方法进行验证，再使用 <code>nextXxx() </code>来读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">// 从键盘接收数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>;<br>        System.out.print(<span class="hljs-string">&quot;输入整数：&quot;</span>);<br>        <span class="hljs-keyword">if</span> (scan.hasNextInt()) &#123;<br>            <span class="hljs-comment">// 判断输入的是否是整数</span><br>            i = scan.nextInt();<br>            <span class="hljs-comment">// 接收整数</span><br>            System.out.println(<span class="hljs-string">&quot;整数数据：&quot;</span> + i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 输入错误的信息</span><br>            System.out.println(<span class="hljs-string">&quot;输入的不是整数！&quot;</span>);<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;输入小数：&quot;</span>);<br>        <span class="hljs-keyword">if</span> (scan.hasNextFloat()) &#123;<br>            <span class="hljs-comment">// 判断输入的是否是小数</span><br>            f = scan.nextFloat();<br>            <span class="hljs-comment">// 接收小数</span><br>            System.out.println(<span class="hljs-string">&quot;小数数据：&quot;</span> + f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 输入错误的信息</span><br>            System.out.println(<span class="hljs-string">&quot;输入的不是小数！&quot;</span>);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h2><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为<code>static</code>类型。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在<code>Java</code>中，使用关键字<code>new</code>来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字<code>new</code>来创建一个对象。</li><li><strong>初始化</strong>：使用<code>new</code>创建对象时，会调用构造方法初始化对象。</li></ul><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><ul><li>一个源文件中只能有一个<code>public</code>类</li><li>一个源文件可以有多个非<code>public</code>类</li><li>源文件的名称应该和<code>public</code>类的类名保持一致。例如：源文件中<code>public</code>类的类名是<code>Employee</code>，那么源文件应该命名为<code>Employee.java</code>。</li><li>如果一个类定义在某个包中，那么<code>package</code>语句应该在源文件的首行。</li><li>如果源文件包含<code>import</code>语句，那么应该放在<code>package</code>语句和类定义之间。如果没有<code>package</code>语句，那么<code>import</code>语句应该在源文件中最前面。</li><li><code>import</code>语句和<code>package</code>语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><h2 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h2><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><p>封装的优点：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><h2 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h2><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <code>super</code>关键字调用父类的构造器并配以适当的参数列表。</p><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <code>super</code> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p><h2 id="Java重写与重载"><a href="#Java重写与重载" class="headerlink" title="Java重写与重载"></a>Java重写与重载</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写</strong></li><li>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法</li><li>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 <code>Exception </code>异常，因为 <code>Exception </code>是 <code>IOException </code>的父类，只能抛出 <code>IOException </code>的子类异常</li></ul><h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><ul><li>参数列表必须完全与被重写方法的相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载。</p><p><strong>重载规则:</strong></p><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><blockquote><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><ol><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ol></blockquote><h2 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力</p><p><strong>多态的优点</strong></p><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><p><strong>多态存在的三个必要条件</strong></p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><h2 id="Java抽象类"><a href="#Java抽象类" class="headerlink" title="Java抽象类"></a>Java抽象类</h2><p>在<code>Java</code>语言中使用<code>abstract class</code>来定义抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String address;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, String address, <span class="hljs-type">int</span> number)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Constructing an Employee&quot;</span>);<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.address = address;<br>      <span class="hljs-built_in">this</span>.number = number;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computePay</span><span class="hljs-params">()</span> &#123;<br>     System.out.println(<span class="hljs-string">&quot;Inside Employee computePay&quot;</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mailCheck</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Mailing a check to &quot;</span> + <span class="hljs-built_in">this</span>.name<br>       + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.address);<br>   &#125;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; &quot;</span> + address + <span class="hljs-string">&quot; &quot;</span> + number;<br>   &#125;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> address;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String newAddress)</span> &#123;<br>      address = newAddress;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> number;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们能通过一般的方法继承Employee类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary; <span class="hljs-comment">//Annual salary</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Salary</span><span class="hljs-params">(String name, String address, <span class="hljs-type">int</span> number, <span class="hljs-type">double</span> salary)</span> &#123;<br>       <span class="hljs-built_in">super</span>(name, address, number);<br>       setSalary(salary);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mailCheck</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;Within mailCheck of Salary class &quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;Mailing check to &quot;</span> + getName()<br>       + <span class="hljs-string">&quot; with salary &quot;</span> + salary);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> salary;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> newSalary)</span> &#123;<br>       <span class="hljs-keyword">if</span>(newSalary &gt;= <span class="hljs-number">0.0</span>) &#123;<br>          salary = newSalary;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computePay</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Computing salary pay for &quot;</span> + getName());<br>      <span class="hljs-keyword">return</span> salary/<span class="hljs-number">52</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p><code>abstract </code>关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String address;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computePay</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">//其余代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p>总结</p><blockquote><ul><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ul></blockquote><h2 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h2><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h2 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h2><p>为了更好地组织类，<code>Java</code> 提供了包机制，用于区别类名的命名空间</p><h3 id="package的目录结构"><a href="#package的目录结构" class="headerlink" title="package的目录结构"></a>package的目录结构</h3><p>类放在包中会有两种主要的结果：</p><ul><li>包名成为类名的一部分，正如我们前面讨论的一样。</li><li>包名必须与相应的字节码所在的目录结构相吻合。</li></ul><p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 <code>nowcoder.com</code>，所有的包名都以 <code>com.nowcoder </code>开头。包名中的每一个部分对应一个子目录。</p><p>类目录的绝对路径叫做 <strong>class path</strong>。设置在系统变量 <strong>CLASSPATH</strong> 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。</p><h3 id="设置-CLASSPATH-系统变量"><a href="#设置-CLASSPATH-系统变量" class="headerlink" title="设置 CLASSPATH 系统变量"></a>设置 CLASSPATH 系统变量</h3><p>用下面的命令显示当前的CLASSPATH变量：</p><ul><li>Windows 平台（DOS 命令行下）：<code>C:&gt; set CLASSPATH</code></li><li>UNIX 平台（Bourne shell 下）：# <code>echo $CLASSPATH</code></li></ul><p>删除当前CLASSPATH变量内容：</p><ul><li>Windows 平台（DOS 命令行下）：<code>C:&gt; set CLASSPATH=</code></li><li>UNIX 平台（Bourne shell 下）：# <code>unset CLASSPATH; export CLASSPATH</code></li></ul><p>设置CLASSPATH变量:</p><ul><li>Windows 平台（DOS 命令行下）： C:&gt; set CLASSPATH&#x3D;C:\users\jack\java\classes</li><li>UNIX 平台（Bourne shell 下）：# CLASSPATH&#x3D;&#x2F;home&#x2F;jack&#x2F;java&#x2F;classes; export CLASSPATH</li></ul><h1 id="面试常问问题"><a href="#面试常问问题" class="headerlink" title="面试常问问题"></a>面试常问问题</h1><h3 id="为什么Java代码可以实现一次编写、到处运行"><a href="#为什么Java代码可以实现一次编写、到处运行" class="headerlink" title="为什么Java代码可以实现一次编写、到处运行"></a>为什么Java代码可以实现一次编写、到处运行</h3><p>JVM（Java虚拟机）是Java跨平台的关键。</p><p>在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p><p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。</p><p><strong>注意事项</strong></p><ol><li>编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行；</li><li>跨平台的是Java程序、而不是JVM，JVM是用C&#x2F;C++开发的软件，不同平台下需要安装不同版本的JVM。</li></ol><h3 id="一个Java文件里可以有多个类吗（不含内部类）"><a href="#一个Java文件里可以有多个类吗（不含内部类）" class="headerlink" title="一个Java文件里可以有多个类吗（不含内部类）"></a>一个Java文件里可以有多个类吗（不含内部类）</h3><ol><li>一个java文件里可以有多个类，但最多只能有一个被public修饰的类；</li><li>如果这个java文件中包含public修饰的类，则这个类的名称必须和java文件名一致。</li></ol><h3 id="说一说你对Java访问权限的了解"><a href="#说一说你对Java访问权限的了解" class="headerlink" title="说一说你对Java访问权限的了解"></a>说一说你对Java访问权限的了解</h3><p>Java语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、default、protected、public，注意在不加任何修饰符时为default访问权限。</p><p>在修饰成员变量&#x2F;成员方法时，该成员的四种访问权限的含义如下：</p><ul><li>private：该成员可以被该类内部成员访问；</li><li>default：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；</li><li>protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问；</li><li>public：该成员可以被任意包下，任意类的成员进行访问。</li></ul><p>在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：</p><ul><li>default：该类可以被同一包下其他的类访问；</li><li>public：该类可以被任意包下，任意的类所访问。</li></ul><h3 id="介绍一下Java的数据类型"><a href="#介绍一下Java的数据类型" class="headerlink" title="介绍一下Java的数据类型"></a>介绍一下Java的数据类型</h3><p>分为两类：基本数据类型和引用数据类型</p><p>基本数据类型有8个，可以分为4个小类，分别是整数类型（byte&#x2F;short&#x2F;int&#x2F;long）、浮点类型（float&#x2F;double）、字符类型（char）、布尔类型（boolean）。其中，4个整数类型中，int类型最为常用。2个浮点类型中，double最为常用。另外，在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。</p><p>引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</p><p>对于基本数据类型，你需要了解每种类型所占据的内存空间，面试官可能会追问这类问题：</p><ul><li>byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。</li><li>short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。</li><li>int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。</li><li>long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。</li><li>float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。</li><li>double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。</li><li>char：2字节（16位），数据范围是 \u0000 ~ \uffff。</li><li>boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。</li></ul><blockquote><p>对于引用数据类型，需要了解JVM的内存分布情况，知道引用以及引用对象存放的位置</p></blockquote><h3 id="请介绍全局变量和局部变量的区别"><a href="#请介绍全局变量和局部变量的区别" class="headerlink" title="请介绍全局变量和局部变量的区别"></a>请介绍全局变量和局部变量的区别</h3><p>Java中的变量分为成员变量和局部变量，它们的区别如下：</p><p>成员变量：</p><ol><li>成员变量是在类的范围里定义的变量；</li><li>成员变量有默认初始值；</li><li>未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；</li><li>被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。</li></ol><p>局部变量：</p><ol><li>局部变量是在方法里定义的变量；</li><li>局部变量没有默认初始值；</li><li>局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。</li></ol><blockquote><p>Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量</p></blockquote><h3 id="实例变量的默认值"><a href="#实例变量的默认值" class="headerlink" title="实例变量的默认值"></a>实例变量的默认值</h3><p>实例变量若为引用数据类型，其默认值一律为null。若为基本数据类型，其默认值如下：</p><ul><li>byte：0</li><li>short：0</li><li>int：0</li><li>long：0L</li><li>float：0.0F</li><li>double：0.0</li><li>char：’\u0000’</li><li>boolean：false</li></ul><h3 id="为啥要有包装类？"><a href="#为啥要有包装类？" class="headerlink" title="为啥要有包装类？"></a>为啥要有包装类？</h3><p>Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</p><blockquote><p>Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。</p></blockquote><h3 id="说一说自动装箱、自动拆箱的应用场景"><a href="#说一说自动装箱、自动拆箱的应用场景" class="headerlink" title="说一说自动装箱、自动拆箱的应用场景"></a>说一说自动装箱、自动拆箱的应用场景</h3><p>自动装箱、自动拆箱是JDK1.5提供的功能。</p><p>&#x3D;&#x3D;自动装箱&#x3D;&#x3D;：可以把一个基本类型的数据直接赋值给对应的包装类型；</p><p>&#x3D;&#x3D;自动拆箱&#x3D;&#x3D;：可以把一个包装类型的对象直接赋值给对应的基本类型；</p><p>通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。</p><h3 id="如何对Integer和Double类型判断相等"><a href="#如何对Integer和Double类型判断相等" class="headerlink" title="如何对Integer和Double类型判断相等"></a>如何对Integer和Double类型判断相等</h3><p>Integer、Double不能直接进行比较，这包括：</p><ul><li>不能用&#x3D;&#x3D;进行直接比较，因为它们是不同的数据类型；</li><li>不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；</li><li>不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。</li></ul><p>整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为&#x3D;&#x3D;转换为相同的基本数据类型&#x3D;&#x3D;（如double），然后使用&#x3D;&#x3D;进行比较。</p><h3 id="int和Integer有什么区别，二者在做-x3D-x3D-运算时会得到什么结果？"><a href="#int和Integer有什么区别，二者在做-x3D-x3D-运算时会得到什么结果？" class="headerlink" title="int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？"></a>int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？</h3><p>int是基本数据类型，Integer是int的包装类。二者在做&#x3D;&#x3D;运算时，Integer会自动拆箱为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。</p><h3 id="说一说你对面向对象的理解"><a href="#说一说你对面向对象的理解" class="headerlink" title="说一说你对面向对象的理解"></a>说一说你对面向对象的理解</h3><p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p><blockquote><p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p><p>因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。</p><p>结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p><p>每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p><ul><li>设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。</li><li>适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高。</li></ul></blockquote><h3 id="面向对象的三大特征是什么？"><a href="#面向对象的三大特征是什么？" class="headerlink" title="面向对象的三大特征是什么？"></a>面向对象的三大特征是什么？</h3><p>面向对象的程序设计方法具有三个基本特征：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;。</p><ul><li>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；</li><li>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；</li><li>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。</li></ul><blockquote><p>抽象也是面向对象的重要部分，&#x3D;&#x3D;抽象就是忽略一个主题中与当前目标无关的那些方面&#x3D;&#x3D;，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p></blockquote><h3 id="封装的目的是什么，为什么要有封装？"><a href="#封装的目的是什么，为什么要有封装？" class="headerlink" title="封装的目的是什么，为什么要有封装？"></a>封装的目的是什么，为什么要有封装？</h3><p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，&#x3D;&#x3D;对象的状态信息都被隐藏在对象内部&#x3D;&#x3D;，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p><ul><li>隐藏类的实现细节；</li><li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li><li>可进行数据检查，从而有利于保证对象信息的完整性；</li><li>便于修改，提高代码的可维护性。</li></ul><blockquote><p>为了实现良好的封装，需要从两个方面考虑：</p><ul><li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；</li><li>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。</li></ul><p>封装实际上有两个方面的含义：&#x3D;&#x3D;把该隐藏的隐藏起来，把该暴露的暴露出来&#x3D;&#x3D;。这两个方面都需要通过使用Java提供的访问控制符来实现。例如：对于成员变量，尽量用<code>protected</code>修饰符，而对于允许外部访问的方法使用<code>public</code></p></blockquote><h3 id="说一说你对多态的理解"><a href="#说一说你对多态的理解" class="headerlink" title="说一说你对多态的理解"></a>说一说你对多态的理解</h3><p>因为子类其实是一种特殊的父类，因此Java允许&#x3D;&#x3D;把一个子类对象直接赋给一个父类引用变量&#x3D;&#x3D;，无须任何类型转换，或者被称为&#x3D;&#x3D;向上转型&#x3D;&#x3D;，向上转型由系统自动完成。</p><p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj &#x3D; new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p><blockquote><p>多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。</p><p>重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Car car)</span> &#123; ... &#125;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Bus bus)</span> &#123; ... &#125;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Truck truck)</span> &#123; ... &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Vehicle vehicle)</span> &#123; ... &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类Vehicle，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vehicle子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。</p></blockquote><h3 id="Java中的多态是怎么实现的？"><a href="#Java中的多态是怎么实现的？" class="headerlink" title="Java中的多态是怎么实现的？"></a>Java中的多态是怎么实现的？</h3><p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类&#x2F;接口的某些抽象方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>八股文</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java进阶知识点</title>
    <link href="/2022/07/21/java%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/07/21/java%E7%9B%B8%E5%85%B3/Java%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Java进阶简介"><a href="#Java进阶简介" class="headerlink" title="Java进阶简介"></a>Java进阶简介</h1><p>主要的知识点来自于黑马程序员的视频：<code>BV1TE41177mP</code></p><h1 id="day1-复习回顾、静态、继承、引用类型使用"><a href="#day1-复习回顾、静态、继承、引用类型使用" class="headerlink" title="day1-复习回顾、静态、继承、引用类型使用"></a>day1-复习回顾、静态、继承、引用类型使用</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><ul><li><p>类名的首字母应该大写，满足<strong>驼峰写法</strong></p></li><li><p>一个Java文件可以定义多个类。但是只有一个类是用<code>public</code>修饰，<code>public</code>修饰的类名必须称为<code>Java</code>文件名。</p></li><li><p>类中有且仅有5大成分（五大金刚）</p><ul><li><p><strong>成员变量Field</strong>：描述类或者对象的属性信息的。</p></li><li><p><strong>成员方法Method</strong>：描述类或者对象的行为的。</p></li><li><p><strong>构造器（构造方法,Constructor）</strong>: 初始化类的一个对象返回。</p><ul><li>有参构造器</li><li>无参构造器</li></ul></li><li><p><strong>代码块</strong></p></li><li><p><strong>内部类</strong></p></li></ul></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>面向对象的三大<strong>特征</strong>之一：<strong>封装，继承，多态</strong>。 </li><li>形成了规范，即使毫无意义还是会这样写代码！</li><li>合理隐藏，合理暴露。</li><li>封装的规范：成员变量私有，方法一般公开，提供成套的<code>getter</code>和<code>setter</code>方法暴露成员变量的取值和赋值，<code>public</code>修饰符</li><li>封装的作用：提高安全性，提高代码的组件化思想。</li><li>封装已经成为<code>Java</code>代码的规范，即使毫无意义，我们也要这样写代码（成员变量私有，方法公开）</li></ul><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ul><li><code>this</code>代表了当前对象的引用。</li><li><code>this</code>可以出现在构造器和方法中。</li><li><code>this</code>出现在构造器中代表构造器正在初始化的对象。</li><li><code>this</code>出现在方法中，哪个对象调用方法，<code>this</code>就代表哪个对象。</li><li><code>this</code>可以访问对象的成员变量，区分成员变量是局部的还是对象中的成员变量。</li></ul><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p><code>Java</code>是通过成员变量是否有<code>static</code>修饰来区分是类的还是属于对象的</p><ul><li>没有<code>static</code>修饰的方法和变量是属于每个对象的</li><li>有<code>static</code>修饰的方法和成员变量属于类的</li></ul><p>按照有无<code>static</code>修饰，成员变量和方法可以分为：</p><p><strong>成员变量</strong>：</p><ul><li><strong>静态成员变量</strong>（类变量）：有<code>static</code>修饰的成员变量称为静态成员变量也叫类变量，属于类本身的，<strong>直接用类名访问</strong>即可。</li><li><strong>实例成员变量</strong>：无<code>static</code>修饰的成员变量称为实例成员变量，属于类的每个对象的，<strong>必须用类的对象来访问</strong>。</li></ul><blockquote><ul><li>同一个类中访问静态成员变量可以省略类名不写</li><li>对象也可以访问静态成员变量，但是不推荐，静态成员变量属于类，如果用对象访问静态成员变量容易混淆</li></ul></blockquote><p>成员变量访问内存</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/javabasic/image-20220427112225577.png" alt="image-20220427112225577"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-comment">// 1.静态成员变量:有static修饰，属于类本身，直接用类名访问即可！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马&quot;</span>;<br>    <span class="hljs-comment">// 2.实例成员变量:无static修饰，属于类的对象的，必须用对象访问！</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.类名.静态成员变量</span><br>        System.out.println(Student.schoolName);<br>        <span class="hljs-comment">// 注意：同一个类中访问静态成员变量可以省略类名不写</span><br>        System.out.println(schoolName);<br><br>        <span class="hljs-comment">// 2.对象.实例成员变量</span><br>        <span class="hljs-comment">//System.out.println(Student.name); // 报错！</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        swk.name = <span class="hljs-string">&quot;孙悟空&quot;</span>;<br>        System.out.println(swk.name);<br>        System.out.println(swk.age);<br><br>        <span class="hljs-comment">// 3.对象.静态成员变量(不推荐)</span><br>        <span class="hljs-comment">// 静态成员变量属于类，直接用类名访问即可。</span><br>        System.out.println(swk.schoolName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>成员方法</strong>：</p><ul><li><strong>静态方法</strong>：有<code>static</code>修饰的成员方法称为静态方法也叫类方法，属于类本身的，<strong>直接用类名访问</strong>即可。</li><li><strong>实例方法</strong>：无<code>static</code>修饰的成员方法称为实例方法，属于类的每个对象的，<strong>必须用类的对象</strong>来访问。</li></ul><blockquote><ul><li>静态方法属于类，有static修饰，直接用类名访问即可。</li><li>实例方法属于对象，无static修饰，必须先创建对象，然后用对象来访问。</li><li>静态方法也可以被对象共享访问，但是不推荐，因为静态方法直接用类名访问即可。</li></ul></blockquote><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/javabasic/image-20220427143750503.png" alt="image-20220427143750503"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 0.实例成员变量。</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br><br>    <span class="hljs-comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我们都在天河区吉山村happy的学习Java!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;已经&quot;</span>+age+<span class="hljs-string">&quot;岁，在吃好吃的！！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// a.类名.静态方法</span><br>        Student.inAddr();<br>        <span class="hljs-comment">// 注意：在同一个类中访问静态成员可以省略类名不写！！</span><br>        inAddr();<br><br>        <span class="hljs-comment">// b.对象.实例方法</span><br>        <span class="hljs-comment">// Student.eat(); // 报错了！</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">zbj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        zbj.name = <span class="hljs-string">&quot;猪刚鬣&quot;</span>;<br>        zbj.age = <span class="hljs-number">1000</span>;<br>        zbj.eat();<br><br>        <span class="hljs-comment">// c.对象.静态方法(不推荐)</span><br>        zbj.inAddr();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>static</code>常考的八类题：</p><ul><li>实例方法是否可以直接访问实例成员变量？可以的，因为它们都属于对象。</li><li>实例方法是否可以直接访问静态成员变量？可以的，静态成员变量可以被共享访问。</li><li>实例方法是否可以直接访问实例方法? 可以的，实例方法和实例方法都属于对象。</li><li>实例方法是否可以直接访问静态方法？可以的，静态方法可以被共享访问！</li><li>静态方法是否可以直接访问实例变量？ 不可以的，实例变量必须用对象访问！！</li><li>静态方法是否可以直接访问静态变量？ 可以的，静态成员变量可以被共享访问。</li><li>静态方法是否可以直接访问实例方法? 不可以的，实例方法必须用对象访问！！</li><li>静态方法是否可以直接访问静态方法？可以的，静态方法可以被共享访问！！</li></ul><blockquote><p><strong>也就是说实例方法啥都可以访问，静态方法只能访问静态方法或者静态变量</strong></p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的概述"><a href="#继承的概述" class="headerlink" title="继承的概述"></a>继承的概述</h3><p>面向对象的三大特征：封装、继承和多态</p><p>继承是Java中一般到特殊的关系，是一种子类到父类的关系。例如：学生类继承了人类。  猫类继承了动物类。</p><p>被继承的类称为：父类&#x2F;超类。继承父类的类称为：子类</p><ul><li>继承可以<strong>提高代码的复用性</strong></li><li>子类直接继承父类，就可以直接使用父类的这些代码了（相同代码重复利用）</li></ul><p>子类继承了一个父类，子类就可以直接得到父类的属性（成员变量）和行为（方法）了。</p><h3 id="继承的例子"><a href="#继承的例子" class="headerlink" title="继承的例子"></a>继承的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>继承的优势可以把相同的代码定义在父类中，子类可以直接继承使用。</li><li>这样就可以<strong>提高代码的复用性</strong>：相同代码只需要在父类中写一次就可以了。</li></ul></blockquote><h3 id="子类不能继承父类的内容"><a href="#子类不能继承父类的内容" class="headerlink" title="子类不能继承父类的内容"></a>子类不能继承父类的内容</h3><ul><li>子类继承父类，子类就得到了父类的属性和行为。</li><li>但是并非所有父类的属性和行为等子类都可以继承。</li></ul><p><strong>子类不能继承父类的东西</strong>：子类不能继承父类的构造器，子类有自己的构造器。（没有争议的）</p><p>有争议的观点（拓展）：</p><p><strong>子类是否可以继承父类的私有成员</strong>（私有成员变量，私有成员方法）?</p><ul><li><strong>子类是可以继承父类的私有成员的，只是不能直接访问而已</strong>。</li><li>以后可以暴力去访问继承自父类的私有成员~~~</li></ul><p><strong>子类是否可以继承父类的静态成员？</strong></p><ul><li><strong>子类是不能继承父类的静态成员的</strong></li><li><strong>子类只是可以访问父类的静态成员</strong>，父类的静态成员只有一份可以被子类共享访问。</li><li><strong>共享并非继承</strong></li></ul><h3 id="成员变量的访问特点"><a href="#成员变量的访问特点" class="headerlink" title="成员变量的访问特点"></a>成员变量的访问特点</h3><p><strong>就近原则</strong>：子类有找子类，子类没有找父类，父类没有就报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物名称&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;子类名称&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;局部名称&quot;</span>;<br>        System.out.println(name); <span class="hljs-comment">// 局部名称</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">// 子类名称</span><br>        System.out.println(<span class="hljs-built_in">super</span>.name); <span class="hljs-comment">// 父类名称</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>this</code>代表了当前对象的引用，可以用于访问当前子类对象的成员变量。</li><li><code>super</code>代表了父类对象的引用，可以用于访问父类中的成员变量。</li></ul></blockquote><h3 id="成员方法的访问特点"><a href="#成员方法的访问特点" class="headerlink" title="成员方法的访问特点"></a>成员方法的访问特点</h3><p>就近原则：子类有找子类，子类没有找父类，父类没有就报错</p><p>子类对象优先使用子类已有的方法，也就是说父类的方法被重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat.run(); <span class="hljs-comment">// 子类的</span><br>        cat.eat(); <span class="hljs-comment">// 父类的</span><br>        <span class="hljs-comment">// cat.go(); // 报错！</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物可以跑~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃东西~~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐱跑的贼溜~~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类继承了父类，子类就得到了父类的某个方法。但是子类觉得父类的这个方法不好用或者无法满足自己的需求，子类重写一个与父类申明一样的方法来覆盖父类的该方法，子类的这个方法就进行了方法重写。</p><p>方法重写的校验注解： <code>@Override</code></p><ul><li><code>Java</code>建议在重写的方法上面加上一个<code>@Override</code>注解。</li><li>方法一旦加了这个注解，那<strong>就必须是成功重写父类</strong>的方法，否则报错！</li><li><code>Override</code>优势：<strong>可读性好，安全，优雅</strong></li></ul><p>方法重写的具体要求：</p><ul><li>子类重写方法的<strong>名称和形参列表必须与父类被重写方法一样</strong>。</li><li>子类重写方法的返回值类型申明要么与父类一样，要么比父类方法<strong>返回值类型范围更小</strong>。（以后再了解）</li><li>子类重写方法的修饰符权限应该与父类被重写方法的<strong>修饰符权限相同或者更大</strong>。（以后再了解）</li><li>子类重写方法申明抛出的异常应该与父类被重写方法申明抛出的<strong>异常一样或者范围更小</strong>！（以后再了解）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">// 进行了方法重写！！</span><br>    <span class="hljs-comment">// 子类重写方法的名称和形参列表必须与父类被重写方法一样</span><br>    <span class="hljs-comment">// 子类重写方法的返回值类型申明要么与父类一样，要么比父类方法返回值类型范围更小</span><br>    <span class="hljs-comment">// 子类重写方法的修饰符权限应该与父类被重写方法的修饰符权限相同或者更大</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐺跑的贼快~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物可以跑步~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>方法重写是子类重写一个与父类申明一样的方法覆盖父类的方法。</li><li>方法重写建议加上<code>@Override</code>注解。</li><li>方法重写的核心要求：方法名称形参列表必须与被重写方法一致！！</li><li>建议<strong>申明不变，重新实现</strong>。</li></ul></blockquote><p>调用父类被重写的方法使用<code>super</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SportMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;运动员跑的贼快~~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">super</span>.run(); <span class="hljs-comment">// 父类被重写的方法</span><br>        run(); <span class="hljs-comment">// 子类的</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;人会跑~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>super</code>可以用在子类的实例方法中调用父类被重写的方法</p></blockquote><p>静态方法和私有方法<strong>不可以</strong>被重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mac</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Computer</span>&#123;<br><span class="hljs-comment">//    @Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">// @Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;super test&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承后构造器的特点"><a href="#继承后构造器的特点" class="headerlink" title="继承后构造器的特点"></a>继承后构造器的特点</h3><p>子类的全部构造器默认一定会<strong>先访问父类的无参数构造器，再执行子类自己的构造器</strong>，主要的原因是</p><ul><li>子类的构造器的第一行默认有一个<code>super()</code>调用父类的无参数构造器，写不写都存在</li><li>子类继承父类，子类就得到了父类的属性和行为</li><li>当我们调用子类构造器初始化子类对象数据的时候，必须先调用父类构造器初始化继承自父类的属性和行为</li></ul><h3 id="super调用父类构造器"><a href="#super调用父类构造器" class="headerlink" title="super调用父类构造器"></a>super调用父类构造器</h3><p><code>super(...)</code>可以根据参数选择调用父类的某个构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monkey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Monkey</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">char</span> sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name , age , sex) ; <span class="hljs-comment">// 根据参数匹配调用父类构造器</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatBanana</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+getAge()+<span class="hljs-string">&quot;--&gt;&quot;</span>+getSex()+<span class="hljs-string">&quot;在吃🍌~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">char</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>super</code>调用父类构造器的内存分布图</p><p><img src="/imgs/image-20220505160400907.png" alt="image-20220505160400907"></p><h3 id="this和super关键字使用总结"><a href="#this和super关键字使用总结" class="headerlink" title="this和super关键字使用总结"></a>this和super关键字使用总结</h3><p><code>this</code>代表了当前对象的引用（继承中指代子类对象）：</p><ul><li><code>this</code> 子类成员变量</li><li><code>this</code>子类成员方法</li><li><code>this(...)</code> 可以根据参数匹配访问本类其他构造器</li></ul><p><code>super</code>代表了父类对象的引用（继承中指代了父类对象空间）</p><ul><li><code>super</code> 父类成员变量</li><li><code>super</code>父类的成员方法</li><li><code>super(...)</code>可以根据参数匹配访问父类的构造器</li></ul><p><code>this(...)</code>和<code>super(...)</code><strong>必须放在构造器的第一行</strong>，否则报错</p><p>所以<code>this(...)</code>和<code>super(...)</code><strong>不能同时出现在构造器中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> String schoolName ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name , <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-comment">// 借用兄弟构造器的功能！</span><br>        <span class="hljs-built_in">this</span>(name , age , <span class="hljs-string">&quot;黑马&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String schoolName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.schoolName = schoolName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSchoolName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> schoolName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSchoolName</span><span class="hljs-params">(String schoolName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.schoolName = schoolName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><ul><li><p><strong>单继承</strong>：一个类只能继承一个直接父类</p><ul><li><p>如果是多继承可能会出现类的<strong>二义性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> , B &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>        c.test(); <span class="hljs-comment">// 出现了类的二义性！所以Java不能多继承！！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>多层继承</strong>：一个类可以间接继承多个父类</p></li><li><p>一个类可以有多个子类</p></li><li><p>一个类要么默认继承了<code>Object</code>类，要么间接继承了<code>Object</code>类，<code>Object</code>类是<code>Java</code>的祖宗类</p></li></ul><h2 id="引用类型作为方法参数和返回值"><a href="#引用类型作为方法参数和返回值" class="headerlink" title="引用类型作为方法参数和返回值"></a>引用类型作为方法参数和返回值</h2><ul><li>除了基本数据类型都是引用数据类型</li><li>引用类型可以作为方法的参数类型和返回值类型</li><li>引用数据类型可以在一切可以使用类型的地方使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">jinMao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        go(jinMao);<br><br>        System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> createDog();<br>        dog.run();<br>    &#125;<br><br>    <span class="hljs-comment">// 引用类型作为方法的返回值:创建一个狗对象返回！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Dog <span class="hljs-title function_">createDog</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//        Dog taiDi = new Dog();</span><br><span class="hljs-comment">//        return taiDi;</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 引用类型作为方法参数: 提供一个方法让狗进入比赛~~~</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Dog a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;比赛开始。。。&quot;</span>);<br>        a.run();<br>        System.out.println(<span class="hljs-string">&quot;比赛结束。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐕跑的贼溜~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用类型作为成员变量的类型"><a href="#引用类型作为成员变量的类型" class="headerlink" title="引用类型作为成员变量的类型"></a>引用类型作为成员变量的类型</h2><p><code>Address.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String code;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String code, String name, <span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Student.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-comment">// 地址信息:复合类型。</span><br>    <span class="hljs-comment">// 引用类型作为成员变量的类型</span><br>    <span class="hljs-keyword">private</span> Address address;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day2-抽象类、接口、代码块、final、单例、枚举"><a href="#day2-抽象类、接口、代码块、final、单例、枚举" class="headerlink" title="day2-抽象类、接口、代码块、final、单例、枚举"></a>day2-抽象类、接口、代码块、final、单例、枚举</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="抽象类的概述"><a href="#抽象类的概述" class="headerlink" title="抽象类的概述"></a>抽象类的概述</h3><p>父类指导之类一定要完成某个功能，但是每个之类完成的情况是不一样的。子类以后也只会用自己重写的功能，那么父类的该功能就可以定义成抽象方法，子类重写调用自己的方法。所以父类的该功能就可以定义为抽象的方法。拥有冲向方法的类必须定义为抽象类。</p><blockquote><p><strong>抽象方法</strong>：没有方法体，只有方法签名，必须用<code>abstract</code>修饰的方法就是抽象方法。</p><p><strong>抽象类</strong>：拥有抽象方法的类必须定义成抽象类，必须用<code>abstract</code>修饰。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐺跑的贼贼溜~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象类：拥有了抽象方法的类必须定义成抽象类。抽象类必须加上abstract修饰。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">// 抽象方法：没有方法体，只有方法签名，必须加上abstract修饰。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类的使用"><a href="#抽象类的使用" class="headerlink" title="抽象类的使用"></a>抽象类的使用</h3><p>抽象类是为了被子类继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;班主任需要管理班级~~~~&quot;</span>);<br>    &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>     &#125;<br> &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Techer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;老师需要授课~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 员工（老师，班主任 ） 每个员工都要工作，但是工作内容不一样。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>一个类继承了抽象类，必须重写完抽象类的全部抽象方法，否则这个类必须定义成抽象类。</li><li>因为拥有抽象方法的类必须定义成抽象类。</li></ul></blockquote><h3 id="抽象类的特征"><a href="#抽象类的特征" class="headerlink" title="抽象类的特征"></a>抽象类的特征</h3><p>抽象类的特征是：<strong>有得有失</strong></p><ul><li>抽象类得到了拥有对象的能力</li><li>抽象类失去了创建对象的能力，即抽象类不能创建对象</li></ul><blockquote><p><strong>抽象类是否有构造器，是否可以创建对象</strong>，为什么?</p><p>抽象类作为类一定<strong>有构造器</strong>，而且必须有构造器。<strong>提供给子类继承后调用父类构造器</strong>使用的。</p><p>抽象类虽然有构造器，但是抽象类<strong>绝对不能创建对象</strong>。抽象类中可能存在抽象方法，<strong>抽象方法不能执行</strong>。抽象在学术上本身意味着不能实例化。</p></blockquote><h3 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h3><p>抽象类存在的意义有两点：</p><ul><li><strong>被继承</strong>：抽象类就是为了被子类继承，否则抽象类将毫无意义</li><li>抽象类体现的<strong>模板思想</strong>：部分实现，部分抽象，可以使用抽象类设计一个模板模式</li></ul><h3 id="抽象类设计模板模式"><a href="#抽象类设计模板模式" class="headerlink" title="抽象类设计模板模式"></a>抽象类设计模板模式</h3><p><strong>设计模式</strong>：就是前人或者软件行业在生产实战中发现的优秀软件设计架构和思想。后来者可以直接用这些架构或者思想就可以设计出优秀的软件，提高开发效率，提高软件可扩展性和可维护性。</p><p>模板设计模式就是一种经典的设计模式思想</p><p><strong>模板设计模型的作用</strong>：优化代码架构，提高代码的复用性，相同功能的重复代码无需重复书写。可以做到部分实现，部分抽象，抽象的东西交给使用模板的人重写实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">writeMain</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\t\t我爸就是好，有多好，做他儿子才能懂~~~&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">writeMain</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\t\t我爸爸很牛，我爸爸是马云，就是爽，很有钱~~~~&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 1.写一个模板类：代表了作文模板。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\t\t\t\t\t\t《我的爸爸》&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\t\t我的爸爸很牛逼，到底有多牛呢，请看如下说明：&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\t\t以上就是我的爸爸，简直太好了，下辈子还要做他儿子！&quot;</span>;<br><br>    <span class="hljs-comment">// 2.提供一个写作文方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(title);<br>        System.out.println(one);<br>        <span class="hljs-comment">// 正文：正文部分模板是不知道怎么写的！应该把正文部分定义成抽象方法</span><br>        <span class="hljs-comment">// 交给使用模板的子类重写！</span><br>        System.out.println(writeMain());<br>        System.out.println(last);<br>    &#125;<br><br>    <span class="hljs-comment">// 正文部分定义成抽象方法，交给子类重写！！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">writeMain</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类的注意事项"><a href="#抽象类的注意事项" class="headerlink" title="抽象类的注意事项"></a>抽象类的注意事项</h3><ol><li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<br>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></li><li><p>抽象类一定有而且是必须有构造器，是供子类创建对象时，初始化父类成员使用的。<br>理解：子类的构造器中，有默认的super()，需要访问父类构造器。</p></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类。</p></li><li><p>抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。<br>理解：抽象类中已经实现的是模板中确定的成员，<br>抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h3><p>接口体现的是规范思想，实现接口的子类必须重写完接口的全部抽象方法</p><p>接口是更加彻底的抽象，在JDK 1.8之前接口中只能是抽象方法和常量</p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 interface 接口名称&#123;<br><span class="hljs-comment">// 在JDK 1.8 之前接口中只能是抽象方法和常量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>成分研究（JDK 1.8之前）</p><ul><li><p>接口中抽象方法默认加上<code>public abstract</code>修饰，可以省略不写</p></li><li><p>常量是指有<code>public static final</code>修饰的成员变量，<strong>有且仅能被复制一次</strong>，值不能改变</p><p>常量名称规范要求全部大写，多个单词下划线连接</p><p>常量修饰<code>public static final</code>可以省略不写，默认会加上</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>     <span class="hljs-comment">// 2.常量</span><br>     <span class="hljs-comment">// 只有一份，在执行的过程中其值必须有，但是不能改变！</span><br>     <span class="hljs-comment">// 常量是public static final修饰</span><br>     <span class="hljs-comment">// 常量的名称建议字母全部大写，多个单词用“_”连接</span><br>     <span class="hljs-comment">// 在接口中常量可以省略public static final不写，默认会加上该三个修饰符！</span><br>     <span class="hljs-comment">//public static final String SCHOOL_NAME = &quot;黑马&quot;;</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马&quot;</span>;<br><br><br>     <span class="hljs-comment">// 1.抽象方法</span><br>     <span class="hljs-comment">// public abstract void run();</span><br>     <span class="hljs-comment">// 接口中的抽象方法默认会加上public abstract修饰,所以可以省略不写。</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口的基本实现"><a href="#接口的基本实现" class="headerlink" title="接口的基本实现"></a>接口的基本实现</h3><p>子类和父类是继承，实现类和接口是实现关系。接口是用来被类实现的，实现接口的类是实现类</p><p>子类–&gt;继承–&gt;父类</p><p>实现类–&gt;实现–&gt;接口</p><p>类实现接口的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 实现类名称 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3</span>,....&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现类 实现 SportMan接口</span><br><span class="hljs-comment">// 一个类实现接口必须重写完接口中全部抽象方法，否则这个类必须定义成抽象类！！</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PingPongMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SportMan</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PingPongMan</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;必须天天运动。正在🏃训练~~~‍&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;参加比赛中~~~‍&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个接口：表示运动员的规范</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SportMan</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 跑步</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 比赛得奖</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>接口的使命就是要求实现接口的类必须有<code>run()</code>和<code>win()</code>方法</li><li>接口可以多实现</li><li>一个类实现接口必须重写完接口中全部抽象方法，否则这个类必须定义成抽象类</li></ul></blockquote><h3 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h3><ul><li>类与类是单继承</li><li>类和接口是多实现</li></ul><p>一个类如果实现了多个接口，必须重写完全部接口中的全部抽象方法，否则这个类必须定义为抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PingPongMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SportMan</span> , Law&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rule</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Law</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rule</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SportMan</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口与接口的多继承"><a href="#接口与接口的多继承" class="headerlink" title="接口与接口的多继承"></a>接口与接口的多继承</h3><ul><li>类与类是单继承关系：一个类只能继承一个直接父类</li><li>类与接口是多继承关系：一个类可以同时实现多个接口</li><li>接口与接口是多继承关系：一个接口可以同时继承多个接口</li></ul><p>接口与接口的多继承，用一个接口合并多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PingPongMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SportMan</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rule</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goAbroad</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Food</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Law</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rule</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 接口与接口的多继承！</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SportMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Law</span> , Food &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goAbroad</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK1-8之后接口新增的方法"><a href="#JDK1-8之后接口新增的方法" class="headerlink" title="JDK1.8之后接口新增的方法"></a>JDK1.8之后接口新增的方法</h3><p>JDK1.8开始之后接口新增的三个方法，了解即可</p><ul><li><strong>默认方法</strong>就是之前写的实例方法<ul><li>必须用<code>default</code>修饰</li><li>默认会加<code>public</code>修饰</li><li>只能用接口的实现类的对象来调用</li></ul></li><li><strong>静态方法</strong><ul><li>可以直接加<code>static</code>修饰</li><li>默认会加<code>public</code>修饰</li><li>接口的静态方法只能用接口的类名称调用</li></ul></li><li><strong>私有方法</strong>    从JDK 1.9开始才支持的<ul><li>其实就是私有的实例方法，必须加<code>private</code>修饰</li><li>只能在<strong>本接口</strong>被其他的默认方法或者私有方法访问</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span><br>        <span class="hljs-type">PingPongMan</span> <span class="hljs-variable">zjk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PingPongMan</span>();<br>        zjk.run();<br>        zjk.work();<br><br>        <span class="hljs-comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span><br>        InterfaceJDK8.inAddr();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PingPongMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceJDK8</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;工作中。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceJDK8</span>&#123;<br>    <span class="hljs-comment">// 之前的抽象方法！！</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// a.默认方法（就是之前写的普通实例方法）</span><br>    <span class="hljs-comment">// 必须用接口的实现类的对象来调用。</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        go();<br>        System.out.println(<span class="hljs-string">&quot;开始跑步🏃‍~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// b.静态方法</span><br>    <span class="hljs-comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我们在吉山区~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span><br>    <span class="hljs-comment">//  -- 只能在本接口中被其他的默认方法或者私有方法访问。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口的注意事项"><a href="#接口的注意事项" class="headerlink" title="接口的注意事项"></a>接口的注意事项</h3><ul><li>如果实现了多个接口，多个接口存在同名的<strong>静态方法</strong>并不会从冲突，原因是只能通过各自接口方法访问各自静态方法</li><li>当一个类，即继承一个父类，又实现若干个接口时，父类的成员方法与接口中的默认方法重名时，之类<strong>就近</strong>选择执行父类的成员方法</li><li>当一个类实现多个接口时，多个接口存在同名的默认方法，实现类必须重写这个方法</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块按照有无<code>static</code>修饰可以分为：静态代码块、实例代码块</p><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块：必须用<code>static</code>修饰，必须放在类下，与类一起优先加载执行</p><p>静态代码块可以用于执行类的方法之前进行静态资源的初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String schoolName ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 静态代码块,属于类，与类一起加载一次!</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);<br>        <span class="hljs-comment">// 在静态代码块中进行静态资源的初始化操作</span><br>        schoolName = <span class="hljs-string">&quot;黑马&quot;</span>;<br>        lists.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;4&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;5&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(schoolName);<br>        System.out.println(lists);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h3><ul><li>实例代码块直接用<code>&#123;&#125;</code>括起来，无需<code>static</code>修饰</li><li>会和类的对象一起加载，每次创建对象的时候，实例代码块会被加载且自动执行一次</li><li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的，<strong>实例代码块属于对象</strong></li><li>实例代码块可以在创建对象之前进行实例资源的初始化操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeDemo02</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 实例代码块！属于对象！与对象一起加载!</span><br>    &#123;<br>        name = <span class="hljs-string">&quot;小手&quot;</span>;<br>        lists.add(<span class="hljs-string">&quot;东&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;南&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;西&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;北&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeDemo02</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeDemo02</span><span class="hljs-params">(String name)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CodeDemo02</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeDemo02</span>();<br>        System.out.println(c.name);<br>        System.out.println(c.lists);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeDemo02</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeDemo02</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="final关键词"><a href="#final关键词" class="headerlink" title="final关键词"></a>final关键词</h2><p><code>final</code>可以用于修饰类、方法、变量</p><ul><li><code>final</code>修饰类：类不能被继承了</li><li><code>final</code>修饰方法：方法不能被重写</li><li><code>final</code>修饰变量：变量有且仅能被赋值一次<ul><li>局部变量-只能赋值一次，不能在更改</li><li>实例成员变量<ul><li>显示初始化，在定义成员变量的时候立马赋值</li><li>实例代码块中赋值一次</li><li>构造器初始化，在构造器中赋值一次</li></ul></li></ul></li></ul><p><code>final</code>和<code>abstract</code>的关系</p><p>互斥关系，不能同时修饰类或者同时修饰方法</p><p><strong>常量</strong>：有<code>public static final</code>修饰，名称字母全部大写，多个单词用下划线连接</p><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p><strong>单例</strong>的意思是一个类永远只存在一个对象，不能创建多个对象</p><ul><li>开发中有很多类的对象我们只需要一个对象，例如虚拟机，任务管理器对象</li><li>对象越多越占内存，有时候只需要一个对象就可以实现业务，单例可以节约内存，提高性能</li></ul><h3 id="饿汉单例设计模式"><a href="#饿汉单例设计模式" class="headerlink" title="饿汉单例设计模式"></a>饿汉单例设计模式</h3><p>通过类获取单例对象的时候，对象已经提前准备做好了</p><p>设计步骤：</p><ul><li>定义一个类，把<strong>构造器私有</strong></li><li>定义一个静态变量存储一个对象</li><li>提供一个返回单例对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 饿汉单例设计模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton01</span>&#123;<br>    <span class="hljs-comment">//  b.定义一个静态变量存储一个对象( 在用类获取对象的时候，对象已经提前为你创建好了。)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton01</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton01</span>();<br>    <span class="hljs-comment">//  a.定义一个类，把构造器私有。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton01</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">// c.提供一个返回单例对象的方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton01 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉单例设计模式"><a href="#懒汉单例设计模式" class="headerlink" title="懒汉单例设计模式"></a>懒汉单例设计模式</h3><p>通过类获取单例对象的时候发现没有对象才会去创建一个对象</p><p>设计步骤：</p><ul><li>定义一个类，把<strong>构造器私有</strong></li><li>定义一个静态成员变量用于存储一个对象</li><li>提供一个返回单例对象的方法，判断对象不存在才创建一次，存在直接返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉单例设计模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton02</span>&#123;<br>    <span class="hljs-comment">//  b.定义一个静态变量存储一个对象(这里不能创建对象，需要的时候才创建，这里只是一个变量用于存储对象！)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton02  instance ;<br><br>    <span class="hljs-comment">//   a.定义一个类，把构造器私有。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton02</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">//  c.提供一个返回单例对象的方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton02 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 第一次来拿单例对象！需要创建一次对象，以后直接返回！！</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton02</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类的作用：是为了做信息的标志和信息分类</p><h3 id="枚举类基本语法"><a href="#枚举类基本语法" class="headerlink" title="枚举类基本语法"></a>枚举类基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">enum</span> 枚举名称&#123;<br><span class="hljs-comment">// 第一行罗列的必须的枚举类的对象名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sex</span>&#123;<br>    BOY , GIRL;<br>&#125;<br><br><span class="hljs-comment">// 枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>    SPRING , SUMMER , AUTUMN , WINTER;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类反编译以后的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Season</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;Season&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SPRING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SUMMER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">AUTUMN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">WINTER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Season[] values();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Season <span class="hljs-title function_">valueOf</span><span class="hljs-params">(java.lang.String)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举类的特点"><a href="#枚举类的特点" class="headerlink" title="枚举类的特点"></a>枚举类的特点</h3><ul><li>枚举类是<code>final</code>修饰的，不能被继承</li><li>枚举类默认继承了枚举类型<code>java.lang.Enum</code></li><li>枚举类的第一行罗列的是枚举类的对象，而且是用常量存储的</li><li>所以枚举类的第一行写的都是常量名称，默认存储了枚举对象</li><li>枚举类的构造器默认是私有的</li><li>枚举类相当于是多例设计模式</li></ul><blockquote><p><code>Java</code>建议做信息标志和信息分类应该使用<strong>枚举</strong>实现，比较优雅，可以实现可读性，而且入参受限制，不能乱输入</p></blockquote><h1 id="day3-多态、包、权限修饰符、内部类、object类、Date类"><a href="#day3-多态、包、权限修饰符、内部类、object类、Date类" class="headerlink" title="day3-多态、包、权限修饰符、内部类、object类、Date类"></a>day3-多态、包、权限修饰符、内部类、object类、Date类</h1><h2 id="多态-x3D-x3D-重点-x3D-x3D"><a href="#多态-x3D-x3D-重点-x3D-x3D" class="headerlink" title="多态&#x3D;&#x3D;重点&#x3D;&#x3D;"></a>多态&#x3D;&#x3D;重点&#x3D;&#x3D;</h2><p>面向对象的三大特征：封装、继承、多态</p><p>多态的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类/实现类构造器;<br>变量名.方法名();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolymorphicDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//  父类类型 对象名称 = new 子类构造器;</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">dlam</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        dlam.run(); <span class="hljs-comment">// 对于方法的调用：编译看左边，运行看右边。</span><br>        System.out.println(dlam.name); <span class="hljs-comment">// 对于变量的调用：编译看左边，运行看左边。</span><br><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">taiDi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        taiDi.run(); <span class="hljs-comment">// 对于方法的调用：编译看左边，运行看右边。</span><br>        System.out.println(taiDi.name); <span class="hljs-comment">// 对于变量的调用：编译看左边，运行看左边。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;🐶名称Dog&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐕跑的贼快~~~~！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;🐱名称Cat&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐱跑的飞快~~~~！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物名称Animal&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物跑！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多态的概念：</strong>同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p><p><strong>多态的识别技巧：</strong></p><ul><li>对于方法的调用：编译看左边，运行看右边</li><li>对于变量的调用：编译看左边，运行看左边</li></ul><p><strong>多态的使用前提</strong></p><ul><li>必须存在继承或者实现关系</li><li>必须存在父类类型的变量引用子类类型的对象</li><li>需要存在方法重写</li></ul><h3 id="多态的优劣势"><a href="#多态的优劣势" class="headerlink" title="多态的优劣势"></a>多态的优劣势</h3><p>优势：</p><ul><li>在多态形式下，右边对象可以实现组件化切换，业务功能也随之改变，便于扩展和维护。可以实现类与类之间的解耦</li><li>实际开发中，父类类型作为方法形式参数，传递之类对象给方法，可以传递一切子类对象进行方法的调用，更能体现出多态的扩展性与便利</li></ul><p>劣势：</p><ul><li><strong>多态形式下，不能直接调用子类特有的功能</strong>。编译看左边！！左边父类没有子类独有的功能，所以代码在编译阶段就直接报错了</li></ul><h3 id="引用类型自动类型转换"><a href="#引用类型自动类型转换" class="headerlink" title="引用类型自动类型转换"></a>引用类型自动类型转换</h3><p>基本数据类型的转换</p><ul><li>小范围类型的变量或者值可以<strong>直接赋值</strong>给大范围类型的变量。</li><li>大范围类型的变量或者值<strong>必须强制类型转换</strong>给小范围类型的变量。</li></ul><p>所以引用类型转换的思想也一样</p><p>子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p><blockquote><p>引用类型的自动类型转换并不能解决多态的劣势</p></blockquote><h3 id="引用类型的强制类型转换"><a href="#引用类型的强制类型转换" class="headerlink" title="引用类型的强制类型转换"></a>引用类型的强制类型转换</h3><p>父类类型的变量或者对象必须强制类型转换成子类类型的变量，否则报错!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型 变量名称 = (类型)(对象或者变量)<br></code></pre></td></tr></table></figure><p>注意：有<strong>继承&#x2F;实现关系</strong>的两个类型就可以进行强制类型转换，编译阶段一定不报错！但是运行阶段可能出现：类型转换<strong>异常</strong> <code>ClassCastException</code></p><p>Java建议在进行强制类型转换之前先判断变量的真实类型，再强制类型转换!</p><p><code>变量 instanceof 类型</code>： 判断前面的变量是否是后面的类型或者其子类类型才会返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolymorphicDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wolf</span>();<br>        a.run();<br>        <span class="hljs-comment">// a.catchSheep(); // 报错！</span><br><br>        <span class="hljs-comment">// 1.把动物类型的变量a 转换成 真实的狼类型</span><br>        <span class="hljs-type">Wolf</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> (Wolf) a;<br>        w.catchSheep();<br><br>        <span class="hljs-comment">// 2.多态下类型转换异常问题研究（重点）</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">//Wolf w1 = (Wolf) a1; // 编译阶段没有报错！在运行阶段出现ClassCastException类型转换成！</span><br><br>        <span class="hljs-keyword">if</span>(a1 <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>            <span class="hljs-type">Cat</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> (Cat) a1;<br>            c1.catchMouse();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a1 <span class="hljs-keyword">instanceof</span> Wolf)&#123;<br>            <span class="hljs-type">Wolf</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> (Wolf) a1;<br>            w1.catchSheep();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狼跑的飞快~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchSheep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐺抓🐏&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫跑的贼快~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;🐱抓🐀~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物可以跑~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态接口的综合案例"><a href="#多态接口的综合案例" class="headerlink" title="多态接口的综合案例"></a>多态接口的综合案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.买一部电脑</span><br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        <span class="hljs-comment">// 2.买一个鼠标</span><br>        <span class="hljs-type">USB</span> <span class="hljs-variable">xiaoMi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mouse</span>(<span class="hljs-string">&quot;小米鼠标&quot;</span>);<br>        c.install(xiaoMi);<br>        <span class="hljs-comment">// 3.买一个键盘</span><br>        <span class="hljs-type">KeyBoard</span> <span class="hljs-variable">sfy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyBoard</span>(<span class="hljs-string">&quot;双飞燕键盘&quot;</span>);<br>        c.install(sfy);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&#123;<br>    <span class="hljs-comment">// 提供一个安装USB设备的入口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">install</span><span class="hljs-params">(USB usb)</span>&#123;<br>        usb.connect();<br><br>        <span class="hljs-comment">// usb.dbclick();</span><br>        <span class="hljs-comment">// usb可能是鼠标，也可能键盘 .....</span><br>        <span class="hljs-keyword">if</span>(usb <span class="hljs-keyword">instanceof</span> Mouse)&#123;<br>            <span class="hljs-type">Mouse</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Mouse) usb;<br>            m.dbclick();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(usb <span class="hljs-keyword">instanceof</span> KeyBoard)&#123;<br>            <span class="hljs-type">KeyBoard</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (KeyBoard) usb;<br>            k.keyDown();<br>        &#125;<br><br>        usb.unconnect();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义2个USB设备：鼠标，键盘。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">USB</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mouse</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 双击</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dbclick</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;双击了，老铁，6666666~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;成功接入了设备~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unconnect</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;成功拔出了设备~~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBoard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">USB</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KeyBoard</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 按键</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyDown</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;写下了，来了，老弟~~记得点亮小💗💗....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;成功接入了设备~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unconnect</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;成功拔出了设备~~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义USB的规范，必须要完成接入和拔出的功能！！</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">USB</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">()</span>;    <span class="hljs-comment">// 接入</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unconnect</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 拔出</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是类的五大成分之一：成员变量、方法、构造器、代码块、内部类</p><p>内部类是定义在一个类里面的类</p><p>内部类有什么用</p><ul><li>可以提供更好的封装性</li><li>内部类有更多的权限修饰符</li><li>其封装有更多的控制</li><li>可以体现出组件的思想</li></ul><p>内部类的分类：</p><ul><li>静态内部类</li><li>实例内部类（成员内部类）</li><li>局部内部类</li><li><strong>匿名内部类</strong></li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>有<code>static</code>修饰，属于外部类本身，会加载一次</p><p>成分研究：</p><ul><li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li><li>所以它的特点与外部类是完全一样的，只是位置在别人里面而已。</li></ul><p>外部类&#x3D;宿主</p><p>内部类&#x3D;寄生</p><p>静态内部类的访问格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">外部类名称.内部类名称<br></code></pre></td></tr></table></figure><p>静态内部类创建对象的格式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">外部类名称.内部类名称 对象名称 <span class="hljs-operator">=</span> new 外部类名称.内部类构造器<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>静态内部类的访问拓展：</p><ul><li>静态内部类中是否可以直接访问外部类的静态成员?可以的，外部类的静态成员只有一份，可以被共享！</li><li>静态内部类中是否可以直接访问外部类的实例成员?不可以的,外部类的是成员必须用外部类对象访问！！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br>    <span class="hljs-comment">// 静态内部类：有static修饰，属于外部类本身，只会加载一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马&quot;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;--&gt;&quot;</span>+age+<span class="hljs-string">&quot;岁~&quot;</span>);<br>            System.out.println(age1);<br>            <span class="hljs-comment">//System.out.println(salary);</span><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例内部类（成员内部类）"><a href="#实例内部类（成员内部类）" class="headerlink" title="实例内部类（成员内部类）"></a>实例内部类（成员内部类）</h3><p>无<code>static</code>修饰的内部类，属于外部类的每个对象的，跟着对象一起加载的</p><p>实例内部类的成分特点：</p><ul><li>实例内部类中不能定义静态成员，其他都可以定义</li><li>可以定义常量</li></ul><p>实例内部类的访问格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">外部类名称.内部类名称<br></code></pre></td></tr></table></figure><p>创建对象的格式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">外部类名称.内部类名称 对象名称 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>外部类构造器.<span class="hljs-keyword">new</span> <span class="hljs-type"></span>内部构造器;<br></code></pre></td></tr></table></figure><p>拓展：</p><ul><li><p>实例内部类中是否可以直接访问外部类的静态成员</p><p>可以的，外部类的静态成员可以被共享访问</p></li><li><p>实例内部类中是否可以访问外部类的实例成员</p><p>可以的，实例内部类属于外部类对象，可以直接访问当前外部类对象的实例成员</p></li></ul><blockquote><p>实例内部类属于外部类对象，需要用外部类对象一起加载，<strong>实例内部类可以访问外部类的全部成员</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 实例内部类属于外部类对象。实例内部类的宿主是外部类对象！！</span><br>        Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        in.show();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 外部类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br>    <span class="hljs-comment">// 实例内部类：无static修饰，属于外部类的对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">private</span> String name ;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马&quot;</span>;<br>        <span class="hljs-comment">// 不能在实例内部类中定义静态成员！！！</span><br><span class="hljs-comment">//      public static String schoolName = &quot;黑马&quot;;</span><br><span class="hljs-comment">//      public static void test()&#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//      &#125;</span><br><br>        <span class="hljs-comment">// 实例方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;名称！&quot;</span>);<br>            System.out.println(age);<br>            System.out.println(salary);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在方法中，在构造器中，代码块中，for循环中定义的内部类，就是局部内部类。</p><p>局部内部类中的成分特点：</p><ul><li>只能定义实例成员，不能定义静态成员</li><li>可以定义常量的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>            <span class="hljs-keyword">private</span> String name;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            &#125;<br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> name;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>                <span class="hljs-built_in">this</span>.name = name;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.test();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>       &#125;<br><br>       <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>就是一个没有名字的局部内部类</p><p>匿名内部类目的是为了：简化代码，也是开发中常用的形式</p><p>匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名|抽象类|接口(形参)&#123;<br>方法重写。<br>&#125;<br></code></pre></td></tr></table></figure><p> 匿名内部类的特点：</p><ul><li>匿名内部类是一个没有名字的内部类</li><li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li><li>匿名内部类的对象的类型相当于是当前<code>new</code>的那个的类型的子类类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anonymity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;猫跑的贼溜~~&quot;</span>);<br>            &#125;<br>        &#125;;<br>        a.run();<br>        a.go();<br><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;狗跑的贼快~~~&quot;</span>);<br>            &#125;<br>        &#125;;<br>        a1.run();<br>        a.go();<br><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始go~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名内部类的使用形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anonymity02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">bozai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;老师🏊‍的贼溜~~~~&quot;</span>);<br>            &#125;<br>        &#125;;<br>        go(bozai);<br><br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">boniu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;波妞学生快乐的狗爬式~~~&quot;</span>);<br>            &#125;<br>        &#125;;<br>        go(boniu);<br><br>        go(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;波妞2学生快乐的狗爬式~~~&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 提供一个方法让全部角色进入比赛</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Swim s)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始。。。。&quot;</span>);<br>        s.swimming();<br>        System.out.println(<span class="hljs-string">&quot;结束。。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包和权限修饰符"><a href="#包和权限修饰符" class="headerlink" title="包和权限修饰符"></a>包和权限修饰符</h2><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>分门别类的管理各种不同的技术。</li><li>企业的代码必须用包区分。便于管理技术，扩展技术，阅读技术。</li></ul><p>定义包的格式：</p><p><code>package 包名;</code></p><p>必须放在类名的最上面<br>一般工具已经帮我们做好了</p><p>包名的命名规范：</p><ul><li>一般是公司域名的倒写+技术名称：</li><li><a href="http://www.itheima.com/">http://www.itheima.com</a> &#x3D;&gt; com.itheima.技术名称</li><li>包名建议全部用英文，多个单词用”.“连接，必须是合法标识符，不能用关键字</li></ul><p>注意</p><ul><li>相同包下的类可以直接访问</li><li>不同包下的类必须导包,才可以使用</li><li>导包格式：<code>import 包名.类名;</code></li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>权限修饰符：有四种（<code>private </code>-&gt; <code>default</code>-&gt; <code>protected </code>- &gt; <code>public</code> ）</p><p>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制!</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/javabasic/image-20220525204748483.png" alt="image-20220525204748483"></p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><code>Object</code>类是Java中的祖宗类</p><ul><li>一个类要么默认继承了<code>Object</code>类，要么间接继承了<code>Object</code>类</li><li><code>Object</code>类的方法是一切子类都可以直接使用的，所以我们要学习<code>Object</code>类的方法。</li></ul><p><code>Object</code>类的常用方法：</p><ul><li><p><code>public String toString():</code></p><ul><li><p>默认是返回当前对象在堆内存中的地址信息</p><p><code>com.itheima._12Object类的详细使用.Student@735b478</code></p></li><li><p>默认的地址信息格式：类的全限名@内存地址</p></li><li><p>直接输出对象名称，默认会调用toString()方法，所以直接输出对象可以省略toString()不写。</p></li><li><p>实际开发中直接输出对象，输出对象的地址其实是没有意义的。</p></li><li><p>所以<code>toString</code>方法存在的意义是为了被子类重写，以便能够返回对象的数据内容输出。因为实际开发中我们输出对象更多的时候是希望看到对象的数据内容信息</p></li></ul></li></ul><blockquote><ul><li>开发中如果希望输出对象看到对象的内容，只需要重写<code>toString()</code>方法即可</li><li>所以<code>toString</code>方法存在的意义是为了被子类重写</li></ul></blockquote><ul><li><code>public boolean equals(Object o)</code><ul><li>默认是比较两个对象的地址是否相同。相同返回<code>true</code>，反之</li><li>直接比较两个对象的地址是否相同完全可以用<code>==</code>替代<code>equals</code>，所以<code>equals</code>存在的意义是为了被子类重写，以便程序员可以自己来定制比较规则</li></ul></li></ul><p>只要两个对象的内容一样，我们就认为他们是相等的。</p><blockquote><p><code>equals</code>存在的意义是为了被子类重写，以便程序员自己来定制比较规则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || <span class="hljs-built_in">this</span>.getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp;<br>                sex == student.sex &amp;&amp;<br>                Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写Object的toString()以便返回对象的内容数据</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, sex=&quot;</span> + sex +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>idea可以自动生成<code>equals()</code>和<code>toString()</code>，直接按下快捷键<code>ALT+INSERT</code>，选择<code>generate</code>即可</p></blockquote><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><ul><li><code>Objects</code>类与<code>Object</code>还是继承关系</li><li><code>Objects</code>类是从JDK 1.7开始之后才有的。</li></ul><p><code>Objects</code>的方法：</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code></p><ul><li><p>比较两个对象的</p></li><li><p>底层进行非空判断，从而可以<strong>避免空指针异常</strong>。更安全，推荐使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br><span class="hljs-keyword">return</span> a == b || a != <span class="hljs-literal">null</span> &amp;&amp; a.equals(b);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>public static boolean isNull(Object obj)</code></p><p>判断变量是否为<code>null</code>,为<code>null</code>返回<code>true</code>, 反之<code>false</code></p></li></ul></li></ul><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p>Java是面向对象的，会用一个类代表一个事物</p><p><code>Date</code>类在Java中代表的是系统当前此刻日期时间对象。</p><p><code>Date</code>类：</p><p>包：<code>java.util.Date</code></p><ul><li>构造器：<br><code>public Date()</code> 创建当前系统的此刻日期时间对象。<br><code>public Date(long time)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// a.创建一个日期对象代表了系统此刻日期时间对象</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<br><br>        <span class="hljs-comment">// b.拿当前日期对象的时间毫秒值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> d.getTime();<br>        System.out.println(time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>方法</p><p><code>public long getTime()</code>: 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来走过的总的毫秒数。</p></li></ul><p>时间记录的两种方式：<br><code>Date</code>日期对象。<br>时间毫秒值：从1970-01-01 00:00:00开始走到此刻的总的毫秒值。 1s &#x3D; 1000ms</p><p>小结：</p><ul><li><code>Date</code>可以代表系统当前此刻日期时间对象。</li><li>时间记录的两种方式：<ul><li><code>Date</code>日期对象。</li><li>时间毫秒值：从1970-01-01 00:00:00开始走到此刻的总的毫秒值。 1s &#x3D; 1000ms</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.拿到此刻日期时间对象的毫秒值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1000000</span> ; i++ )&#123;<br>            System.out.println(<span class="hljs-string">&quot;输出：&quot;</span>+i);<br>        &#125;<br>        <span class="hljs-comment">// 2.拿到此刻日期时间对象的毫秒值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>        System.out.println( (endTime - startTime) / <span class="hljs-number">1000.0</span> +<span class="hljs-string">&quot;s&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Date</code>类的有参数构造器的使用。</p><p>构造器：</p><ul><li><code>public Date()</code>:创建当前系统的此刻日期时间对象。</li><li><code>public Date(long time)</code>:把时间毫秒值转换成日期对象。</li></ul><p>流程</p><ul><li><code>Date</code>日期对象 -&gt;<code> getTime()</code> -&gt; 时间毫秒值</li><li>时间毫秒值 -&gt;<code> new Date(时间毫秒值)</code> -&gt; <code>Date</code>日期对象</li></ul><h1 id="day4-常用API、正则表达式、泛型、Collection集合API"><a href="#day4-常用API、正则表达式、泛型、Collection集合API" class="headerlink" title="day4-常用API、正则表达式、泛型、Collection集合API"></a>day4-常用API、正则表达式、泛型、Collection集合API</h1><h2 id="第一章-DateFormat类"><a href="#第一章-DateFormat类" class="headerlink" title="第一章 DateFormat类"></a>第一章 DateFormat类</h2><p>简单日期格式化类<code>SimpleDateFormat</code>可以把日期对象格式化成我们喜欢的时间形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.得到此刻日期对象</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(d);<br><br><span class="hljs-comment">// 2.创建一个简单日期格式化对象负责格式化日期对象</span><br><span class="hljs-comment">// 注意：参数是之间的格式。</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br><br><span class="hljs-comment">// 3.开始调用方法格式化时间得到格式化的字符串时间形式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br>System.out.println(rs);<br></code></pre></td></tr></table></figure><p>也可以直接格式化时间毫秒值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.问121s后的时间是多少。格式化输出。</span><br><span class="hljs-comment">// a.得到此刻日期对象</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(date);<br><br><span class="hljs-comment">// b.得到当前时间的时间毫秒值</span><br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> date.getTime();<br>time += <span class="hljs-number">121</span> * <span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// c.格式化时间毫秒值</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br>System.out.println(sdf.format(time));<br></code></pre></td></tr></table></figure><p>简单日期格式化类<code>SimpleDateFormat</code>解析字符串时间成为日期对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// a.定义一个字符串时间</span><br><span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2019-11-04 09:30:30&quot;</span>;<br><br><span class="hljs-comment">// b.把字符串的时间解析成Date日期对象 。（重点）</span><br><span class="hljs-comment">// 1.创建一个简单日期格式化对象负责解析字符串的时间成为日期对象</span><br><span class="hljs-comment">// 注意：参数必须与被解析的时间的格式完全一致，否则执行报错！！</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-comment">// 2.开始解析成日期对象</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">newDate</span> <span class="hljs-operator">=</span> sdf.parse(date);<br><br><span class="hljs-comment">// c.得到日期对象的时间毫秒值 + 往后走 1天15小时，30分29s</span><br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> newDate.getTime() + (<span class="hljs-number">24L</span> *<span class="hljs-number">60</span>*<span class="hljs-number">60</span> + <span class="hljs-number">15</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> + <span class="hljs-number">30</span>*<span class="hljs-number">60</span> + <span class="hljs-number">29</span>) * <span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// d.把时间毫秒值格式化成喜欢的字符串的时间形式!</span><br>System.out.println(sdf.format(time));<br></code></pre></td></tr></table></figure><h2 id="第二章-Calendar类"><a href="#第二章-Calendar类" class="headerlink" title="第二章 Calendar类"></a>第二章 Calendar类</h2><p><code>Calendar</code>代表了系统此刻日期对应的日历对象。</p><p><code>Calendar</code>是一个抽象类，不能直接创建对象。</p><p><code>Calendar</code>日历类创建日历对象的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">rightNow</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br></code></pre></td></tr></table></figure><p><code>Calendar</code>的方法：</p><ul><li><code>public static Calendar getInstance()</code>: 返回一个日历类的对象。</li><li><code>public int get(int field)</code>：取日期中的某个字段信息。</li><li><code>public void set(int field,int value)</code>：修改日历的某个字段信息。</li><li><code>public void add(int field,int amount)</code>：为某个字段增加&#x2F;减少指定的值</li><li><code>public final Date getTime()</code>: 拿到此刻日期对象。</li><li><code>public long getTimeInMillis()</code>: 拿到此刻时间毫秒值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.通过调用日历类的静态方法getInstance得到一个当前此刻日期对象对应的日历对象。</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">rightNow</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(rightNow);<br><br><span class="hljs-comment">// 2.获取年：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> rightNow.get(Calendar.YEAR);<br>System.out.println(year);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> rightNow.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<br>System.out.println(mm);<br><br><span class="hljs-comment">// 3.一年中的第几天: 308</span><br><span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);<br>System.out.println(days);<br><br><span class="hljs-comment">// 4.修改日历的信息</span><br><span class="hljs-comment">//rightNow.set(Calendar.YEAR , 2099);</span><br><span class="hljs-comment">//System.out.println(rightNow.get(Calendar.YEAR));</span><br><br><span class="hljs-comment">// 5.日历可以得到此刻日期对象。</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> rightNow.getTime();<br>System.out.println(d);<br><br><span class="hljs-comment">// 6.此刻时间毫秒值</span><br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> rightNow.getTimeInMillis();<br>System.out.println(time);<br><br><span class="hljs-comment">// 7.请问701天  15小时后是哪个日期</span><br><span class="hljs-comment">// 让日历的一年中的第几天往后走 701天！</span><br>rightNow.add(Calendar.DAY_OF_YEAR , <span class="hljs-number">701</span>);<br>rightNow.add(Calendar.HOUR , <span class="hljs-number">15</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> rightNow.getTimeInMillis();<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br>System.out.println(sdf.format(time1));<br></code></pre></td></tr></table></figure><h2 id="第三章-Math类"><a href="#第三章-Math类" class="headerlink" title="第三章 Math类"></a>第三章 Math类</h2><ul><li><code>Math</code>用于做数学运算</li><li><code>Math</code>类中的方法全部是静态方法，直接用类名调用即可。</li></ul><p>常用方法</p><ul><li><code>public static int abs(int a)</code>                  获取参数a的绝对值：</li><li><code>public static double ceil(double a) </code>          向上取整</li><li><code>public static double floor(double a)</code>     向下取整</li><li><code>public static double pow(double a, double b) </code> 获取a的b次幂        </li><li><code>public static long round(double a)</code>         四舍五入取整</li></ul><h2 id="第四章-System类"><a href="#第四章-System类" class="headerlink" title="第四章 System类"></a>第四章 System类</h2><p><code>System</code>系统类的使用，<code>System</code>代表当前系统</p><p>静态方法：</p><ul><li><code>public static void exit(int status)</code>:终止JVM虚拟机，非0是异常终止。</li><li><code>public static long currentTimeMillis()</code>:获取当前系统此刻时间毫秒值。</li><li>可以做数组的拷贝。<br><code>arraycopy(Object var0, int var1, Object var2, int var3, int var4);</code><ul><li>参数一：原数组</li><li>参数二：从原数组的哪个位置开始赋值。</li><li>参数三：目标数组</li><li>参数四：赋值到目标数组的哪个位置</li><li>参数五：赋值几个。</li></ul></li></ul><h2 id="第五章-BigDecimal类"><a href="#第五章-BigDecimal类" class="headerlink" title="第五章 BigDecimal类"></a>第五章 BigDecimal类</h2><p><code>BigDecimal</code>大数据类</p><ul><li>浮点型运算的时候直接+  * &#x2F; 可能会出现数据失真（精度问题）</li><li><code>BigDecimal</code>可以解决浮点型运算数据失真的问题</li></ul><p>包：<code>java.math.</code><br>创建对象的方式（最好的方式：）<br>      <code>public static BigDecimal valueOf(double val)</code> :包装浮点数成为大数据对象。<br>方法声明</p><ul><li><code>public BigDecimal add(BigDecimal value)</code>       加法运算</li><li><code>public BigDecimal subtract(BigDecimal value)</code>  减法运算 </li><li><code>public BigDecimal multiply(BigDecimal value) </code> 乘法运算 </li><li><code>public BigDecimal divide(BigDecimal value)</code>    除法运算</li><li><code>public double doubleValue()</code>     把<code>BigDecimal</code>转换成<code>double</code>类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.1</span> ;<br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span> ;<br><span class="hljs-comment">// 1.把浮点数转换成大数据对象运算</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(a);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(b);<br><span class="hljs-comment">//BigDecimal c1 = a1.add(b1);  // 加法</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> a1.divide(b1); <span class="hljs-comment">// 除法</span><br>System.out.println(c1);<br><br><span class="hljs-comment">// 结果可能需要继续使用!!!</span><br><span class="hljs-comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span><br><span class="hljs-type">double</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> c1.doubleValue();<br>System.out.println(rs);<br></code></pre></td></tr></table></figure><h2 id="第六章-包装类"><a href="#第六章-包装类" class="headerlink" title="第六章 包装类"></a>第六章 包装类</h2><p><code>Java</code>认为一切皆对象。引用数据类型就是对象了</p><p>但是在<code>Java中8</code>基本数据类型不是对象，只是表示一种数据的类型形式,这8种数据类型显得很突兀</p><p><code>Java</code>为了一切皆对象的思想统一，把8种基本数据类型转换成对应的类，这个类称为基本数据类型的包装类。</p><p>基本数据类型                    包装类（引用数据类型）<br>     byte                      Byte<br>     short                     Short<br>     int                       Integer(特殊)<br>     long                      Long</p><p>​     float                     Float<br>​     double                    Double<br>​     char                      Character(特殊)<br>​     boolean                   Boolean</p><ul><li>自动装箱：可以直接把基本数据类型的值或者变量赋值给包装类</li><li>自动拆箱：可以把包装类的变量直接赋值给基本数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span> ;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span> ;  <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> a ;   <span class="hljs-comment">// 自动装箱</span><br><br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">99.9</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">99.9</span>; <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">Double</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> b ;   <span class="hljs-comment">// 自动装箱</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span> ;<br><span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> c ;      <span class="hljs-comment">// 自动拆箱</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 引用数据类型的默认值可以为null</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">12</span>);  <span class="hljs-comment">// 手工装箱！</span><br><span class="hljs-comment">// Integer it1 = new Integer(12); // 手工装箱！</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">it2</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">it3</span> <span class="hljs-operator">=</span> <span class="hljs-number">111</span> ;<br><span class="hljs-type">int</span> <span class="hljs-variable">it33</span> <span class="hljs-operator">=</span> it3.intValue(); <span class="hljs-comment">// 手工拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">it333</span> <span class="hljs-operator">=</span> it3;<br></code></pre></td></tr></table></figure><ul><li><p>Java为包装类做了一些特殊功能，以便程序员使用</p></li><li><p>包装类作为类首先拥有了<code>Object</code>类的方法</p></li><li><p>包装类作为引用类型的变量可以存储<code>null</code>值</p></li><li><p>可以把基本数据类型的值转换成字符串类型的值。（没啥用）</p><ul><li>调用<code>toString()</code>方法</li><li>调用<code>Integer.toString</code>(基本数据类型的值)得到字符串</li><li>直接把基本数据类型+空字符串就得到了字符串</li></ul></li><li><p>把字符串类型的数值转换成对应的基本数据类型的值。（真的很有用）</p><ul><li><code>Xxx.parseXxx(&quot;字符串类型的数值&quot;)</code></li><li><code>Xxx.valueOf(&quot;字符串类型的数值&quot;)</code> 推荐使用</li></ul></li></ul><h2 id="第七章-正则表达式"><a href="#第七章-正则表达式" class="headerlink" title="第七章 正则表达式"></a>第七章 正则表达式</h2><p>是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱是否合法，例如电话号码，金额等。</p><p>字符类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[abc]</span> <span class="hljs-selector-tag">a</span>、<span class="hljs-selector-tag">b</span> 或 c（简单类）<br><span class="hljs-selector-attr">[^abc]</span> 任何字符，除了 <span class="hljs-selector-tag">a</span>、<span class="hljs-selector-tag">b</span> 或 c（否定）<br><span class="hljs-selector-attr">[a-zA-Z]</span> <span class="hljs-selector-tag">a</span> 到 z 或 <span class="hljs-selector-tag">A</span> 到 Z，两头的字母包括在内（范围）<br><span class="hljs-selector-attr">[a-d[m-p]</span>] <span class="hljs-selector-tag">a</span> 到 d 或 m 到 <span class="hljs-selector-tag">p</span>：<span class="hljs-selector-attr">[a-dm-p]</span>（并集）<br><span class="hljs-selector-attr">[a-z&amp;&amp;[def23]</span>] d、e 或 f（交集）<br><span class="hljs-selector-attr">[a-z&amp;&amp;[^bc]</span>] <span class="hljs-selector-tag">a</span> 到 z，除了 <span class="hljs-selector-tag">b</span> 和 c：<span class="hljs-selector-attr">[ad-z]</span>（减去）<br><span class="hljs-selector-attr">[a-z&amp;&amp;[^m-p]</span>] <span class="hljs-selector-tag">a</span> 到 z，而非 m 到 <span class="hljs-selector-tag">p</span>：<span class="hljs-selector-attr">[a-lq-z]</span>（减去）<br></code></pre></td></tr></table></figure><p> 预定义字符类</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">. 任何字符<br><span class="hljs-string">\d</span> 数字：[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><span class="hljs-string">\D</span> 非数字： [^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><span class="hljs-string">\s</span> 空白字符：[ <span class="hljs-string">\t\n\x0B\f\r]</span><br><span class="hljs-string">\S</span> 非空白字符：[^<span class="hljs-string">\s]</span><br><span class="hljs-string">\w</span> 单词字符：[a-zA-Z_0-<span class="hljs-number">9</span>]<br><span class="hljs-string">\W</span> 非单词字符：[^<span class="hljs-string">\w]</span><br></code></pre></td></tr></table></figure><p>以上正则匹配只能校验单个字符。</p><p>Greedy 数量词</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">X</span>? <span class="hljs-keyword">X</span>，一次或一次也没有<br><span class="hljs-keyword">X</span>* <span class="hljs-keyword">X</span>，零次或多次<br><span class="hljs-keyword">X</span>+ <span class="hljs-keyword">X</span>，一次或多次<br><span class="hljs-keyword">X</span>&#123;n&#125; <span class="hljs-keyword">X</span>，恰好 n 次<br><span class="hljs-keyword">X</span>&#123;n,&#125; <span class="hljs-keyword">X</span>，至少 n 次<br><span class="hljs-keyword">X</span>&#123;n,m&#125; <span class="hljs-keyword">X</span>，至少 n 次，但是不超过 m 次<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请您输入电话号码：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        <span class="hljs-keyword">if</span>(phone.matches(<span class="hljs-string">&quot;0\\d&#123;2,5&#125;-?\\d&#123;5,15&#125;&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;电话号码合法了！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.err.println(<span class="hljs-string">&quot;电话号码不正确！&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkTel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请您输入手机号码：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tel</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        <span class="hljs-keyword">if</span>(tel.matches(<span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;手机号码合法了！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.err.println(<span class="hljs-string">&quot;手机号码不正确！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 校验邮箱</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkEmail</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请您输入邮箱：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        <span class="hljs-comment">// 3232323@qq.com</span><br>        <span class="hljs-comment">// dlei082@163.com</span><br>        <span class="hljs-comment">// dlei@pic.com.cn</span><br>        <span class="hljs-keyword">if</span>(email.matches(<span class="hljs-string">&quot;\\w&#123;1,&#125;@\\w&#123;2,10&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;邮箱合法了！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.err.println(<span class="hljs-string">&quot;邮箱格式不正确！&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>split</code>可以结合正则表达式分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.split的基础用法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;贾乃亮,王宝强,陈羽凡&quot;</span>;<br><span class="hljs-comment">// 以“，”分割成字符串数组</span><br>String[] nameArrs = names.split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nameArrs.length ; i++ )&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> nameArrs[i];<br>    System.out.println(name);<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;----------------------&quot;</span>);<br><span class="hljs-comment">// 2.split集合正则表达式做分割</span><br><span class="hljs-type">String</span> <span class="hljs-variable">names1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;贾乃亮lv434fda324王宝强87632fad2342423陈羽凡&quot;</span>;<br><span class="hljs-comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span><br>String[] nameArrs1 = names1.split(<span class="hljs-string">&quot;\\w+&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nameArrs1.length ; i++ )&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> nameArrs1[i];<br>    System.out.println(name);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;----------------------&quot;</span>);<br><span class="hljs-comment">// 3. public String replaceAll(String regex,String newStr)</span><br><span class="hljs-type">String</span> <span class="hljs-variable">names2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;贾乃亮lv434fda324王宝强87632fad2342423陈羽凡&quot;</span>;<br><span class="hljs-comment">// 使用正则表达式定位出内容，替换成/</span><br>System.out.println(names2.replaceAll(<span class="hljs-string">&quot;\\w+&quot;</span> , <span class="hljs-string">&quot;/&quot;</span>));<br><br><span class="hljs-type">String</span> <span class="hljs-variable">names3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;贾乃亮,王宝强,羽凡&quot;</span>;<br>System.out.println(names3.replaceAll(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>));<br></code></pre></td></tr></table></figure><p>正则表达式爬取信息中的内容</p><p>可以通过<code>|</code>将正则表达式连接起来，是<strong>或</strong>的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;来黑马程序学习Java,电话020-43422424，或者联系邮箱&quot;</span> +<br>    <span class="hljs-string">&quot;itcast@itcast.cn,电话18762832633，0203232323&quot;</span> +<br>    <span class="hljs-string">&quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;</span>;<br><span class="hljs-comment">// 需求：从上面的内容中爬取出 电话号码和邮箱。</span><br><span class="hljs-comment">// 1.定义爬取规则</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\\w&#123;1,&#125;@\\w&#123;2,10&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;)|(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,5&#125;-?\\d&#123;5,15&#125;)|400-?\\d&#123;3,8&#125;-?\\d&#123;3,8&#125;&quot;</span>;<br><span class="hljs-comment">// 2.编译正则表达式成为一个匹配规则对象</span><br><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br><span class="hljs-comment">// 3.通过匹配规则对象得到一个匹配数据内容的匹配器对象</span><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br><span class="hljs-comment">// 4.通过匹配器去内容中爬取出信息</span><br><span class="hljs-keyword">while</span>(matcher.find())&#123;<br>    System.out.println(matcher.group());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第八章-泛型"><a href="#第八章-泛型" class="headerlink" title="第八章 泛型"></a>第八章 泛型</h2><h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><p>什么是泛型</p><ul><li>泛型就是一个标签：<code>&lt;数据类型&gt;</code></li><li>泛型可以在编译阶段约束只能操作某种数据类型</li></ul><blockquote><ul><li>JDK 1.7开始之后，泛型后面的申明可以省略不写</li><li><strong>泛型和集合都只能支持引用数据类型，不支持基本数据类型</strong></li></ul></blockquote><h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><ul><li>泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常</li><li>体现的是Java的严谨性和规范性，数据类型,经常需要进行统一</li></ul><h3 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h3><p>使用了泛型定义的类就是泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">lists</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>&#123;<br>        lists.add(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span>&#123;<br>        lists.remove(e);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> lists.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><p>定义了泛型的方法就是泛型方法</p><p>泛型方法定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>一个泛型方法的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; String <span class="hljs-title function_">arrToString</span><span class="hljs-params">(T[] nums)</span>&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    sb.append(<span class="hljs-string">&quot;[&quot;</span>);<br>    <span class="hljs-keyword">if</span>(nums!=<span class="hljs-literal">null</span> &amp;&amp; nums.length &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++ )&#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> nums[i];<br>            sb.append(i == nums.length-<span class="hljs-number">1</span> ? ele : ele+<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>    &#125;<br>    sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>泛型方法是一个通用技术</p></blockquote><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>使用了泛型定义的接口就是泛型接口</p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 interface 接口名称&lt;泛型变量&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E stu)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(E stu)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(E stu)</span>;<br>    E <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>泛型接口的核心思想，在实现接口的时候传入真实的数据类型</p><p>这样重写的方法就是对该数据类型进行操作</p></blockquote><h3 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h3><p>通配符：<code>?</code></p><ul><li><code>?</code>可以用在<strong>使用泛型</strong>的时候代表一切类型</li><li><code>E , T , K , V</code>是在<strong>定义泛型</strong>的时候使用代表一切类型</li></ul><p>泛型的上下限：</p><ul><li><code>? extends Car</code> : 那么<code>?</code>必须是<code>Car</code>或者其子类。(泛型的上限)</li><li><code>? super  Car</code> :那么<code>?</code>必须是<code>Car</code>或者其父类。（泛型的下限。不是很常见）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;BMW&gt; bmws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        run(bmws);<br><br>        ArrayList&lt;BENZ&gt; benzs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        run(benzs);<br><br>        ArrayList&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        <span class="hljs-comment">// run(dogs); // 就进不来了！</span><br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个方法，可以让很多汽车一起进入参加比赛</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BENZ</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第九章-Collection集合"><a href="#第九章-Collection集合" class="headerlink" title="第九章 Collection集合"></a>第九章 Collection集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>什么是集合</p><ul><li>集合是一个大小可变的容器</li><li>容器中的每个数据称为一个元素。数据&#x3D;&#x3D;元素</li><li>集合的特点是：类型可以不确定，大小不固定。集合有很多种，不同的集合特点和使用场景不同</li><li>数组：类型和长度一旦定义出来就都固定了</li></ul><p>集合用处</p><ul><li>在开发中，很多时候元素的个数是不确定的。</li><li>而且经常要进行元素的增删该查操作，集合都是非常合适的。</li><li>开发中集合用的更多</li></ul><blockquote><ul><li>Java中集合的代表是：<code>Collection</code></li><li><code>Collection</code>集合是Java中集合的祖宗类</li><li>学习Collection集合的功能，那么一切集合都可以用这些功能</li></ul></blockquote><p>集合体系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">Collection<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>(接口)<br>              /                                \<br>         Set<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>(接口)                            List<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>(接口)<br>        /               \                       /                \<br> HashSet<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>(实现类)  TreeSet<span class="hljs-tag">&lt;&gt;</span>(实现类)     ArrayList<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>(实现类)  LinekdList<span class="hljs-tag">&lt;&gt;</span>(实现类)<br>     /<br> LinkedHashSet<span class="hljs-tag">&lt;&gt;</span>(实现类)<br></code></pre></td></tr></table></figure><p>集合的特点：</p><ul><li><code>Set</code>系列集合：添加的元素是无序，不重复，无索引的<ul><li><code>HashSet</code>: 添加的元素是无序，不重复，无索引的</li><li><code>LinkedHashSet</code>: 添加的元素是有序，不重复，无索引的</li><li><code>TreeSet</code>: 不重复，无索引，按照大小默认升序排序</li></ul></li><li><code>List</code>系列集合：添加的元素是有序，可重复，有索引<ul><li><code>ArrayList</code>：添加的元素是有序，可重复，有索引</li><li><code>LinekdList</code>：添加的元素是有序，可重复，有索引</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多态写法：</span><br><span class="hljs-comment">//  HashSet:添加的元素是无序，不重复，无索引的。</span><br>Collection&lt;String&gt; sets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>sets.add(<span class="hljs-string">&quot;MyBatis&quot;</span>);<br>sets.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>sets.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>sets.add(<span class="hljs-string">&quot;Spring&quot;</span>);<br>sets.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>sets.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br><span class="hljs-comment">// [Java, MySQL, MyBatis, Spring]</span><br>System.out.println(sets);<br><br><span class="hljs-comment">// ArrayList:添加的元素是有序，可重复，有索引。</span><br>Collection&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;MyBatis&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;Spring&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br><span class="hljs-comment">// [MyBatis, Java, Java, Spring, MySQL, MySQL]</span><br>System.out.println(lists);<br></code></pre></td></tr></table></figure><h3 id="集合常用API"><a href="#集合常用API" class="headerlink" title="集合常用API"></a>集合常用API</h3><p><code>Collection</code>是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。<br>Collection API如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashSet:添加的元素是无序，不重复，无索引。</span><br>Collection&lt;String&gt; sets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">// 1.添加元素，添加成功返回true.</span><br>System.out.println(sets.add(<span class="hljs-string">&quot;贾乃亮&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(sets.add(<span class="hljs-string">&quot;贾乃亮&quot;</span>)); <span class="hljs-comment">// false</span><br>System.out.println(sets.add(<span class="hljs-string">&quot;王宝强&quot;</span>)); <span class="hljs-comment">// true</span><br>sets.add(<span class="hljs-string">&quot;陈羽凡&quot;</span>);<br>System.out.println(sets); <span class="hljs-comment">// 集合重写了toString()方法，默认打印出内容信息</span><br><span class="hljs-comment">// 2.清空集合的元素。</span><br><span class="hljs-comment">//sets.clear();</span><br><span class="hljs-comment">//System.out.println(sets);</span><br><br><span class="hljs-comment">// 3.判断集合是否为空 是空返回true 反之</span><br>System.out.println(sets.isEmpty()); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 4.获取集合的大小</span><br>System.out.println(sets.size()); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 5.判断集合中是否包含某个元素 。</span><br>System.out.println(sets.contains(<span class="hljs-string">&quot;贾乃亮&quot;</span>));<br><br><span class="hljs-comment">// 6.删除某个元素:如果有多个重复元素默认删除前面的第一个！</span><br>sets.remove(<span class="hljs-string">&quot;陈羽凡&quot;</span>);<br>System.out.println(sets);<br><br><span class="hljs-comment">// 7.把集合转换成数组</span><br>Object[] arrs = sets.toArray();<br>System.out.println(<span class="hljs-string">&quot;数组：&quot;</span>+ Arrays.toString(arrs));<br><br>String[] arrs1 = sets.toArray(String[]::<span class="hljs-keyword">new</span>); <span class="hljs-comment">// 以后再了解，指定转换的数组类型！</span><br>System.out.println(<span class="hljs-string">&quot;数组：&quot;</span>+ Arrays.toString(arrs1));<br><br>System.out.println(<span class="hljs-string">&quot;---------------------拓展---------------------------&quot;</span>);<br>Collection&lt;String&gt; c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c1.add(<span class="hljs-string">&quot;李小璐&quot;</span>);<br>c1.add(<span class="hljs-string">&quot;马蓉&quot;</span>);<br><br>Collection&lt;String&gt; c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c2.add(<span class="hljs-string">&quot;白百合&quot;</span>);<br><br>c1.addAll(c2); <span class="hljs-comment">// 把c2集合的元素全部倒入到c1</span><br>System.out.println(c1);<br></code></pre></td></tr></table></figure><h1 id="day5-迭代器、数据结构、List、Set、TreeSet集合、Collections工具类"><a href="#day5-迭代器、数据结构、List、Set、TreeSet集合、Collections工具类" class="headerlink" title="day5-迭代器、数据结构、List、Set、TreeSet集合、Collections工具类"></a>day5-迭代器、数据结构、List、Set、TreeSet集合、Collections工具类</h1><h2 id="第一章-Iterator迭代器"><a href="#第一章-Iterator迭代器" class="headerlink" title="第一章 Iterator迭代器"></a>第一章 Iterator迭代器</h2><p><code>Collection</code>集合的遍历方式</p><ul><li>迭代器</li><li><code>for-each</code></li><li><code>Lambda</code>表达式</li></ul><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul><li><code>public Iterator iterator()</code> 获取集合对应的迭代器，用来遍历集合中的元素</li><li><code>E next()</code> 获取下一个元素值</li><li><code>boolean hasNext()</code> 判断是否有下一个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;小昭&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;殷素素&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>System.out.println(lists);<br><span class="hljs-comment">// 1.得到集合的迭代器对象。</span><br>Iterator&lt;String&gt; it = lists.iterator();<br><br><span class="hljs-comment">// 2.使用while循环遍历。</span><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> it.next();<br>    System.out.println(ele);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for-each遍历"></a>for-each遍历</h3><p><code>for-each</code>遍历实际上是迭代器遍历的简化写法</p><ul><li><code>for-each</code>遍历集合或者数组很方便</li><li><code>for-each</code>遍历无法知道遍历到了哪个元素，因为没有索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;小昭&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;殷素素&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>System.out.println(lists);<br><span class="hljs-comment">// lists = [赵敏, 小昭, 殷素素, 周芷若]</span><br><span class="hljs-comment">//  ele</span><br><span class="hljs-keyword">for</span> (String ele : lists) &#123;<br>    System.out.println(ele);<br>&#125;<br><br><span class="hljs-type">int</span>[] ages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">17</span> , <span class="hljs-number">18</span> , <span class="hljs-number">38</span> , <span class="hljs-number">21</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> age : ages) &#123;<br>    System.out.println(age);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;小昭&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;殷素素&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>System.out.println(lists);<br><span class="hljs-comment">//   [赵敏, 小昭, 殷素素, 周芷若]</span><br><span class="hljs-comment">//   s</span><br>lists.forEach(s -&gt; &#123;<br>System.out.println(s);<br>&#125;);<br><span class="hljs-comment">//      lists.forEach(s -&gt;  System.out.println(s));</span><br><span class="hljs-comment">//      lists.forEach(System.out::println);</span><br></code></pre></td></tr></table></figure><h2 id="第二章-Java常见数据结构种类"><a href="#第二章-Java常见数据结构种类" class="headerlink" title="第二章 Java常见数据结构种类"></a>第二章 Java常见数据结构种类</h2><p>队列（queue）</p><ul><li>先进先出，后进后出。</li><li>场景：各种排队。叫号系统。</li><li>有很多集合可以实现队列。</li></ul><p>栈（stack）</p><ul><li>后进先出，先进后出<br>压栈 &#x3D;&#x3D; 入栈<br>弹栈 &#x3D;&#x3D; 出栈<br>场景：手枪的弹夹。</li></ul><p>数组</p><ul><li>数组是内存中的连续存储区域。</li><li>分成若干等分的小区域（每个区域大小是一样的）</li><li>元素存在索引</li><li>特点：查询元素快（根据索引快速计算出元素的地址，然后立即去定位）<br>增删元素慢（创建新数组，迁移元素）</li></ul><p>链表</p><ul><li>元素不是内存中的连续区域存储。</li><li>元素是游离存储的。每个元素会记录下个元素的地址。</li><li>特点：查询元素慢<br>增删元素快（针对于首尾元素，速度极快，一般是双链表）</li></ul><p>红黑树</p><ul><li>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree） 。</li><li>查找二叉树,排序二叉树：小的左边，大的右边，但是可能树很高，性能变差。</li><li>为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</li><li>红黑树（就是基于红黑规则实现了自平衡的排序二叉树）：树尽量的保证到了很矮小，但是又排好序了，性能最高的树。</li><li>红黑树的增删查改性能都好！！！</li></ul><p>这些结构，其实Java早就通过代码实现了，我们要知道有这些结构即可!</p><h2 id="第三章-List系列集合的使用"><a href="#第三章-List系列集合的使用" class="headerlink" title="第三章 List系列集合的使用"></a>第三章 List系列集合的使用</h2><h3 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/javabasic/image-20220601213800419.png" alt="image-20220601213800419"></p><p><code>Collection</code>集合体系的特点:</p><p><code>Set</code>系列集合：添加的元素，是无序，不重复，无索引的。</p><ul><li><code>HashSet</code>：添加的元素，是无序，不重复，无索引的。</li><li><code>LinkedHashSet</code>：添加的元素，是有序，不重复，无索引的。</li></ul><p><code>List</code>系列集合：添加的元素，是有序，可重复，有索引的。</p><ul><li><code>LinkedList</code>： 添加的元素，是有序，可重复，有索引的。</li><li><code>ArrayList</code>： 添加的元素，是有序，可重复，有索引的。</li><li><code>Vector </code>：是线程安全的，速度慢，工作中很少使用。</li></ul><p><code>List</code>集合继承了<code>Collection</code>集合的全部功能，同时因为<code>List</code>系列集合有索引，</p><p>因为<code>List</code>集合多了索引，所以多了很多按照索引操作元素的功能</p><p><code>ArrayList</code>实现类集合底层基于数组存储数据的，查询快，增删慢！</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回更新前的元素值。</li></ul><blockquote><ul><li><code>List</code>系列集合有序，可重复，有索引的。</li><li><code>ArrayList</code>实现类集合底层基于数组存储数据的，查询快，增删慢！！</li><li>开发中<code>ArrayList</code>集合用的最多！！</li></ul></blockquote><h3 id="List集合的遍历方式"><a href="#List集合的遍历方式" class="headerlink" title="List集合的遍历方式"></a>List集合的遍历方式</h3><p><code>List</code>遍历方式有四种：</p><ul><li><code>for</code>循环</li><li>迭代器</li><li><code>for-each</code></li><li>lambda表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java3&quot;</span>);<br><br><span class="hljs-comment">/** （1）for循环。 */</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; lists.size() ; i++ ) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> lists.get(i);<br>    System.out.println(ele);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><br><span class="hljs-comment">/** （2）迭代器。 */</span><br>Iterator&lt;String&gt; it = lists.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    System.out.println(it.next());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><br><span class="hljs-comment">/** （3）foreach。 */</span><br><span class="hljs-keyword">for</span>(String ele : lists)&#123;<br>    System.out.println(ele);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><br><span class="hljs-comment">/** （4）JDK 1.8开始之后的Lambda表达式*/</span><br>lists.forEach(s -&gt; &#123;<br>    System.out.println(s);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><p><code>LinkedList</code>也是<code>List</code>的实现类：底层是基于链表的，增删比较快，查询慢！！<br><code>LinkedList</code>是支持双链表，定位前后的元素是非常快的，增删首尾的元素也是最快的<br>所以<code>LinkedList</code>除了拥有<code>List</code>集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li></ul><blockquote><ul><li><code>LinkedList</code>是支持双链表，定位前后的元素是非常快的，增删首尾的元素也是最快的。</li><li>所以提供了很多操作首尾元素的特殊API可以做栈和队列的实现。</li><li>如果查询多而增删少用<code>ArrayList</code>集合。(用的最多的)</li><li>如果查询少而增删首尾较多用<code>LinkedList</code>集合。</li></ul></blockquote><h2 id="第四章-Set系列集合"><a href="#第四章-Set系列集合" class="headerlink" title="第四章 Set系列集合"></a>第四章 Set系列集合</h2><p>研究两个问题&#x3D;&#x3D;面试热点&#x3D;&#x3D;</p><ul><li><code>Set</code>集合添加的元素是不重复的，是如何去重复的</li><li><code>Set</code>集合元素无序的原因是什么</li></ul><h3 id="Set系列集合元素去重复的流程"><a href="#Set系列集合元素去重复的流程" class="headerlink" title="Set系列集合元素去重复的流程"></a>Set系列集合元素去重复的流程</h3><ul><li>对于有值特性的，<code>Set</code>集合可以直接判断进行去重复。</li><li>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。<ul><li><code>Set</code>集合会让两两对象，先调用自己的<code>hashCode()</code>方法得到彼此的哈希值（所谓的内存地址）</li><li>然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。</li><li>如果哈希值相同，会继续让两个对象进行<code>equals</code>比较内容是否相同，如果相同认为真的重复了</li><li>如果不相同认为不重复。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; sets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">// 一行经典代码！！</span><br>sets.add(<span class="hljs-number">1</span>);<br>sets.add(<span class="hljs-number">1</span>);<br>sets.add(<span class="hljs-number">2</span>);<br>sets.add(<span class="hljs-number">2</span>);<br>System.out.println(sets);<br><br><span class="hljs-comment">// 存储一些自定义类型数据:无序不重复</span><br>Set&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-type">Apple</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;红富士&quot;</span>,<span class="hljs-number">59.9</span> ,<span class="hljs-string">&quot;红色&quot;</span>);<br><span class="hljs-type">Apple</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;阿克苏&quot;</span>,<span class="hljs-number">39.9</span> ,<span class="hljs-string">&quot;青红色&quot;</span>);<br><span class="hljs-type">Apple</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;阿克苏&quot;</span>,<span class="hljs-number">39.9</span> ,<span class="hljs-string">&quot;青红色&quot;</span>);<br>System.out.println(a1.hashCode()); <span class="hljs-comment">// 哈希值，相当于是内存地址</span><br>System.out.println(a2.hashCode()); <span class="hljs-comment">// 哈希值，相当于是内存地址</span><br>System.out.println(a3.hashCode()); <span class="hljs-comment">// 哈希值，相当于是内存地址</span><br>apples.add(a1);<br>apples.add(a2);<br>apples.add(a3);<br>System.out.println(apples);<br></code></pre></td></tr></table></figure><h3 id="Set系列集合元素无序-x3D-x3D-面试必考-x3D-x3D"><a href="#Set系列集合元素无序-x3D-x3D-面试必考-x3D-x3D" class="headerlink" title="Set系列集合元素无序&#x3D;&#x3D;面试必考&#x3D;&#x3D;"></a>Set系列集合元素无序&#x3D;&#x3D;面试必考&#x3D;&#x3D;</h3><p><code>Set</code>系列集合添加元素无序的根本原因是因为底层采用了哈希表存储元素。</p><ul><li>JDK 1.8之前：哈希表 &#x3D; 数组 + 链表  + （哈希算法）</li><li>JDK 1.8之后：哈希表 &#x3D; 数组 + 链表 + 红黑树  + （哈希算法）</li></ul><p>​    当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>是<code>HashSet</code>的子类，元素是“有序” 不重复，无索引.</p><ul><li><code>LinkedHashSet</code>底层依然是使用哈希表存储元素的，</li><li>但是每个元素都额外带一个链来维护添加顺序！！</li><li>不光增删查快，还有序。缺点是多了一个存储顺序的链会占内存空间!!而且不允许重复，无索引。</li></ul><blockquote><ul><li>如果希望元素可以重复，又有索引，查询要快用<code>ArrayList</code>集合。（用的最多）</li><li>如果希望元素可以重复，又有索引，增删要快要用<code>LinkedList</code>集合。（适合查询元素比较少的情况，经常要首尾操作元素的情况）</li><li>如果希望增删改查都很快，但是元素不重复以及无序无索引，那么用<code>HashSet</code>集合。</li><li>如果希望增删改查都很快且有序，但是元素不重复以及无索引，那么用<code>LinkedHashSet</code>集合。</li></ul></blockquote><h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><p><code>TreeSet</code>: 不重复，无索引，按照大小默认升序排序!!</p><p><code>TreeSet</code>集合称为排序不重复集合，可以对元素进行默认的升序排序。</p><p><code>TreeSet</code>集合自自排序的方式：</p><ul><li>有值特性的元素直接可以升序排序。（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序。</li><li>对于自定义的引用数据类型，<code>TreeSet</code>默认无法排序，执行的时候直接报错，因为人家不知道排序规则。</li></ul><p>自定义的引用数据类型的排序实现：</p><p>对于自定义的引用数据类型，<code>TreeSet</code>默认无法排序</p><p>所以我们需要定制排序的大小规则，程序员定义大小规则的方案有2种：</p><ul><li>直接为对象的类实现比较器规则接口Comparable，重写比较方法（拓展方式）<br>&#x2F;&#x2F; 如果程序员认为比较者大于被比较者 返回正数！<br>&#x2F;&#x2F; 如果程序员认为比较者小于被比较者 返回负数！<br>&#x2F;&#x2F; 如果程序员认为比较者等于被比较者 返回0！</li><li>直接为集合设置比较器Comparator对象,重写比较方法<br>&#x2F;&#x2F; 如果程序员认为比较者大于被比较者 返回正数！<br>&#x2F;&#x2F; 如果程序员认为比较者小于被比较者 返回负数！<br>&#x2F;&#x2F; 如果程序员认为比较者等于被比较者 返回0！</li></ul><blockquote><p>如果类和集合都带有比较规则，优先使用集合自带的比较规则。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TreeSet : 排序不重复集合。</span><br>Set&lt;Double&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>scores.add(<span class="hljs-number">100.0</span>);<br>scores.add(<span class="hljs-number">99.9</span>);<br>scores.add(<span class="hljs-number">69.5</span>);<br>scores.add(<span class="hljs-number">0.1</span>);<br>scores.add(<span class="hljs-number">89.3</span>);<br>System.out.println(scores);<br><br><span class="hljs-comment">// 字符串按照首字符的编号进行排序。</span><br>Set&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;Jack&quot;</span>);<br>names.add(<span class="hljs-string">&quot;rose&quot;</span>);<br>names.add(<span class="hljs-string">&quot;Dlei&quot;</span>);<br>names.add(<span class="hljs-string">&quot;about&quot;</span>);<br>names.add(<span class="hljs-string">&quot;曹雪芹&quot;</span>);<br>names.add(<span class="hljs-string">&quot;bozai&quot;</span>);<br>names.add(<span class="hljs-string">&quot;caocao&quot;</span>);<br>names.add(<span class="hljs-string">&quot;angel&quot;</span>);<br>System.out.println(names);<br><br><span class="hljs-comment">// 引用数据类型定义TreeSet集合。</span><br>Set&lt;Employee&gt; employees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>employees.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;播仔&quot;</span>,<span class="hljs-number">6500.0</span>,<span class="hljs-number">21</span>));<br>employees.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;播妞&quot;</span>,<span class="hljs-number">7500.0</span>,<span class="hljs-number">19</span>));<br>employees.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;乔治&quot;</span>,<span class="hljs-number">4500.0</span>,<span class="hljs-number">23</span>));<br>System.out.println(employees);<br><br><br><span class="hljs-comment">// public TreeSet(Comparator&lt;? super E&gt; comparator)</span><br><span class="hljs-comment">// 集合自带比较器对象</span><br><span class="hljs-comment">// 如果类和集合都存在大小规则，默认使用集合自带的规则进行大小排序！！</span><br>Set&lt;Employee&gt; employees1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Employee&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Employee o1, Employee o2)</span> &#123;<br>        <span class="hljs-comment">// o1比较者   o2被比较者</span><br>        <span class="hljs-comment">// 如果程序员认为比较者大于被比较者 返回正数！</span><br>        <span class="hljs-comment">// 如果程序员认为比较者小于被比较者 返回负数！</span><br>        <span class="hljs-comment">// 如果程序员认为比较者等于被比较者 返回0！</span><br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>    &#125;<br>&#125;);<br>employees1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;播仔&quot;</span>,<span class="hljs-number">6500.0</span>,<span class="hljs-number">21</span>));<br>employees1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;播妞&quot;</span>,<span class="hljs-number">7500.0</span>,<span class="hljs-number">19</span>));<br>employees1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;乔治&quot;</span>,<span class="hljs-number">4500.0</span>,<span class="hljs-number">23</span>));<br>System.out.println(employees1);<br></code></pre></td></tr></table></figure><h2 id="第五章-Collections工具类"><a href="#第五章-Collections工具类" class="headerlink" title="第五章 Collections工具类"></a>第五章 Collections工具类</h2><p><code>Collections</code>并不属于集合，而是用来操作集合的工具类</p><p><code>Collections</code>有几个常用的API:</p><ul><li><p><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)</code></p><p>给集合对象批量添加元素！</p></li><li><p><code>public static void shuffle(List&lt;?&gt; list)</code></p><p>打乱集合顺序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code></p><p>将集合中元素按照默认规则排序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code></p><p>将集合中元素按照指定规则排序。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.给集合批量添加元素</span><br>Collection&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 参数一：被添加元素的集合</span><br><span class="hljs-comment">* 参数二：可变参数，一批元素</span><br><span class="hljs-comment">*/</span><br>Collections.addAll(names,<span class="hljs-string">&quot;曹操&quot;</span>,<span class="hljs-string">&quot;贾乃亮&quot;</span>,<span class="hljs-string">&quot;王宝强&quot;</span>,<span class="hljs-string">&quot;陈羽凡&quot;</span>);<br>System.out.println(names);<br><br><span class="hljs-comment">// 2.打乱集合的顺序：public static void shuffle(List&lt;?&gt; list)</span><br><span class="hljs-comment">// 注意：只能打乱有序的List集合。</span><br>List&lt;String&gt; newnames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(newnames,<span class="hljs-string">&quot;曹操&quot;</span>,<span class="hljs-string">&quot;贾乃亮&quot;</span>,<span class="hljs-string">&quot;王宝强&quot;</span>,<span class="hljs-string">&quot;陈羽凡&quot;</span>);<br>Collections.shuffle(newnames); <span class="hljs-comment">// 打乱顺序</span><br>System.out.println(newnames);<br><br><span class="hljs-comment">// 3.public static &lt;T&gt; void sort(List&lt;T&gt; list)：给List集合升序排序。</span><br>List&lt;Double&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(scores, <span class="hljs-number">98.5</span>, <span class="hljs-number">66.5</span> , <span class="hljs-number">59.5</span> , <span class="hljs-number">66.5</span> , <span class="hljs-number">99.5</span> );<br>Collections.sort(scores); <span class="hljs-comment">// 默认升序排序！</span><br>System.out.println(scores);<br></code></pre></td></tr></table></figure><p>引用类型的排序</p><p>字符串按照首字符的编号升序排序！</p><p>自定义类型的比较方法API:</p><ul><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code></p><p>集合中元素按照默认规则排序。</p><p>对于自定义的引用类型的排序人家根本不知道怎么排，直接报错！</p><p>如果希望自定义的引用类型排序不报错，可以给类提供比较规则:Comparable。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c)</code></p><p>将集合中元素按照指定规则排序,自带比较器</p><p>注意：如果类有比较规则，而这里有比较器，优先使用比较器。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义类型如何排序！</span><br>List&lt;Orange&gt; oranges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;红橘子&quot;</span>,<span class="hljs-number">654.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黄橘子&quot;</span>,<span class="hljs-number">454.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黄橘子&quot;</span>,<span class="hljs-number">454.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;青橘子&quot;</span>,<span class="hljs-number">456.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br>Collections.addAll(oranges,o1,o2,o3,o4);<br>Collections.sort(oranges); <span class="hljs-comment">// 排序，按照类实现的比较规则进行排序！！</span><br>System.out.println(oranges);<br><br><br>List&lt;Orange&gt; oranges1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o11</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;红橘子&quot;</span>,<span class="hljs-number">654.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o22</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黄橘子&quot;</span>,<span class="hljs-number">454.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o33</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黄橘子&quot;</span>,<span class="hljs-number">454.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o44</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;青橘子&quot;</span>,<span class="hljs-number">456.0</span> ,<span class="hljs-string">&quot;贼便宜~&quot;</span>);<br>Collections.addAll(oranges1,o11,o22,o33,o44);<br><span class="hljs-comment">// 优先用方法自带的比较器对象Comparator而不会用类的比较规则！！</span><br>Collections.sort(oranges1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Orange&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Orange o1, Orange o2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(o1.getWeight() &gt; o2.getWeight()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(o1.getWeight() &lt; o2.getWeight()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br>System.out.println(oranges1);<br></code></pre></td></tr></table></figure><h2 id="第六章-可变参数"><a href="#第六章-可变参数" class="headerlink" title="第六章 可变参数"></a>第六章 可变参数</h2><p>可变参数用在形参中可以接收多个数据。</p><p>可变参数的格式：数据类型… 参数名称</p><p>可变参数的作用：</p><ul><li>传输参数非常灵活，方便。</li><li>可以不传输参数。</li><li>可以传输一个参数。</li><li>可以传输多个参数。</li><li>可以传输一个数组。</li></ul><p>可变参数在方法内部本质上就是一个数组。</p><p>可变参数的注意事项：</p><ul><li>一个形参列表中可变参数只能有一个！！</li><li>可变参数必须放在形参列表的最后面！！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    sum(); <span class="hljs-comment">// 可以不传输参数。</span><br>    sum(<span class="hljs-number">10</span>); <span class="hljs-comment">// 可以传输一个参数。</span><br>    sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>); <span class="hljs-comment">// 可以传输多个参数。</span><br>    sum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>,<span class="hljs-number">90</span>&#125;); <span class="hljs-comment">// 可以传输一个数组。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>...nums)</span>&#123;<br>    <span class="hljs-comment">// 可变参数在方法内部本质上就是一个数组。</span><br>    System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+nums.length);<br>    System.out.println(<span class="hljs-string">&quot;元素内容：&quot;</span>+ Arrays.toString(nums));<br>    System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day6-Map"><a href="#day6-Map" class="headerlink" title="day6-Map"></a>day6-Map</h1><h2 id="第一章-Map"><a href="#第一章-Map" class="headerlink" title="第一章 Map"></a>第一章 Map</h2><h3 id="Map集合的概述"><a href="#Map集合的概述" class="headerlink" title="Map集合的概述"></a>Map集合的概述</h3><p><code>Map</code>集合是另一个集合体系。</p><p><code>Collection</code>是单值集合体系。</p><p><code>Map</code>集合是一种双列集合，每个元素包含两个值。</p><p><code>Map</code>集合的每个元素的格式：<code>key=value</code>(键值对元素)。</p><p><code>Map</code>集合也被称为“键值对集合”。</p><p><code>Map</code>集合的完整格式：<code>&#123;key1=value1 , key2=value2 , key3=value3 , ...&#125;</code></p><ul><li><code>Map</code>集合的特点都是由键决定的。</li><li><code>Map</code>集合的键是无序,不重复的，无索引的，<code>Map</code>集合后面重复的键对应的元素会覆盖前面的整个元素！</li><li><code>Map</code>集合的值无要求。</li><li><code>Map</code>集合的键值对都可以为<code>null</code>。</li></ul><p><code>HashMap</code>:元素按照键是无序，不重复，无索引，值不做要求。<br><code>LinkedHashMap</code>:元素按照键是有序，不重复，无索引，值不做要求。</p><h3 id="Map集合的API"><a href="#Map集合的API" class="headerlink" title="Map集合的API"></a>Map集合的API</h3><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到<code>Map</code>集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在<code>Map</code>集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在<code>Map</code>集合中获取对应的值。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取<code>Map</code>集合中所有的键，存储到<code>Set</code>集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到<code>Map</code>集合中所有的键值对对象的集合(<code>Set</code>集合)。</li><li><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">10</span>);<br>maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span><br>maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br><span class="hljs-comment">// &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br>System.out.println(maps);<br><br><span class="hljs-comment">// 2.清空集合</span><br><span class="hljs-comment">//maps.clear();</span><br><span class="hljs-comment">//System.out.println(maps);</span><br><br><span class="hljs-comment">// 3.判断集合是否为空，为空返回true ,反之！</span><br>System.out.println(maps.isEmpty());<br><br><span class="hljs-comment">// 4.根据键获取对应值。</span><br><span class="hljs-comment">//Integer value = maps.get(&quot;娃娃&quot;);</span><br><span class="hljs-comment">//System.out.println(value);</span><br>System.out.println(maps.get(<span class="hljs-string">&quot;娃娃&quot;</span>));<br><br><span class="hljs-comment">// 5.根据键删除整个元素。(删除键会返回键的值)</span><br>maps.remove(<span class="hljs-string">&quot;iphoneX&quot;</span>);<br>System.out.println(maps);<br><br><span class="hljs-comment">// 6.判断是否包含某个键 ，包含返回true ,反之</span><br>System.out.println(maps.containsKey(<span class="hljs-string">&quot;手表&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(maps.containsKey(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 7.判断是否包含某个值。</span><br>System.out.println(maps.containsValue(<span class="hljs-number">1000</span>)); <span class="hljs-comment">// true</span><br>System.out.println(maps.containsValue(<span class="hljs-number">10</span>)); <span class="hljs-comment">// true</span><br>System.out.println(maps.containsValue(<span class="hljs-string">&quot;30&quot;</span>)); <span class="hljs-comment">// false 包含的是整数30不是字符串。</span><br><br><span class="hljs-comment">// 8.获取全部键的集合：public Set&lt;K&gt; keySet()</span><br><span class="hljs-comment">// Map集合的键是无序不重复的，所以返回的是一个Set集合。</span><br>Set&lt;String&gt; keys = maps.keySet();<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>    System.out.println(key);<br>&#125;<br><br><span class="hljs-comment">// 9.获取全部值的集合：Collection&lt;V&gt; values();</span><br><span class="hljs-comment">// Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span><br>Collection&lt;Integer&gt; values = maps.values();<br><span class="hljs-keyword">for</span> (Integer value : values) &#123;<br>    System.out.println(value);<br>&#125;<br><br><span class="hljs-comment">// 10.集合的大小</span><br>System.out.println(maps.size());<br><br><span class="hljs-comment">// 11.合并其他Map集合。(拓展)</span><br>Map&lt;String,Integer&gt; maps2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>maps2.put(<span class="hljs-string">&quot;xiaoMi&quot;</span> , <span class="hljs-number">1</span>);<br>maps2.put(<span class="hljs-string">&quot;🔨手机&quot;</span> , <span class="hljs-number">10</span>);<br>maps2.put(<span class="hljs-string">&quot;手表&quot;</span> , <span class="hljs-number">10000</span>);<br>maps.putAll(maps2); <span class="hljs-comment">// 把Map集合maps2的数据全部倒入到maps集合中去</span><br>System.out.println(maps);<br></code></pre></td></tr></table></figure><h3 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h3><p><code>Map</code>集合的遍历方式有3种：</p><ul><li><strong>键找值</strong>的方式遍历：先获取<code>Map</code>集合全部的键，再根据遍历键找值</li><li><strong>键值对</strong>的方式遍历</li><li>JDK1.8之后支持<code>Lambda</code>表达式</li></ul><p>首先是<strong>键找值</strong>遍历方式</p><ul><li>先获取<code>Map</code>集合的全部键的<code>Set</code>集合</li><li>遍历键的<code>Set</code>集合，然后通过键找值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; keys = maps.keySet();<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>    <span class="hljs-comment">// 过键取对应的值</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> maps.get(key);<br>    System.out.println(key + <span class="hljs-string">&quot;=&quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是<strong>键值对</strong>的方式遍历</p><ul><li>把<code>Map</code>集合转换成一个<code>Set</code>集合:<code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code></li><li>此时键值对元素的类型就确定了，类型是键值对实体类型：<code>Map.Entry&lt;K, V&gt;</code></li><li>接下来就可以用<code>foreach</code>遍历这个<code>Set</code>集合，类型用<code>Map.Entry&lt;K, V&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>    System.out.println(key + <span class="hljs-string">&quot;=&gt;&quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是简介的<code>Lambda</code>表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">maps.forEach((k , v) -&gt; &#123;<br>    System.out.println(k+<span class="hljs-string">&quot;==&gt;&quot;</span>+v);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Map集合存储自定义类型"><a href="#Map集合存储自定义类型" class="headerlink" title="Map集合存储自定义类型"></a>Map集合存储自定义类型</h3><p><code>Map</code>集合的键和值都可以存储自定义类型</p><p>如果<code>Map</code>集合认为自定义类型的键对象重复了，必须重写对象的<code>hashCode()</code>和<code>equals()</code>方法</p><p><code>Orange.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> weight;<br>    <span class="hljs-keyword">private</span> String price;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> weight, String price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.weight = weight;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Orange</span> <span class="hljs-variable">orange</span> <span class="hljs-operator">=</span> (Orange) o;<br>        <span class="hljs-keyword">return</span> Double.compare(orange.weight, weight) == <span class="hljs-number">0</span> &amp;&amp;<br>                Objects.equals(name, orange.name) &amp;&amp;<br>                Objects.equals(price, orange.price);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, weight, price);<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Map</code>使用自定义存储类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Orange,String&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黄橘子&quot;</span>,<span class="hljs-number">20.3</span> , <span class="hljs-string">&quot;贼便宜！&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黑橘子&quot;</span>,<span class="hljs-number">30.3</span> , <span class="hljs-string">&quot;坏了&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;青橘子&quot;</span>,<span class="hljs-number">34.3</span> , <span class="hljs-string">&quot;9.9包邮&quot;</span>);<br><span class="hljs-type">Orange</span> <span class="hljs-variable">o4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>(<span class="hljs-string">&quot;黄橘子&quot;</span>,<span class="hljs-number">20.3</span> , <span class="hljs-string">&quot;贼便宜！&quot;</span>);<br><br>maps.put(o1 , <span class="hljs-string">&quot;江西\n&quot;</span>);<br>maps.put(o2 , <span class="hljs-string">&quot;赣州\n&quot;</span>);<br>maps.put(o3 , <span class="hljs-string">&quot;广州\n&quot;</span>);<br>maps.put(o4 , <span class="hljs-string">&quot;广西\n&quot;</span>);<br><br>System.out.println(maps);<br></code></pre></td></tr></table></figure><h3 id="LinkedHashMap的特点"><a href="#LinkedHashMap的特点" class="headerlink" title="LinkedHashMap的特点"></a>LinkedHashMap的特点</h3><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，添加的元素按照键有序，不重复的。</p><p><code>HashSet</code>集合相当于是<code>HashMap</code>集合的键都不带值。</p><p><code>LinkedHashSet</code>集合相当于是<code>LinkedHashMap</code>集合的键都不带值。</p><p>底层原理完全一样，都是基于哈希表按照键存储数据的，</p><p>只是<code>HashMap</code>或者<code>LinkedHashMap</code>的键都多一个附属值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">10</span>);<br>maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>); <span class="hljs-comment">// 依然是保留前面的位置，只是替换其值！</span><br>maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>System.out.println(maps);<br></code></pre></td></tr></table></figure><ul><li><code>HashMap</code>集合是无序不重复的键值对集合。</li><li><code>LinkedHashMap</code>集合是有序不重复的键值对集合。</li><li>他们都是基于哈希表存储数据,增删改查都很好。</li></ul><h3 id="TreeMap集合应用"><a href="#TreeMap集合应用" class="headerlink" title="TreeMap集合应用"></a>TreeMap集合应用</h3><ul><li><code>TreeMap</code>集合按照键是可排序不重复的键值对集合。(默认升序)</li><li><code>TreeMap</code>集合按照键排序的特点与<code>TreeSet</code>是完全一样的</li></ul><blockquote><p><code>TreeMap</code>集合和<code>TreeSet</code>集合都是排序不重复集合</p><p><code>TreeSet</code>集合的底层是基于<code>TreeMap</code>，只是键没有附属值而已。</p><p>所以<code>TreeMap</code>集合指定大小规则有2种方式：</p><ul><li>直接为对象的类实现比较器规则接口<code>Comparable</code>，重写比较方法（拓展方式）</li><li>直接为集合设置比较器<code>Comparator</code>对象,重写比较方法</li></ul></blockquote><p>类实现<code>Comparable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比较者： this</span><br><span class="hljs-comment">// 被比较者： o</span><br><span class="hljs-comment">// 需求：按照价格排序！</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 浮点型的大小比较建议使用Java自己的API:</span><br>    <span class="hljs-comment">// public static int compare(double d1, double d2)</span><br>    <span class="hljs-keyword">return</span>  -Double.compare(<span class="hljs-built_in">this</span>.price , ((Pig)o).price);<br>&#125;<br></code></pre></td></tr></table></figure><p>集合设置<code>Comparator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Pig,String&gt; pigs1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Pig&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Pig p1, Pig p2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Double.compare(p1.getWeight() , p2.getWeight());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="第二章-排序算法"><a href="#第二章-排序算法" class="headerlink" title="第二章 排序算法"></a>第二章 排序算法</h2><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br><span class="hljs-comment">// 1.定义一个循环控制总共需要冒泡几轮：数组的长度-1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;  i &lt; arr.length - <span class="hljs-number">1</span> ; i++ )&#123;<br>    <span class="hljs-comment">// i = 0   j = 0 1 2</span><br>    <span class="hljs-comment">// i = 1   j = 0 1</span><br>    <span class="hljs-comment">// i = 2   j = 0</span><br>    <span class="hljs-comment">// 2.控制每轮比较几次。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; arr.length - i - <span class="hljs-number">1</span> ; j++ )&#123;<br>        <span class="hljs-comment">// 如果当前元素大于后一个元素</span><br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-comment">// 交换位置。大的元素必须后移！</span><br>            <span class="hljs-comment">// 定义一个临时变量存储后一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j+<span class="hljs-number">1</span>];<br>            arr[j+<span class="hljs-number">1</span>] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span> , <span class="hljs-number">1</span> , <span class="hljs-number">3</span> , <span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 1.定义一个循环控制选择几轮</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; arr.length - <span class="hljs-number">1</span> ; i++ )&#123;<br>    <span class="hljs-comment">// 2.定义一个循环控制每轮比较几次，一定是以当前位置与后面元素比较</span><br>    <span class="hljs-comment">// i =0  j = 1 2 3</span><br>    <span class="hljs-comment">// i =1  j = 2 3</span><br>    <span class="hljs-comment">// i =2  j = 3</span><br>    <span class="hljs-comment">// 遍历后面的元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span> ; j &lt; arr.length ; j++ )&#123;<br>        <span class="hljs-comment">// 拿当前位置与j指定的元素进行大小比较，后面的较小就交换位置</span><br>        <span class="hljs-keyword">if</span>(arr[j] &lt; arr[i])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三章-二分查找"><a href="#第三章-二分查找" class="headerlink" title="第三章 二分查找"></a>第三章 二分查找</h2><p><strong>二分查找的前提</strong>：对数组是有要求的,数组必须已经排好序。</p><p>每次先与中间的元素进行比较，如果大于往右边找，如果小于往左边找，如果等于就返回该元素索引位置！</p><p>如果没有该元素，返回-1。综合性能比较好！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr  被检索的数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> number 被检索的元素值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  返回元素在数组中的索引值，不存在该元素返回-1</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySerach</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr , <span class="hljs-type">int</span> number)</span>&#123;<br>    <span class="hljs-comment">// 3.记录当前区间搜索的开始索引和结束索引。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 4.定义一个循环，反复去循环元素。</span><br>    <span class="hljs-keyword">while</span>(start &lt;= end)&#123;<br>        <span class="hljs-comment">// 5.取中间索引位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">middleIndex</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span> ;<br>        <span class="hljs-comment">// 6.判断当前元素与中间元素的大小</span><br>        <span class="hljs-keyword">if</span>(number &lt; arr[middleIndex])&#123;<br>            <span class="hljs-comment">// 7.往左边继续寻找，结束索引应该-1</span><br>            end = middleIndex - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number &gt; arr[middleIndex])&#123;<br>            start = middleIndex + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number == arr[middleIndex])&#123;<br>            <span class="hljs-keyword">return</span> middleIndex;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果上述循环执行完毕还没有返回索引，说明根本不存在该元素值，直接返回-1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day7-异常、线程"><a href="#day7-异常、线程" class="headerlink" title="day7-异常、线程"></a>day7-异常、线程</h1><h2 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章 异常"></a>第一章 异常</h2><h3 id="异常的概述和体系"><a href="#异常的概述和体系" class="headerlink" title="异常的概述和体系"></a>异常的概述和体系</h3><p><strong>异常</strong>：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止</p><ul><li>在<code>Java</code>等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。<code>Java</code>处理异常的方式是中断处理。</li><li><code>Java</code>会为常见的代码异常都设计一个类来代表</li><li><code>Java</code>中异常继承的根类是：<code>Throwable</code></li></ul><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/javabasic/image-20220603140634079.png" alt="image-20220603140634079" style="zoom: 80%;" /><p><code>Error </code>: 错误的意思，严重错误<code>Error</code>，无法通过处理的错误，一旦出现，程序员无能为力了，</p><ul><li>只能重启系统，优化项目。</li><li>比如内存奔溃，<code>JVM</code>本身的奔溃。这个程序员无需理会。</li></ul><p><code>Exception</code>:才是异常类，它才是开发中代码在编译或者执行的过程中可能出现的错误，</p><ul><li>它是需要提前处理的。以便程序更健壮！</li></ul><p><code>Exception</code>异常的分类:</p><ul><li><strong>编译时异常</strong>：继承自<code>Exception</code>的异常或者其子类，编译阶段就会报错，必须程序员处理的。否则代码编译就不能通过</li><li><strong>运行时异常</strong>: 继承自<code>RuntimeException</code>的异常或者其子类，编译阶段是不会出错的，它是在运行时阶段可能出现，运行时异常可以处理也可以不处理，编译阶段是不会出错的，但是运行阶段可能出现，还是建议提前处理</li></ul><h3 id="常见的运行时异常-x3D-x3D-面试热点-x3D-x3D"><a href="#常见的运行时异常-x3D-x3D-面试热点-x3D-x3D" class="headerlink" title="常见的运行时异常&#x3D;&#x3D;面试热点&#x3D;&#x3D;"></a>常见的运行时异常&#x3D;&#x3D;面试热点&#x3D;&#x3D;</h3><p>继承自<code>RuntimeException</code>的异常或者其子类，编译阶段是不会出错的，它是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理,代码编译都能通过</p><ul><li>数组索引越界异常: <code>ArrayIndexOutOfBoundsException</code></li><li>空指针异常 : <code>NullPointerException</code><br>直接输出没有问题。但是调用空指针的变量的功能就会报错</li><li>类型转换异常：<code>ClassCastException</code></li><li>迭代器遍历没有此元素异常：<code>NoSuchElementException</code></li><li>数学操作异常：<code>ArithmeticException</code></li><li>数字转换异常： <code>NumberFormatException</code></li></ul><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>编译时异常：继承自<code>Exception</code>的异常或者其子类，没有继承<code>RuntimeException</code></p><ul><li>“编译时异常是编译阶段就会报错”，</li><li>必须程序员编译阶段就处理的。否则代码编译就报错</li></ul><p>编译时异常的作用是什么：</p><ul><li>是担心程序员的技术不行，在编译阶段就爆出一个错误, 目的在于提醒</li><li>提醒程序员这里很可能出错，请检查并注意不要出bug</li></ul><h2 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h2><h3 id="异常的产生、处理的默认过程"><a href="#异常的产生、处理的默认过程" class="headerlink" title="异常的产生、处理的默认过程"></a>异常的产生、处理的默认过程</h3><ul><li>默认会在出现异常的代码那里自动的创建一个异常对象：<code>ArithmeticException</code>。</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给<code>JVM</code>虚拟机。</li><li>虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</li><li>直接从当前执行的异常点干掉当前程序。</li><li>后续代码没有机会执行了，因为程序已经死亡。</li></ul><h3 id="编译时异常处理机制"><a href="#编译时异常处理机制" class="headerlink" title="编译时异常处理机制"></a>编译时异常处理机制</h3><p>方法一</p><ul><li>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给JVM虚拟机。</li><li>JVM虚拟机输出异常信息，直接干掉程序，这种方式与默认方式是一样的。</li></ul><p>抛出异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">方法 <span class="hljs-keyword">throws</span> 异常<span class="hljs-number">1</span> ,  异常<span class="hljs-number">2</span> , ..&#123;<br><br>&#125;<br>建议抛出异常的方式：代表可以抛出一切异常，<br>方法 <span class="hljs-keyword">throws</span> Exception&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然可以解决代码编译时的错误，但是一旦运行时真的出现异常，程序还是会立即死亡</p><p>方法二</p><p>在出现异常的地方自己处理，谁出现谁处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 监视可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 变量)&#123;<br>    <span class="hljs-comment">// 处理异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 变量)&#123;<br>    <span class="hljs-comment">// 处理异常</span><br>&#125;...<br></code></pre></td></tr></table></figure><blockquote><p>第二种方式，可以处理异常，并且出现异常后代码也不会死亡。这种方案还是可以的。但是从理论上来说，这种方式不是最好的，上层调用者不能直接知道底层的执行情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy/MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(time);<br>    System.out.println(d);<br><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/meinv.png&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;文件根本不存在！&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;解析有问题，请检查代码！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三</p><p>在出现异常的地方吧异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理&#x3D;&#x3D;规范做法&#x3D;&#x3D;</p><blockquote><p>这种方案最外层调用者可以知道底层执行的情况，同时程序在出现异常后也不会立即死亡，这是<br>理论上最好的方案</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;程序开始。。。。&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        parseDate(<span class="hljs-string">&quot;2013-03-23 10:19:23&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;功能成功执行！！&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        System.out.println(<span class="hljs-string">&quot;功能执行失败！！&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;程序结束。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 可以拦截所以异常!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDate</span><span class="hljs-params">(String time)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(time);<br>    System.out.println(d);<br><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/meinv.png&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行时异常的处理机制"><a href="#运行时异常的处理机制" class="headerlink" title="运行时异常的处理机制"></a>运行时异常的处理机制</h3><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错。运行时异常在编译阶段不处理也不会报错，但是运行时如果出错了程序还是会死亡。所以运行时异常也建议要处理。</p><p>运行时异常是自动往外抛出的，不需要我们手工抛出。</p><p>运行时异常的处理规范：直接在最外层捕获处理即可，底层会自动抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;程序开始。。。。&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            chu(<span class="hljs-number">10</span> , <span class="hljs-number">0</span>);<br>            System.out.println(<span class="hljs-string">&quot;操作成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;操作失败！&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;程序结束。。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>  &#123;<br>        System.out.println( a / b );<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p>用在捕获处理的异常格式中的，放在最后面</p><p>无论代码是出现异常还是正常执行，最终一定要执行这里的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>finally</code>的作用: 可以在代码执行完毕以后进行资源的释放操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//System.out.println(10/0);</span><br>    is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/cang.png&quot;</span>);<br>    System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">0</span> );<br><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;==finally被执行===&quot;</span>);<br>    <span class="hljs-comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(is!=<span class="hljs-literal">null</span>)is.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h3><ul><li>运行时异常被抛出可以不处理。可以自动抛出,编译时异常必须处理.按照规范都应该处理!</li><li>重写方法申明抛出的异常，<strong>应该与父类被重写方法申明抛出的异常一样或者范围更小</strong></li><li>方法默认都可以自动抛出运行时异常！  <code>throws RuntimeException</code>可以省略不写!!</li><li>当多异常处理时，捕获处理，<strong>前边的异常类不能是后边异常类的父类</strong>。</li><li>在<code>try/catch</code>后可以追加<code>finally</code>代码块，其中的代码一定会被执行，通常用于资源回收操作。</li></ul><h2 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h2><p>自定义<strong>编译时异常</strong></p><ul><li>定义一个异常类继承<code>Exception</code></li><li>重写构造器</li><li>在出现异常的地方用<code>throw new </code>自定义对象抛出</li><li>编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItheimaAgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalException</span><span class="hljs-params">(String message, Throwable cause, <span class="hljs-type">boolean</span> enableSuppression, <span class="hljs-type">boolean</span> writableStackTrace)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause, enableSuppression, writableStackTrace);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义<strong>运行时异常</strong></p><ul><li>定义一个异常类继承<code>RuntimeException</code></li><li>重写构造器</li><li>在出现异常的地方用<code>throw new</code>自定义对象抛出</li><li>提醒不强烈，编译阶段不报错，运行时才可能出现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItheimaAgeIllegalRuntimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalRuntimeException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalRuntimeException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalRuntimeException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalRuntimeException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIllegalRuntimeException</span><span class="hljs-params">(String message, Throwable cause, <span class="hljs-type">boolean</span> enableSuppression, <span class="hljs-type">boolean</span> writableStackTrace)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause, enableSuppression, writableStackTrace);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常的作用：</p><ul><li>可以处理代码问题，防止程序出现异常后的死亡</li><li>提高了程序的健壮性和安全性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请您输入您的年年龄：&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> sc.nextInt();<br>    System.out.println(<span class="hljs-string">&quot;您是：&quot;</span>+age);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    System.err.println(<span class="hljs-string">&quot;您的年龄是瞎输入的！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li><strong>线程</strong>：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</li></ul><p>进程的三个特征：</p><ul><li><p>动态性 ： 进程是运行中的程序，要动态的占用内存，CPU和网络等资源。</p></li><li><p>独立性 ： 进程与进程之间是相互独立的，彼此有自己的独立内存区域。</p></li><li><p>并发性 ： 假如<code>CPU</code>是单核，同一个时刻其实内存中只有一个进程在被执行。</p><p><code>CPU</code>会分时轮询切换依次为每个进程服务，因为切换的速度非常快，给我们的感觉这些进程在同时执行，这就是并发性。</p></li></ul><p>线程的作用</p><ul><li>可以提高程序的效率，线程也支持并发性，可以有更多机会得到CPU。</li><li>多线程可以解决很多业务模型。</li><li>大型高并发技术的核心技术。</li><li>设计到多线程的开发可能都比较难理解。</li></ul><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p>线程开启我们需要用到了<code>java.lang.Thread</code>类，API中该类中定义了有关线程的一些方法，具体如下：</p><p><strong>构造方法：</strong></p><ul><li><code>public Thread()</code>:分配一个新的线程对象。</li><li><code>public Thread(String name)</code>:分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code>:分配一个带有指定目标新的线程对象。</li><li><code>public Thread(Runnable target,String name)</code>:分配一个带有指定目标新的线程对象并指定名字。</li></ul><p><strong>常用方法：</strong></p><ul><li><code>public void setName(String name)</code>：给当前线程取名字</li><li><code>public String getName()</code>:获取当前线程名称。</li><li><code>public void start()</code>:导致此线程开始执行; Java虚拟机调用此线程的run方法。</li><li><code>public void run()</code>:此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li><code>public static Thread currentThread()  </code>:返回对当前正在执行的线程对象的引用。</li></ul><p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</p><h3 id="线程的创建方式一-继承方式"><a href="#线程的创建方式一-继承方式" class="headerlink" title="线程的创建方式一-继承方式"></a>线程的创建方式一-继承方式</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-comment">// 启动后的ThreadDemo当成一个进程。</span><br>    <span class="hljs-comment">// main方法是由主线程执行的，理解成main方法就是一个主线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建一个线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-comment">// 4.调用线程对象的start()方法启动线程,最终还是执行run()方法！</span><br>        t.start();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1.定义一个线程类继承Thread类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">// 2.重写run()方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行方法。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>线程的启动必须调用<code>start()</code>方法，否则当成普通类处理<ul><li>如果线程直接调用<code>run()</code>方法，相当于变成了普通类的执行，此时只有主线程在执行他们</li><li><code>start()</code>方法底层其实是给CPU注册当前线程，并且触发<code>run()</code>方法执行</li></ul></li><li>建议线程先创建子线程，主线程的任务放在之后，否则主线程永远是先执行完</li></ul></blockquote><h3 id="线程创建方式二-实现方式"><a href="#线程创建方式二-实现方式" class="headerlink" title="线程创建方式二-实现方式"></a>线程创建方式二-实现方式</h3><p>采用<code>java.lang.Runnable</code>也是非常常见的一种，我们只需要重写run方法即可。</p><p>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建一个线程任务对象(注意：线程任务对象不是线程对象，只是执行线程的任务的)</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">// 4.把线程任务对象包装成线程对象.且可以指定线程名称</span><br>        <span class="hljs-comment">// Thread t = new Thread(target);</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target,<span class="hljs-string">&quot;1号线程&quot;</span>);<br>        <span class="hljs-comment">// 5.调用线程对象的start()方法启动线程</span><br>        t.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<br>        <span class="hljs-comment">// 调用线程对象的start()方法启动线程</span><br>        t2.start();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;==&gt;&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1.创建一个线程任务类实现Runnable接口。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-comment">// 2.重写run()方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;==&gt;&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类方式"><a href="#匿名内部类方式" class="headerlink" title="匿名内部类方式"></a>匿名内部类方式</h3><p>这种方式是实现方式的匿名内部类写法，代码更加简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoNameInnerClassThread</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <br><span class="hljs-comment">//new Runnable()&#123;</span><br><span class="hljs-comment">//public void run()&#123;</span><br><span class="hljs-comment">//for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="hljs-comment">//System.out.println(&quot;张宇:&quot;+i);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;  </span><br><span class="hljs-comment">//   &#125;; //---这个整体  相当于new MyRunnable()</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>                  System.out.println(<span class="hljs-string">&quot;张宇:&quot;</span>+i);<br>                &#125;<br>            &#125;  <br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>          System.out.println(<span class="hljs-string">&quot;费玉清:&quot;</span>+i);<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程创建方式三-实现Callable接口"><a href="#线程创建方式三-实现Callable接口" class="headerlink" title="线程创建方式三-实现Callable接口"></a>线程创建方式三-实现Callable接口</h3><ul><li>定义一个线程任务类实现Callable接口 ， 申明线程执行的结果类型。</li><li>重写线程任务类的call方法，这个方法可以直接返回执行的结果。</li><li>创建一个Callable的线程任务对象。</li><li>把Callable的线程任务对象包装成一个未来任务对象。</li><li>把未来任务对象包装成线程对象。</li><li>调用线程的start()方法启动线程</li></ul><p>这样做的优点是：</p><ul><li>线程任务类只是实现了Callable接口，可以继续继承其他类，而且可以继续实现其他接口（避免了单继承的局限性）</li><li>同一个线程任务对象可以被包装成多个线程对象</li><li>适合多个多个线程去共享同一个资源（后面内容）</li><li>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立。</li><li>线程池可以放入实现Runable或Callable线程任务对象。(后面了解)</li><li>能直接得到线程执行的结果！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建一个Callable的线程任务对象</span><br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        <span class="hljs-comment">// 4.把Callable任务对象包装成一个未来任务对象</span><br>        <span class="hljs-comment">//      -- public FutureTask(Callable&lt;V&gt; callable)</span><br>        <span class="hljs-comment">// 未来任务对象是啥，有啥用？</span><br>        <span class="hljs-comment">//      -- 未来任务对象其实就是一个Runnable对象:这样就可以被包装成线程对象！</span><br>        <span class="hljs-comment">//      -- 未来任务对象可以在线程执行完毕之后去得到线程执行的结果。</span><br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<br>        <span class="hljs-comment">// 5.把未来任务对象包装成线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        <span class="hljs-comment">// 6.启动线程对象</span><br>        t.start();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">10</span> ; i++ )&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; =&gt; &quot;</span> + i);<br>        &#125;<br><br>        <span class="hljs-comment">// 在最后去获取线程执行的结果,如果线程没有结果，让出CPU等线程执行完再来取结果</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 获取call方法返回的结果（正常/异常结果）</span><br>            System.out.println(rs);<br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1.创建一个线程任务类实现Callable接口，申明线程返回的结果类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-comment">// 2.重写线程任务类的call方法！</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：计算1-10的和返回</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">10</span> ; i++ )&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; =&gt; &quot;</span> + i);<br>            sum+=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;执行的结果是：&quot;</span>+sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章-线程安全"><a href="#第五章-线程安全" class="headerlink" title="第五章 线程安全"></a>第五章 线程安全</h2><p>线程安全问题：多个线程同时操作同一个共享资源的时候可能会出现线程安全问题</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul><li><strong>同步代码块</strong>：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ul><p>格式: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>     需要同步操作的代码<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同步锁</strong>:</p><p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ol><li>锁对象 可以是任意类型。</li><li>多个线程对象  要使用同一把锁。</li></ol><blockquote><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p></blockquote><p>使用同步代码块解决代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行卖票操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//每个窗口卖票的操作 </span><br><span class="hljs-comment">//窗口 永远开启 </span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间 </span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">50</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket--);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul><li><strong>同步方法</strong>:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>   可能会产生线程安全问题的代码<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同步锁是谁?</p><p>​      对于非static方法,同步锁就是this。  </p><p>​      对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p></blockquote><p>使用同步方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行卖票操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//每个窗口卖票的操作 </span><br><span class="hljs-comment">//窗口 永远开启 </span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>sellTicket();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 锁对象 是 谁调用这个方法 就是谁 </span><br><span class="hljs-comment"> *   隐含 锁对象 就是  this</span><br><span class="hljs-comment"> *    </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>            <span class="hljs-comment">//出票操作</span><br>            <span class="hljs-comment">//使用sleep模拟一下出票时间 </span><br>            <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              <span class="hljs-comment">// TODO Auto-generated catch block</span><br>              e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//获取当前线程对象的名字 </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket--);<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作,同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大</p><p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li><code>public void lock() </code>:加同步锁。</li><li><code>public void unlock()</code>:释放同步锁。</li></ul><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行卖票操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//每个窗口卖票的操作 </span><br><span class="hljs-comment">//窗口 永远开启 </span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>lock.lock();<br><span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作 </span><br><span class="hljs-comment">//使用sleep模拟一下出票时间 </span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">50</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket--);<br>&#125;<br>lock.unlock();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day8-线程状态、volatile关键字、原子性、并发包、死锁、线程池"><a href="#day8-线程状态、volatile关键字、原子性、并发包、死锁、线程池" class="headerlink" title="day8-线程状态、volatile关键字、原子性、并发包、死锁、线程池"></a>day8-线程状态、volatile关键字、原子性、并发包、死锁、线程池</h1><h2 id="第一章-线程状态"><a href="#第一章-线程状态" class="headerlink" title="第一章 线程状态"></a>第一章 线程状态</h2><h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中<code>java.lang.Thread.State</code>这个枚举中给出了六种线程状态：</p><p>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还没调用start方法。MyThread t &#x3D; new MyThread只有线程对象，没有线程特征。</td></tr><tr><td>Runnable(可运行)</td><td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。调用了t.start()方法   ：就绪（经典教法）</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td>Timed Waiting(计时等待)</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><h3 id="睡眠方法"><a href="#睡眠方法" class="headerlink" title="睡眠方法"></a>睡眠方法</h3><p>我们看到状态中有一个状态叫做计时等待，可以通过Thread类的方法来进行演示.</p><p><code>public static void  sleep(long time)</code>  让当前线程进入到睡眠状态，到毫秒后自动醒来继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>      Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(i)   <br>    &#125; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们发现主线程执行到sleep方法会休眠1秒后再继续执行。</p><h3 id="等待和唤醒"><a href="#等待和唤醒" class="headerlink" title="等待和唤醒"></a>等待和唤醒</h3><p>Object类的方法</p><p><code>public void wait()</code> : 让当前线程进入到等待状态 此方法必须锁对象调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_wait</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>   <span class="hljs-comment">// 步骤1 : 子线程开启,进入无限等待状态, 没有被唤醒,无法继续运行.</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                System.out.println(<span class="hljs-string">&quot;begin wait ....&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-string">&quot;&quot;</span>) &#123;<br>                    <span class="hljs-string">&quot;&quot;</span>.wait();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>public void notify()</code> : 唤醒当前锁对象上等待状态的线程  此方法必须锁对象调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2_notify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>   <span class="hljs-comment">// 步骤1 : 子线程开启,进入无限等待状态, 没有被唤醒,无法继续运行.</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                System.out.println(<span class="hljs-string">&quot;begin wait ....&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-string">&quot;&quot;</span>) &#123;<br>                    <span class="hljs-string">&quot;&quot;</span>.wait();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">//步骤2:  加入如下代码后, 3秒后,会执行notify方法, 唤醒wait中线程.</span><br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-string">&quot;&quot;</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;唤醒&quot;</span>);<br>                    <span class="hljs-string">&quot;&quot;</span>.notify();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章-线程通信"><a href="#第二章-线程通信" class="headerlink" title="第二章 线程通信"></a>第二章 线程通信</h2><ul><li>多个线程因为在同一个进程中，所以互相通信比较容易</li><li>线程通信一定是多个线程在操作同一个资源才需要进行通信</li><li>线程通信必须先保证线程安全，否则毫无意义</li></ul><p>线程通信的核心方法：</p><ul><li><code>public void wait()</code>: 让当前线程进入到等待状态 此方法必须锁对象调用.</li><li><code>public void notify()</code> : 唤醒当前锁对象上等待状态的某个线程  此方法必须锁对象调用</li><li><code>public void notifyAll()</code> : 唤醒当前锁对象上等待状态的全部线程  此方法必须锁对象调用</li></ul><h2 id="第三章-线程池"><a href="#第三章-线程池" class="headerlink" title="第三章 线程池"></a>第三章 线程池</h2><p>线程池:其实就是一个容纳多个线程的容器,其中的线程可以反复的使用，省去了频繁创建和销毁线程对象的操作,无需反复创建线程而消耗过多资源。</p><p>合理利用线程池能够带来三个好处</p><ol><li>降低资源消耗。<br>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度<br>不需要频繁的创建线程，如果有线程可以直接用，不会出现系统僵死！</li><li>提高线程的可管理性（线程池可以约束系统最多只能有多少个线程，不会因为线程过多而死机）</li></ol><blockquote><p> 线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务。</p></blockquote><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>线程池在Java中的代表类：ExecutorService(接口)。</p><p>Java在Executors类下提供了一个静态方法得到一个线程池的对象：<br><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：创建一个线程池返回。</p><ul><li>ExecutorService提交线程任务对象执行的方法：<br><code>Future&lt;?&gt; submit(Runnable task)</code>:提交一个Runnable的任务对象给线程池执行。</li><li><code>Future&lt;?&gt; submit(Callable task)</code>:提交一个Callable的任务对象给线程池执行。</li></ul><blockquote><ul><li><code>pools.shutdown();</code> &#x2F;&#x2F; 等待任务执行完毕以后才会关闭线程池</li><li><code>pools.shutdownNow();</code> &#x2F;&#x2F; 立即关闭线程池的代码，无论任务是否执行完毕</li><li>线程池中的线程可以被复用，线程用完以后可以继续去执行其他任务。</li></ul></blockquote><p><code>Runnable</code>任务对象给线程池执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolsDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// a.创建一个线程池，指定线程的固定数量是3.</span><br>        <span class="hljs-comment">// new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// b.创建线程的任务对象。</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">// c.把线程任务放入到线程池中去执行。</span><br>        pools.submit(target); <span class="hljs-comment">// 提交任务，此时会创建一个新线程,自动启动线程执行！</span><br>        pools.submit(target); <span class="hljs-comment">// 提交任务，此时会创建一个新线程,自动启动线程执行！</span><br>        pools.submit(target); <span class="hljs-comment">// 提交任务，此时会创建一个新线程,自动启动线程执行！</span><br>        pools.submit(target); <span class="hljs-comment">// 不会再创建新线程，会复用之前的线程来处理这个任务</span><br><br>        pools.shutdown(); <span class="hljs-comment">// 等待任务执行完毕以后才会关闭线程池</span><br>        <span class="hljs-comment">//pools.shutdownNow(); // 立即关闭线程池的代码，无论任务是否执行完毕！</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i++ )&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; =&gt; &quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Callable</code>任务对象给线程池执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolsDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// a.创建一个线程池，指定线程的固定数量是3.</span><br>        <span class="hljs-comment">// new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        Future&lt;String&gt; t1 = pools.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 提交任务，此时会创建一个新线程,自动启动线程执行！</span><br>        Future&lt;String&gt; t2 = pools.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">20</span>)); <span class="hljs-comment">// 提交任务，此时会创建一个新线程,自动启动线程执行！</span><br>        Future&lt;String&gt; t3 = pools.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">30</span>)); <span class="hljs-comment">// 提交任务，此时会创建一个新线程,自动启动线程执行！</span><br>        Future&lt;String&gt; t4 = pools.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">40</span>)); <span class="hljs-comment">// 复用之前的某个线程</span><br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// b.可以得到线程池执行的任务结构</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> t1.get();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> t2.get();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs3</span> <span class="hljs-operator">=</span> t3.get();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs4</span> <span class="hljs-operator">=</span> t4.get();<br>            System.out.println(rs1);<br>            System.out.println(rs2);<br>            System.out.println(rs3);<br>            System.out.println(rs4);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1.定义一个线程任务类实现Callable接口 ， 申明线程执行的结果类型。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-comment">// 2.重写线程任务类的call方法，这个方法可以直接返回执行的结果。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= n ; i++)&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; =&gt; &quot;</span>+i);<br>            sum += i ;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;计算1-&quot;</span>+n+<span class="hljs-string">&quot;的和：&quot;</span>+sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-死锁"><a href="#第四章-死锁" class="headerlink" title="第四章 死锁"></a>第四章 死锁</h2><p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>java 死锁产生的四个必要条件：</p><ul><li><strong>互斥使用</strong>，即当资源被一个线程使用(占有)时，别的线程不能使用</li><li><strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li><li><strong>求和保持</strong>，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li><li><strong>循环等待</strong>，即存在一个等待循环队列：p1要p2的资源，p2要p1的资源。这样就形成了一个等待环路</li></ul><p>​    当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失</p><h2 id="第五章-volatile关键字"><a href="#第五章-volatile关键字" class="headerlink" title="第五章 volatile关键字"></a>第五章 volatile关键字</h2><p><strong>问题</strong>：线程修改了某个成员变量的值，但是在主线程中读取到的还是之前的值修改后的值无法读取到。</p><p><strong>原因</strong>：按照JMM模型，所有的成员变量和静态变量都存在于主内存中，主内存中的变量可以被多个线程共享。每个线程都存在一个专属于自己的工作内存，工作内存一开始存储的是成员变量的副本。所以线程很多时候都是直接访问自己工作内存中的该变量，其他线程对主内存变量值的修改将不可见</p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/javabasic/image-20220606111513140.png" alt="image-20220606111513140"></p><p>希望所有线程对于主内存的成员变量修改，其他线程是可见的。</p><ul><li><strong>加锁</strong>：可以实现其他线程对变量修改的可见性<br>某一个线程进入<code>synchronized</code>代码块前后，执行过程入如下：<ul><li>线程获得锁</li><li>清空工作内存</li><li>从主内存拷贝共享变量最新的值到工作内存成为副本</li></ul></li><li>可以给成员变量加上一个<code>volatile</code>关键字，立即就实现了成员变量多线程修改的可见性</li></ul><blockquote><p><code>volatile</code>与<code>synchronized</code>的区别。</p><ul><li><code>volatile</code>只能修饰实例变量和静态变量，而<code>synchronized</code>可以修饰方法，以及代码块。</li><li><code>volatile</code>保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而<code>synchronized</code>是一种排他（互斥）的机制，</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.启动线程，把线程对象中的flag改为true。</span><br>        <span class="hljs-type">VolatileThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileThread</span>();<br>        t.start();<br><br>        <span class="hljs-comment">// 2.定义一个死循环</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 这里读取到了flag值一直是false,虽然线程已经把它的值改成了true。</span><br>            <span class="hljs-keyword">if</span>(t.isFlag())&#123;<br>                System.out.println(<span class="hljs-string">&quot;执行了循环一次~~~~~~~&quot;</span>);<br>            &#125;<br>        &#125;<br>       <span class="hljs-comment">/* while(true)&#123;</span><br><span class="hljs-comment">            synchronized (&quot;ddd&quot;)&#123;</span><br><span class="hljs-comment">                // 这里读取到了flag值一直是false,虽然线程已经把它的值改成了true。</span><br><span class="hljs-comment">                if(t.isFlag())&#123;</span><br><span class="hljs-comment">                    System.out.println(&quot;执行了循环一次~~~~~~~&quot;);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;*/</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 定义成员变量</span><br>    <span class="hljs-comment">// volatile可以实现变量一旦被子线程修改，其他线程可以马上看到它修改后的最新值！</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span> ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFlag</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 将flag的值更改为true</span><br>        <span class="hljs-built_in">this</span>.flag = <span class="hljs-literal">true</span> ;<br>        System.out.println(<span class="hljs-string">&quot;线程修改了flag=&quot;</span> + flag);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第六章-原子性"><a href="#第六章-原子性" class="headerlink" title="第六章 原子性"></a>第六章 原子性</h2><p><strong>原子性</strong>是指在一次操作或者多次操作中，所有的操作全部都得到了执行并且不会受到任何因素的干扰。最终结果要保证线程安全。</p><blockquote><p>在多线程环境下，<code>volatile</code>关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性（在多线程环境下volatile修饰的变量也是线程不安全的）。<br><code>volatile</code>的使用场景</p><ul><li><p>开关控制<br>用可见性特点，控制某一段代码执行或者关闭</p></li><li><p>多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读</p><p>此时加上更好，其他线程可以立即读取到最新值。<code>volatile</code>不能保证变量操作的原子性（安全性）。</p></li></ul></blockquote><h3 id="解决方法一-加锁"><a href="#解决方法一-加锁" class="headerlink" title="解决方法一-加锁"></a>解决方法一-加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileAtomicThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 定义一个int类型的遍历</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 对该变量进行++操作，100次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; x &lt; <span class="hljs-number">100</span> ; x++) &#123;<br>           <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>               count++ ;<br>               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;count =========&gt;&gt;&gt;&gt; &quot;</span> + count);<br>           &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileAtomicThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建VolatileAtomicThread对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileAtomicThread</span>() ;<br>        <span class="hljs-comment">// 开启100个线程对执行这一个任务。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; x &lt; <span class="hljs-number">100</span> ; x++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这种方法虽然安全性得到了保证，但是性能不好</p></blockquote><h3 id="解决方法二-基于CAS方式的原子类"><a href="#解决方法二-基于CAS方式的原子类" class="headerlink" title="解决方法二-基于CAS方式的原子类"></a>解决方法二-基于CAS方式的原子类</h3><p>Java已经提供了一些本身即可实现原子性（线程安全）的类。</p><ul><li>概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。</li><li>操作整型的原子类<ul><li><code>public AtomicInteger()</code>：           初始化一个默认值为0的原子型<code>Integer</code></li><li><code>public AtomicInteger(int initialValue)</code>： 初始化一个指定值的原子型<code>Integer</code></li><li><code>int get()</code>:                                        获取值</li><li><code>int getAndIncrement()</code>:               以原子方式将当前值加1，注意，这里返回的是自增前的值。</li><li><code>int incrementAndGet()</code>:               以原子方式将当前值加1，注意，这里返回的是自增后的值。</li><li><code>int addAndGet(int data)</code>:            以原子方式将输入的数值与实例中的值（<code>AtomicInteger</code>里的value）相加，并返回结果。</li><li><code>int getAndSet(int value)</code>:            以原子方式设置为<code>newValue</code>的值，并返回旧值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileAtomicThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 原子类中封装好了整型变量，默认值是0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 对该变量进行++操作，100次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; x &lt; <span class="hljs-number">100</span> ; x++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> atomicInteger.incrementAndGet(); <span class="hljs-comment">// 底层变量+1且返回！</span><br>            System.out.println(<span class="hljs-string">&quot;count =========&gt;&gt;&gt;&gt; &quot;</span> + count);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileAtomicThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建VolatileAtomicThread对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileAtomicThread</span>() ;<br>        <span class="hljs-comment">// 开启100个线程对执行这一个任务。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; x &lt; <span class="hljs-number">100</span> ; x++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> <strong>CAS与Synchronized总结</strong></p><p> <code>Synchronized</code>是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。因此<code>Synchronized</code>我们也将其称之为<strong>悲观锁</strong>。jdk中的<code>ReentrantLock</code>也是一种悲观锁。性能较差</p><p> <code>CAS</code>是从乐观的角度出发:总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。CAS这种机制我们也可以将其称之为<strong>乐观锁</strong>。综合性能较好</p></blockquote><h2 id="第七章-并发包"><a href="#第七章-并发包" class="headerlink" title="第七章 并发包"></a>第七章 并发包</h2><p>并发包的来历：<br>在实际开发中如果不需要考虑线程安全问题，大家不需要做线程安全，因为如果做了反而性能不好！<br>但是开发中有很多业务是需要考虑线程安全问题的，此时就必须考虑了。否则业务出现问题。<br>Java为很多业务场景提供了性能优异，且线程安全的并发包，程序员可以选择使用！</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><code>Map</code>集合中的经典集合：<code>HashMap</code>它是线程不安全的，性能好，如果在要求线程安全的业务情况下就不能用这个集合做Map集合，否则业务会崩溃</p><p>为了保证线程安全，可以使用<code>Hashtable</code>。注意：线程中加入了计时，<code>Hashtable</code>是线程安全的<code>Map</code>集合，但是性能较差！(已经被淘汰了，虽然安全，但是性能差)</p><p>为了保证线程安全，再看<code>ConcurrentHashMap</code>（不止线程安全，而且效率高，性能好，最新最好用的线程安全的Map集合）<code>ConcurrentHashMap</code>保证了线程安全，综合性能较好！</p><blockquote><ul><li><code>HashMap</code>是线程不安全的。</li><li><code>Hashtable</code>线程安全基于<code>synchronized</code>，综合性能差,被淘汰了。</li><li><code>ConcurrentHashMap</code>：线程安全的，分段式锁，综合性能最好，线程安全开发中推荐使用</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentHashMapDemo</span> &#123;<br>    <span class="hljs-comment">// 定义一个静态的HashMap集合，只有一个容器。</span><br>    <span class="hljs-comment">// public static Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-comment">//public static Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// HashMap线程不安全演示。</span><br>        <span class="hljs-comment">// 需求：多个线程同时往HashMap容器中存入数据会出现安全问题。</span><br>        <span class="hljs-comment">// 具体需求：提供2个线程分别给map集合加入50万个数据！</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddMapDataThread</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddMapDataThread</span>().start();<br><br>        <span class="hljs-comment">//休息10秒，确保两个线程执行完毕</span><br>        Thread.sleep(<span class="hljs-number">1000</span> * <span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//打印集合大小</span><br>        System.out.println(<span class="hljs-string">&quot;Map大小：&quot;</span> + map.size());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddMapDataThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000000</span> ; i++ )&#123;<br>            ConcurrentHashMapDemo.map.put(Thread.currentThread().getName()+<span class="hljs-string">&quot;键：&quot;</span>+i , <span class="hljs-string">&quot;值&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作，再执行自己。</p><p>例如：</p><p>线程1要执行打印：A和C，线程2要执行打印：B，但线程1在打印A后，要线程2打印B之后才能打印C，所以：线程1在打印A后，必须等待线程2打印完B之后才能继续执行</p><p>需求：</p><p>提供A线程，打印 A , C<br>提供B线程，打印 B</p><p>构造器：</p><p><code>public CountDownLatch(int count)</code>&#x2F;&#x2F; 初始化唤醒需要的down几步。</p><p>方法：<br><code>public void await() throws InterruptedException</code>&#x2F;&#x2F; 让当前线程等待，必须down完初始化的数字才可以被唤醒，否则进入无限等待<br><code>public void countDown()</code>    &#x2F;&#x2F; 计数器进行减1 （down 1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建1个计数器：用来控制 A , B线程的执行流程的。</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(down).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(down).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> CountDownLatch down;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(CountDownLatch down)</span>&#123;<br>        <span class="hljs-built_in">this</span>.down = down;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            down.await(); <span class="hljs-comment">// A线程你进入等待，让B线程执行自己！</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> CountDownLatch down;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(CountDownLatch down)</span>&#123;<br>        <span class="hljs-built_in">this</span>.down = down;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>        down.countDown(); <span class="hljs-comment">// 这里相当于是-1，代表自己执行完毕了。A线程被唤醒！！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p><code>CyclicBarrier</code>作用：某个线程任务必须等待其他线程执行完毕以后才能最终触发自己执行。</p><p>例如：公司召集5名员工开会，等5名员工都到了，会议开始。我们创建5个员工线程，1个开会任务，几乎同时启动。使用<code>CyclicBarrier</code>保证5名员工线程全部执行后，再执行开会线程。</p><p>构造器：<br><code>public CyclicBarrier(int parties, Runnable barrierAction)</code><br>     &#x2F;&#x2F; 用于在线程到达屏障5时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景<br>方法：<br>   <code>  public int await()</code><br>     &#x2F;&#x2F; 每个线程调用await方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞</p><blockquote><ul><li>可以实现多线程中，某个任务在等待其他线程执行完毕以后触发。</li><li>循环屏障可以实现达到一组屏障就触发一个任务执行！</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个任务循环屏障对象。</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数一：代表多少个线程的执行。</span><br><span class="hljs-comment">         * 参数二：到达执行屏障就开始触发的线程任务。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">5</span> , <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeetingRunnable</span>());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeopleThread</span>(cb).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任务类：开始开会的任务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MeetingRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;人员到齐了开始由&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;主持会议！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 员工类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PeopleThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> CyclicBarrier cb ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PeopleThread</span><span class="hljs-params">(CyclicBarrier cb)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cb = cb;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;员工：&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;进入会议室&quot;</span>);<br>            cb.await(); <span class="hljs-comment">// 自己做完了，告诉循环屏障我结束了！</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul><li><p><code>Semaphore</code>（发信号）的主要作用是控制线程的并发数量。</p></li><li><p><code>synchronized</code>可以起到”锁”的作用，但某个时间段内，只能有一个线程允许执行。</p></li><li><p><code>Semaphore</code>可以设置同时允许几个线程执行。</p></li><li><p><code>Semaphore</code>字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。</p></li></ul><p><code>Semaphore</code>的构造器：</p><ul><li><code>public Semaphore(int permits)</code>：    permits 表示许可线程的数量</li><li><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程</li></ul><p><code>Semaphore</code>的方法：</p><ul><li><code>public void acquire() throws InterruptedException</code> 表示获取许可</li><li><code>public void release() release()</code> 表示释放许可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Service</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(service,<span class="hljs-string">&quot;线程：&quot;</span>+i).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 执行的任务。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span>&#123;<br>    <span class="hljs-comment">// 可以同时支持多个线程进入共享资源区执行。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMethod</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">startTimer</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            System.out.println(<span class="hljs-string">&quot;进入时间：&quot;</span>+startTimer);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;进入资源执行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimer</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;结束时间：&quot;</span>+endTimer);<br>        semaphore.release();<br>        <span class="hljs-comment">//acquire()和release()方法之间的代码为&quot;同步代码&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Service service;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(Service service , String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.service = service;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        service.showMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p> Exchanger构造方法：public Exchanger()</p><p> Exchanger重要方法：public V exchange(V x)</p><p> 分析：<br>    （1）需要2个线程<br>    （2）需要一个交换对象负责交换两个线程执行的结果。</p><blockquote><ul><li>Exchanger可以实现线程间的数据交换。</li><li>一个线程如果等不到对方的数据交换就会一直等待。</li><li>我们也可以控制一个线程等待的时间。</li><li>必须双方都进行交换才可以正常进行数据的交换。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建交换对象（信使）</span><br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br>        <span class="hljs-comment">// 创建2给线程对象。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(exchanger).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(exchanger).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; exchanger;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span> &#123;<br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 礼物A</span><br>            System.out.println(<span class="hljs-string">&quot;线程A,做好了礼物A,等待线程B送来的礼物B.....&quot;</span>);<br>            <span class="hljs-comment">// 开始交换礼物。参数是送给其他线程的礼物!</span><br>            <span class="hljs-comment">// System.out.println(&quot;线程A收到线程B的礼物：&quot;+exchanger.exchange(&quot;礼物A&quot;));</span><br>            <span class="hljs-comment">// 如果等待了5s还没有交换它就去死（抛出异常）！</span><br>            System.out.println(<span class="hljs-string">&quot;线程A收到线程B的礼物：&quot;</span>+exchanger.exchange(<span class="hljs-string">&quot;礼物A&quot;</span>, <span class="hljs-number">5</span> , TimeUnit.SECONDS));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程A等待了5s，没有收到礼物,最终就执行结束了!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; exchanger;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span> &#123;<br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 礼物B</span><br>             System.out.println(<span class="hljs-string">&quot;线程B,做好了礼物B,等待线程A送来的礼物A.....&quot;</span>);<br>            <span class="hljs-comment">// 开始交换礼物。参数是送给其他线程的礼物!</span><br>             System.out.println(<span class="hljs-string">&quot;线程B收到线程A的礼物：&quot;</span>+exchanger.exchange(<span class="hljs-string">&quot;礼物B&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day9-方法引用、Lambda表达式、Stream流"><a href="#day9-方法引用、Lambda表达式、Stream流" class="headerlink" title="day9-方法引用、Lambda表达式、Stream流"></a>day9-方法引用、Lambda表达式、Stream流</h1><h2 id="第一章-方法引用"><a href="#第一章-方法引用" class="headerlink" title="第一章 方法引用"></a>第一章 方法引用</h2><h3 id="方法引用概述"><a href="#方法引用概述" class="headerlink" title="方法引用概述"></a>方法引用概述</h3><p>方法引用是为了进一步简化Lambda表达式的写法。</p><p>方法引用的格式：类型或者对象::引用的方法。</p><p>方法引用有四种形式：</p><ul><li>静态方法的引用</li><li>实例方法的引用</li><li>特定类型方法的引用</li><li>构造器引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ist&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java3&quot;</span>);<br><br>lists.forEach( s -&gt; System.out.println(s));<br><span class="hljs-comment">// 方法引用！</span><br>lists.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>引用格式：类名::静态方法</p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去。</p><p>静态方法引用的注意事项：<strong>被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致</strong></p><p><code>Student</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareByAge</span><span class="hljs-params">(Student o1 , Student o2)</span>&#123;<br>        <span class="hljs-keyword">return</span>  o1.getAge() - o2.getAge();<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;李铭&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;冯龙&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;王乐乐&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br>Collections.addAll(lists , s1 , s2 , s3);<br><br>Collections.sort(lists, ( o1, o2) -&gt; Student.compareByAge(o1 , o2));<br><span class="hljs-comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span><br>Collections.sort(lists, Student::compareByAge);<br></code></pre></td></tr></table></figure><h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>格式： 对象::实例方法</p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去。</p><p>实例方法引用的注意事项：<strong>被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java3&quot;</span>);<br><br><span class="hljs-comment">// 对象是 System.out = new PrintStream();</span><br><span class="hljs-comment">// 实例方法：println()</span><br><span class="hljs-comment">// 前后参数正好都是一个</span><br>lists.forEach(s -&gt; System.out.println(s));<br>lists.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="特定类型方法的引用"><a href="#特定类型方法的引用" class="headerlink" title="特定类型方法的引用"></a>特定类型方法的引用</h3><p>特定类型：String ,任何类型</p><p>格式：特定类型::方法</p><p>注意：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>,<br>                             <span class="hljs-string">&quot;Patricia&quot;</span>,<span class="hljs-string">&quot;Dlei&quot;</span> , <span class="hljs-string">&quot;Robert&quot;</span>,<span class="hljs-string">&quot;Boom&quot;</span>, <span class="hljs-string">&quot;Cao&quot;</span> ,<span class="hljs-string">&quot;black&quot;</span> ,<br>                             <span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-string">&quot;Linda&quot;</span>,<span class="hljs-string">&quot;cao&quot;</span>,<span class="hljs-string">&quot;after&quot;</span>,<span class="hljs-string">&quot;sBBB&quot;</span>&#125;;<br><br><span class="hljs-comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</span><br><span class="hljs-comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span><br>Arrays.sort(strs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.compareToIgnoreCase(s2);<span class="hljs-comment">// 按照元素的首字符(忽略大小写)比较。</span><br>    &#125;<br>&#125;);<br>Arrays.sort(strs, (String s1, String s2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> s1.compareToIgnoreCase(s2);<span class="hljs-comment">// 按照元素的首字符(忽略大小写)比较。</span><br>&#125;);<br><br>Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));<br><br><span class="hljs-comment">// 特定类型的方法引用：</span><br>Arrays.sort(strs,  String::compareToIgnoreCase);<br><br>System.out.println(Arrays.toString(strs));<br></code></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式是：类名::new</p><p>注意点：前后参数一致的情况下，又在创建对象就可以使用构造器引用<code>s -&gt; new Student(s) =&gt; Student::new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>lists.add(<span class="hljs-string">&quot;java3&quot;</span>);<br><br><span class="hljs-comment">// 集合默认只能转成Object类型的数组。</span><br>Object[] objs = lists.toArray();<br>System.out.println(<span class="hljs-string">&quot;Object类型的数组：&quot;</span>+ Arrays.toString(objs));<br><br><span class="hljs-comment">// 我们想指定转换成字符串类型的数组！！</span><br><span class="hljs-comment">// 最新的写法可以结合构造器引用实现 。</span><br><span class="hljs-comment">// default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator)</span><br>String[] strs = lists.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntFunction</span>&lt;String[]&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] apply(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[value];<br>    &#125;<br>&#125;);<br><br>String[] strs1 = lists.toArray(s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[s] );<br><br>String[] strs2 = lists.toArray(String[]::<span class="hljs-keyword">new</span>);<br><br>System.out.println(<span class="hljs-string">&quot;String类型的数组：&quot;</span>+ Arrays.toString(strs2));<br></code></pre></td></tr></table></figure><h2 id="第二章-Lambda表达式"><a href="#第二章-Lambda表达式" class="headerlink" title="第二章 Lambda表达式"></a>第二章 Lambda表达式</h2><p>Lambda表达式是JDK1.8开始之后的新技术，是一种代码的新语法，作用是为了简化匿名内部类的代码写法</p><p>Lambda表达式的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(匿名内部类被重写方法的形参列表) -&gt; &#123;<br><span class="hljs-comment">// 被重写方法的方法代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda表达式的使用前提：</p><ul><li>Lambda表达式并不能简化所有匿名内部类的写法。</li><li>Lambda表达式只能简化接口中只有一个抽象方法的匿名内部类形式。</li></ul><p>Lambda表达式<strong>只能简化函数式接口的匿名内部类写法</strong>：</p><ul><li>首先必须是接口</li><li>接口中只能有一个抽象方法</li></ul><h3 id="Lambda表达式简化Runnable接口匿名内部类"><a href="#Lambda表达式简化Runnable接口匿名内部类" class="headerlink" title="Lambda表达式简化Runnable接口匿名内部类"></a>Lambda表达式简化Runnable接口匿名内部类</h3><p><code>@FunctionalInterface</code>函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法。<br>   这个接口就可以被Lambda表达式简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:执行~~~&quot;</span>);<br>    &#125;<br>&#125;);<br>t.start();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:执行~~~&quot;</span>);<br>&#125;);<br>t1.start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:执行~~~&quot;</span>);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:执行~~~&quot;</span>)).start();<br></code></pre></td></tr></table></figure><h3 id="Lambda表达式简化Comparator接口匿名内部类写法"><a href="#Lambda表达式简化Comparator接口匿名内部类写法" class="headerlink" title="Lambda表达式简化Comparator接口匿名内部类写法"></a>Lambda表达式简化Comparator接口匿名内部类写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;李铭&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;冯龙&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;王乐乐&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br>Collections.addAll(lists , s1 , s2 , s3);<br><br><span class="hljs-comment">// 按照年龄进行升序排序！</span><br>Collections.sort(lists, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student s1, Student s2)</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.getAge() - s2.getAge();<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 简化写法</span><br>Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> t1.getAge() - t2.getAge();<br>&#125;);<br><br>Collections.sort(lists ,(Student t1, Student t2) -&gt; t1.getAge() - t2.getAge());<br><br><span class="hljs-comment">// 参数类型可以省略</span><br>Collections.sort(lists ,( t1,  t2) -&gt; t1.getAge() - t2.getAge());<br><br>System.out.println(lists);<br></code></pre></td></tr></table></figure><h3 id="Lambda表达式的省略写法"><a href="#Lambda表达式的省略写法" class="headerlink" title="Lambda表达式的省略写法"></a>Lambda表达式的省略写法</h3><p>Lambda表达式的省略写法（进一步在Lambda表达式的基础上继续简化）</p><ul><li>如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写,同时要省略分号</li><li>如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是return语句，必须省略return不写，同时也必须省略”;”不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时()也可以省略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;胡伟光&quot;</span>);<br>names.add(<span class="hljs-string">&quot;甘挺&quot;</span>);<br>names.add(<span class="hljs-string">&quot;洪磊&quot;</span>);<br><br>names.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;);<br><br>names.forEach((String s) -&gt; &#123;<br>    System.out.println(s);<br>&#125;);<br><br>names.forEach((s) -&gt; &#123;<br>    System.out.println(s);<br>&#125;);<br><br>names.forEach(s -&gt; &#123;<br>    System.out.println(s);<br>&#125;);<br><br>names.forEach(s -&gt; System.out.println(s) );<br><br>names.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h2 id="第三章-Stream流"><a href="#第三章-Stream流" class="headerlink" title="第三章 Stream流"></a>第三章 Stream流</h2><h3 id="Stream流概述"><a href="#Stream流概述" class="headerlink" title="Stream流概述"></a>Stream流概述</h3><p>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream流概念 ，用于解决已有集合&#x2F;数组类库有的弊端。</p><p>Stream流能解决什么问题：</p><ul><li>可以解决已有集合类库或者数组API的弊端。</li><li>Stream认为集合和数组操作的API很不好用，所以采用了Stream流简化集合和数组的操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter( s -&gt; s.length()== <span class="hljs-number">3</span> )<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="Stream流的获取"><a href="#Stream流的获取" class="headerlink" title="Stream流的获取"></a>Stream流的获取</h3><p>Stream流式思想的核心：</p><ul><li>是先得到集合或者数组的Stream流（就是一根传送带）</li><li>然后就用这个Stream流操作集合或者数组的元素</li><li>然后用Stream流简化替代集合操作的API</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Stream&lt;String&gt; ss = c.stream();<br><br><span class="hljs-comment">/** --------------------Map集合获取流-------------------------------   */</span><br>Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">// 先获取键的Stream流。</span><br>Stream&lt;String&gt; keyss = map.keySet().stream();<br><span class="hljs-comment">// 在获取值的Stream流</span><br>Stream&lt;Integer&gt; valuess = map.values().stream();<br><span class="hljs-comment">// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）</span><br>Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();<br><br><span class="hljs-comment">/** ---------------------数组获取流------------------------------   */</span><br><span class="hljs-comment">// 数组也有Stream流。</span><br>String[] arrs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;JavaEE&quot;</span> ,<span class="hljs-string">&quot;Spring Boot&quot;</span>&#125;;<br>Stream&lt;String&gt; arrsSS1 = Arrays.stream(arrs);<br>Stream&lt;String&gt; arrsSS2 = Stream.of(arrs);<br></code></pre></td></tr></table></figure><h3 id="Stream流的常用API"><a href="#Stream流的常用API" class="headerlink" title="Stream流的常用API"></a>Stream流的常用API</h3><ul><li><p><code>forEach </code>: 逐一处理(遍历)</p></li><li><p><code>count</code>：统计个数</p><p><code>long count();</code></p></li><li><p><code>filter</code>: 过滤元素</p></li><li><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></p></li><li><p><code>limit</code>: 取前几个元素</p></li><li><p><code>skip</code>: 跳过前几个</p></li><li><p><code>map</code> : 加工方法</p><p>把原来的元素加工以后，重新放上去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends R&gt; mapper)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>concat </code>: 合并流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">concat</span><span class="hljs-params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>list.stream().filter( s -&gt; s.length() == <span class="hljs-number">3</span> ).filter( s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>    .forEach( System.out::println);<br><span class="hljs-comment">// 统计数量</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream().filter( s -&gt; s.length() == <span class="hljs-number">3</span> )<br>    .filter( s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).count();<br>System.out.println(count);<br><span class="hljs-comment">// 取前2个</span><br>list.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).limit(<span class="hljs-number">2</span>)<br>    .forEach(System.out::println);<br><span class="hljs-comment">// 跳过前2个</span><br>list.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).skip(<span class="hljs-number">2</span>)<br>    .forEach(System.out::println);<br><span class="hljs-comment">// 把名称加工成学生对象放入list中</span><br>list.stream().map(Student::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>合并流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br><span class="hljs-comment">// 数组流</span><br>Stream&lt;Integer&gt; s1 = Stream.of(<span class="hljs-number">10</span>, <span class="hljs-number">20</span> ,<span class="hljs-number">30</span> ,<span class="hljs-number">40</span>);<br><span class="hljs-comment">// 集合流</span><br>Stream&lt;String&gt; s2 = list.stream();<br><span class="hljs-comment">// 合并流</span><br>Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);<br>s3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="Stream流的综合应用"><a href="#Stream流的综合应用" class="headerlink" title="Stream流的综合应用"></a>Stream流的综合应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>one.add(<span class="hljs-string">&quot;迪丽热巴&quot;</span>);<br>one.add(<span class="hljs-string">&quot;宋远桥&quot;</span>);<br>one.add(<span class="hljs-string">&quot;苏星河&quot;</span>);<br>one.add(<span class="hljs-string">&quot;老子&quot;</span>);<br>one.add(<span class="hljs-string">&quot;庄子&quot;</span>);<br>one.add(<span class="hljs-string">&quot;孙子&quot;</span>);<br>one.add(<span class="hljs-string">&quot;洪七公&quot;</span>);<br><br>List&lt;String&gt; two = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>two.add(<span class="hljs-string">&quot;古力娜扎&quot;</span>);<br>two.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>two.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>two.add(<span class="hljs-string">&quot;赵丽颖&quot;</span>);<br>two.add(<span class="hljs-string">&quot;张二狗&quot;</span>);<br>two.add(<span class="hljs-string">&quot;张天爱&quot;</span>);<br>two.add(<span class="hljs-string">&quot;张三&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1. 第一个队伍只要名字为3个字的成员姓名；</span><br><span class="hljs-comment">         * 2. 第一个队伍筛选之后只要前3个人；</span><br><span class="hljs-comment">         */</span><br>Stream&lt;String&gt; oneStream =<br>    one.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).limit(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 3. 第二个队伍只要姓张的成员姓名；</span><br><span class="hljs-comment">         * 4. 第二个队伍筛选之后不要前2个人；</span><br><span class="hljs-comment">         * 5. 将两个队伍合并为一个队伍；</span><br><span class="hljs-comment">         */</span><br>Stream&lt;String&gt; twoStream =<br>    two.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).skip(<span class="hljs-number">2</span>);<br><br>Stream&lt;String&gt; allStream = Stream.concat(oneStream , twoStream);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 6. 根据姓名创建`Student`对象； (加工)</span><br><span class="hljs-comment">         * 7. 打印整个队伍的Student对象信息。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//allStream.map(s -&gt; new Student(s)).forEach(System.out::println);</span><br>allStream.map(Student::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="Stream流的终结与非终结方法"><a href="#Stream流的终结与非终结方法" class="headerlink" title="Stream流的终结与非终结方法"></a>Stream流的终结与非终结方法</h3><p>一旦Stream调用了终结方法，流的操作就全部终结了，不能继续使用，只能创建新的Stream操作。</p><p>终结方法： <code>foreach </code>, <code>count</code></p><p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持链式编程！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br><span class="hljs-comment">// foreach终结方法</span><br>list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>    .filter(s -&gt; s.length() == <span class="hljs-number">3</span>).forEach(System.out::println);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span>  list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>    .filter(s -&gt; s.length() == <span class="hljs-number">3</span>).count();<br>System.out.println(count);<br></code></pre></td></tr></table></figure><h3 id="收集Stream流"><a href="#收集Stream流" class="headerlink" title="收集Stream流"></a>收集Stream流</h3><p>收集Stream流:把Stream流的数据转回成集合。</p><p>Stream的作用是：把集合转换成一根传送带，借用Stream流的强大功能进行的操作。但是实际开发中数据最终的形式还是应该是集合，最终Stream流操作完毕以后还是要转换成集合。这就是收集Stream流。</p><p>收集Stream流的含义：就是把Stream流的数据转回到集合中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>Stream&lt;String&gt; zhangLists = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br><span class="hljs-comment">// 把stream流转换成Set集合。</span><br>Set&lt;String&gt; sets = zhangLists.collect(Collectors.toSet());<br>System.out.println(sets);<br><br><span class="hljs-comment">// 把stream流转换成List集合。</span><br>Stream&lt;String&gt; zhangLists1 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>List&lt;String&gt; lists= zhangLists1.collect(Collectors.toList());<br>System.out.println(lists);<br><br><span class="hljs-comment">// 把stream流转换成数组。</span><br>Stream&lt;String&gt; zhangLists2 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>Object[] arrs = zhangLists2.toArray();<br><span class="hljs-comment">// 可以借用构造器引用申明转换成的数组类型！！！</span><br><span class="hljs-comment">//String[] arrs1 = zhangLists2.toArray(String[]::new);</span><br></code></pre></td></tr></table></figure><h2 id="第四章-File类"><a href="#第四章-File类" class="headerlink" title="第四章 File类"></a>第四章 File类</h2><h3 id="File类的概述"><a href="#File类的概述" class="headerlink" title="File类的概述"></a>File类的概述</h3><p>File类：代表操作系统的文件对象</p><p>File类：是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹）…</p><p>广义来说操作系统认为文件包含（文件和文件夹）</p><p>File类的创建文件对象的API:</p><ul><li>包：<code>java.io.File</code></li><li>构造器：<ul><li><code>public File(String pathname)</code>:根据路径获取文件对象</li><li><code>public File(String parent, String child)</code>:根据父路径和文件名称获取文件对象！</li></ul></li></ul><p>File类创建文件对象的格式:</p><ul><li><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code><ul><li><strong>绝对路径</strong>：从磁盘的的盘符一路走到目的位置的路径。<ul><li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错！！</li><li>一般是定位某个操作系统中的某个文件对象。</li></ul></li><li><strong>相对路径</strong>：不带盘符的。（重点）<ul><li>默认是直接相对到工程目录下寻找文件的。</li><li>相对路径只能用于寻找工程下的文件。</li><li>能用相对路径就应该尽量使用，可以跨平台！</li></ul></li></ul></li><li><code>File f = new File(&quot;文件对象/文件夹对象&quot;);</code><br>广义来说：文件是包含文件和文件夹的。</li></ul><blockquote><ul><li>创建文件对象可以用绝对路径也可以用相对路径。</li><li>相对路径只能用于寻找工程下的文件。</li><li>文件对象可以表示文件也可以表示文件夹！</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast\\图片资源\\beautiful.jpg&quot;</span>);<br>System.out.println(f1.length()); <span class="hljs-comment">// 获取文件的大小，字节大小</span><br><br><span class="hljs-comment">// 2.创建文件对象：使用相对路径</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day09Demo/src/dlei01.txt&quot;</span>);<br>System.out.println(f2.length());<br><br><span class="hljs-comment">// 3.创建文件对象：代表文件夹。</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast\\图片资源&quot;</span>);<br>System.out.println(f3.exists());<span class="hljs-comment">// 判断路径是否存在！！</span><br></code></pre></td></tr></table></figure><h3 id="File类的获取功能的方法"><a href="#File类的获取功能的方法" class="headerlink" title="File类的获取功能的方法"></a>File类的获取功能的方法</h3><ul><li><code>public String getAbsolutePath()</code>  ：返回此File的绝对路径名字符串。</li><li><code>public String getPath()</code>  ： 获取创建文件对象的时候用的路径</li><li><code>public String getName()</code>  ： 返回由此File表示的文件或目录的名称。</li><li><code>public long length()</code>  ：    返回由此File表示的文件的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.绝对路径创建一个文件对象</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/itcast/图片资源/meinv.jpg&quot;</span>);<br><span class="hljs-comment">// a.获取它的绝对路径。</span><br>System.out.println(f1.getAbsolutePath());<br><span class="hljs-comment">// b.获取文件定义的时候使用的路径。</span><br>System.out.println(f1.getPath());<br><span class="hljs-comment">// c.获取文件的名称：带后缀。</span><br>System.out.println(f1.getName());<br><span class="hljs-comment">// d.获取文件的大小：字节个数。</span><br>System.out.println(f1.length());<br><br>System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br><br><span class="hljs-comment">// 2.相对路径</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day09Demo/src/dlei01.txt&quot;</span>);<br><span class="hljs-comment">// a.获取它的绝对路径。</span><br>System.out.println(f2.getAbsolutePath());<br><span class="hljs-comment">// b.获取文件定义的时候使用的路径。</span><br>System.out.println(f2.getPath());<br><span class="hljs-comment">// c.获取文件的名称：带后缀。</span><br>System.out.println(f2.getName());<br><span class="hljs-comment">// d.获取文件的大小：字节个数。</span><br>System.out.println(f2.length());<br></code></pre></td></tr></table></figure><h3 id="File类的判断功能的方法"><a href="#File类的判断功能的方法" class="headerlink" title="File类的判断功能的方法"></a>File类的判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code>：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.文件对象。</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast\\图片资源\\meinv.jpg&quot;</span>);<br><span class="hljs-comment">// a.判断文件路径是否存在</span><br>System.out.println(f1.exists()); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span><br>System.out.println(f1.isFile()); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span><br>System.out.println(f1.isDirectory()); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 1.文件对象。</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast\\图片资源&quot;</span>);<br><span class="hljs-comment">// a.判断文件路径是否存在</span><br>System.out.println(f2.exists()); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span><br>System.out.println(f2.isFile()); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span><br>System.out.println(f2.isDirectory()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="File类的创建和删除方法"><a href="#File类的创建和删除方法" class="headerlink" title="File类的创建和删除方法"></a>File类的创建和删除方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，<br>创建一个新的空文件。 （几乎不用的，因为以后文件都是自动创建的！）</li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。 （只能删除空目录）</li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。（只能创建一级目录）</li><li><code>public boolean mkdirs()</code> ：可以创建多级目录（建议使用的）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day09Demo/src/dlei02.txt&quot;</span>);<br><span class="hljs-comment">// a.创建新文件，创建成功返回true ,反之</span><br>System.out.println(f.createNewFile());<br><br><span class="hljs-comment">// b.删除文件或者空文件夹</span><br>System.out.println(f.delete());<br><span class="hljs-comment">// 不能删除非空文件夹，只能删除空文件夹</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/itcast/aaaaa&quot;</span>);<br>System.out.println(f1.delete());<br><br><span class="hljs-comment">// c.创建一级目录</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/itcast/bbbb&quot;</span>);<br>System.out.println(f2.mkdir());<br><br><span class="hljs-comment">// d.创建多级目录</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/itcast/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;</span>);<br>System.out.println(f3.mkdirs());<br></code></pre></td></tr></table></figure><h3 id="File目录的遍历"><a href="#File目录的遍历" class="headerlink" title="File目录的遍历"></a>File目录的遍历</h3><ul><li><code>public String[] list()</code><br>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</li><li><code>public File[] listFiles()</code>&#x3D;&#x3D;常用&#x3D;&#x3D;<br>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;day09/src/com/itheima&quot;</span>);<br><span class="hljs-comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。</span><br>String[] names = dir.list();<br><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    System.out.println(name);<br>&#125;<br><span class="hljs-comment">// b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。</span><br>File[] files = dir.listFiles();<br><span class="hljs-keyword">for</span> (File file : files) &#123;<br>    System.out.println(file.getAbsolutePath());<br>&#125;<br><br><span class="hljs-comment">// ---------拓展------------</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Documents\\codes\\notes\\java-notes\\java补充知识点\\codes\\seniorJava\\day09\\src\\com\\itheima\\_20File目录的遍历\\FileDemo.java&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> f1.lastModified(); <span class="hljs-comment">// 最后修改时间！</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(sdf.format(time));<br></code></pre></td></tr></table></figure><h2 id="第五章-递归"><a href="#第五章-递归" class="headerlink" title="第五章 递归"></a>第五章 递归</h2><h3 id="递归的概述"><a href="#递归的概述" class="headerlink" title="递归的概述"></a>递归的概述</h3><p>方法在方法中又调用了自己</p><ul><li>直接递归：自己的方法调用自己</li><li>间接递归：自己的方法调用别的方法，别的方法又调用自己</li></ul><blockquote><ul><li>递归是自己调用自己。</li><li>递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误！！</li><li>递归应该防止进入递归的死循环！</li></ul></blockquote><p>一个简单的例子，计算<br>$$<br>f(x) &#x3D; f(x-1) + 1<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f(<span class="hljs-number">10</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> f(x - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归的核心"><a href="#递归的核心" class="headerlink" title="递归的核心"></a>递归的核心</h3><p>递归算法分为三个要素：</p><ul><li><p>递归公式<br>$$<br>f(x)&#x3D;f(x)+1<br>$$</p></li><li><p>递归终结点<br>$$<br>f(1)&#x3D;1<br>$$</p></li><li><p>递归方向</p><p>必须走向终结点</p></li></ul><p>必须满足三要素，否则递归会出现死亡</p><h3 id="递归实现文件搜索"><a href="#递归实现文件搜索" class="headerlink" title="递归实现文件搜索"></a>递归实现文件搜索</h3><p>这是一个非规律递归，实现步骤是：</p><ul><li>定义一个方法用于做搜索</li><li>进入方法中进行业务搜索分析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 去某个目录下搜索某个文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dir 搜索文件的目录。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 搜索文件的名称。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFiles</span><span class="hljs-params">(File dir , String fileName)</span>&#123;<br>    <span class="hljs-comment">// 1.判断是否存在该路径，是否是文件夹</span><br>    <span class="hljs-keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory())&#123;<br>        <span class="hljs-comment">// 2.提取当前目录下的全部一级文件对象</span><br>        File[] files = dir.listFiles(); <span class="hljs-comment">// null/[]</span><br>        <span class="hljs-comment">// 3.判断是否存在一级文件对象（判断是否不为空目录）</span><br>        <span class="hljs-keyword">if</span>(files!=<span class="hljs-literal">null</span> &amp;&amp; files.length &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 4.判断一级文件对象</span><br>            <span class="hljs-keyword">for</span> (File f : files) &#123;<br>                <span class="hljs-comment">// 5.判断file是文件还是文件夹</span><br>                <span class="hljs-keyword">if</span>(f.isFile())&#123;<br>                    <span class="hljs-comment">// 6.判断该文件是否为我要找的文件对象</span><br>                    <span class="hljs-keyword">if</span>(f.getName().contains(fileName))&#123;<br>                        System.out.println(f.getAbsolutePath());<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 启动它（拓展）</span><br>                            <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                            r.exec(f.getAbsolutePath());<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 7.该文件是文件夹，文件夹要递归进入继续寻找</span><br>                    searchFiles(f ,fileName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第六章-字节流"><a href="#第六章-字节流" class="headerlink" title="第六章 字节流"></a>第六章 字节流</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集：各个国家为自己国家的字符取的一套编号规则。计算机的底层是不能直接存储字符的。计算机的底层只能存储二进制。010101二进制就是可以转成10进制的。10进制就是整数编号。101 &#x3D; 1<em>2^0 + 0</em>2^1 + 1*2^2 &#x3D; 5</p><ul><li>中国用的编码：GBK编码</li><li>美国用的编码：ACSII编码</li></ul><h3 id="IO流读写数据"><a href="#IO流读写数据" class="headerlink" title="IO流读写数据"></a>IO流读写数据</h3><p>IO输入输出流：输入&#x2F;输出流。</p><ul><li>Input:输入。</li><li>Output:输出。</li></ul><p>引入：<br>File类只能操作文件对象本身，不能读写文件对象的内容。<br>读写数据内容，应该使用IO流。</p><p>IO流是一个水流模型：IO理解成水管，把数据理解成水流。</p><p>IO流的分类</p><p>按照流的方向分为：输入流，输出流。</p><ul><li>输出流：以内存为基准，把内存中的数据写出到磁盘文件或者网络介质中去的流称为输出流。<br>输出流的作用：写数据到文件，或者写数据发送给别人。</li><li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据读入到内存中去的流称为输入流。<br>输入流的作用：读取数据到内存。</li></ul><p>按照流的内容分为: 字节流，字符流。</p><ul><li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流。</li><li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流。(针对于文本内容)</li></ul><p>所以流大体分为四大类:</p><ul><li>字节输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据以一个一个的字节的形式读入到内存中去的流称为字节输入流。</li><li>字节输出流：以内存为基准，把内存中的数据以一个一个的字节写出到磁盘文件或者网络介质中去的流称为字节输出流。</li><li>字符输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据以一个一个的字符的形式读入到内存中去的流称为字符输入流。</li><li>字符输出流：以内存为基准，把内存中的数据以一个一个的字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</li></ul><blockquote><p> IO流是读写传输数据的，IO流有很多种，每种流有自己的功能特点。</p></blockquote><h3 id="字节流的使用"><a href="#字节流的使用" class="headerlink" title="字节流的使用"></a>字节流的使用</h3><p>IO流的体系</p><table><thead><tr><th align="center">字节流</th><th align="center">字节流</th><th align="center">字符流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">字节输入流</td><td align="center">字节输出流</td><td align="center">字符输入流</td><td align="center">字符输出流</td></tr><tr><td align="center">InputStream</td><td align="center">OutputStream</td><td align="center">Reader</td><td align="center">Writer(抽象类)</td></tr><tr><td align="center">FileInputStream</td><td align="center">FileOutputStream</td><td align="center">FileReader</td><td align="center">FileWriter(子类实现类)</td></tr></tbody></table><h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>FileInputStream文件字节输入流</p><p>作用：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流，简单的来说，就是按照字节读取文件数据到内存</p><p>构造器</p><ul><li><code>public FileInputStream(File path)</code>:创建一个字节输入流管道与源文件对象接通</li><li><code>public FileInputStream(String pathName)</code>:创建一个字节输入流管道与文件路径对接</li></ul><p>方法</p><ul><li><code>public int read()</code> 每次读取一个直接返回，读取完毕会返回<code>-1</code></li><li><code>public int read(byte[] buffer)</code> 从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回<code>-1</code></li></ul><blockquote><ul><li>一个一个字节读取英文和数字没有问题。</li><li>但是一旦读取中文输出无法避免乱码，因为会截断中文的字节。</li><li>一个一个字节的读取数据，性能也较差，所以禁止使用此方案！</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建文件对象定位dlei01.txt</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day09Demo/src/dlei01.txt&quot;</span>);<br><span class="hljs-comment">// 2.创建一个字节输入流管道与源文件接通</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br><span class="hljs-comment">// 3.读取一个字节的编号返回，读取完毕返回-1</span><br><span class="hljs-comment">//        int code1 = is.read(); // 读取一滴水，一个字节</span><br><span class="hljs-comment">//        System.out.println((char)code1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int code2 = is.read(); // 读取一滴水，一个字节</span><br><span class="hljs-comment">//        System.out.println((char)code2);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int code3 = is.read(); // 读取一滴水，一个字节</span><br><span class="hljs-comment">//        System.out.println((char)code3);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int code4 = is.read(); // 读取一滴水，一个字节 ,读取没有字节返回-1</span><br><span class="hljs-comment">//        System.out.println(code4);</span><br><br><span class="hljs-comment">// 4.使用while读取字节数</span><br><span class="hljs-comment">// 定义一个整数变量存储字节</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br><span class="hljs-keyword">while</span>((ch = is.read())!= -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>) ch);<br>&#125;<br><br><span class="hljs-comment">// 读法优化，必须使用循环     // abc xyz i</span><br><span class="hljs-comment">// a.定义一个字节数组代表桶   // ooo ooo o</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> len ; <span class="hljs-comment">// 存储每次读取的字节数。</span><br><span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">// 读取了多少就倒出多少！</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer , <span class="hljs-number">0</span> , len);<br>    System.out.print(rs);<br>&#125;<br></code></pre></td></tr></table></figure><p>解决中文乱码</p><p>定义一个字节数组与文件的大小刚刚一样大，然后一桶水读取全部字节数据再输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0.定位文件对象</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Documents\\codes\\notes\\java-notes\\java补充知识点\\codes\\seniorJava\\day09\\src\\com\\itheima\\_25字节流的使用\\FileInputStreamDemo03.java&quot;</span>);<br><span class="hljs-comment">// 1.定义一个字节输入流通向源文件路径，简化写法！</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f);<br><br><span class="hljs-comment">// 2.定义一个字节数组与文件的大小刚刚一样大</span><br><span class="hljs-comment">//        System.out.println(&quot;文件大小：&quot;+f.length());</span><br><span class="hljs-comment">//        byte[] buffer = new byte[(int) f.length()];</span><br><span class="hljs-comment">//        int len = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了：&quot;+len);</span><br><span class="hljs-comment">//        String rs = new String(buffer);</span><br><span class="hljs-comment">//        System.out.println(rs);</span><br><br><span class="hljs-type">byte</span>[] buffer = is.readAllBytes();<br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer);<br>System.out.println(rs);<br></code></pre></td></tr></table></figure><h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p><code>FileOutputStream</code>文件字节输出流</p><p>作用：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去。简单来说，把内存数据按照字节写出到磁盘文件中去。</p><p>构造器：</p><ul><li><code>public FileOutputStream(File file)</code>:创建一个字节输出流管道通向目标文件对象。</li><li><code>public FileOutputStream(String file)</code>:创建一个字节输出流管道通向目标文件路径。</li><li><code>public FileOutputStream(File file , boolean append)</code>:创建一个追加数据的字节输出流管道通向目标文件对象。</li><li><code>public FileOutputStream(String file , boolean append)</code>:创建一个追加数据的字节输出流管道通向目标文件路径。</li></ul><p>方法：</p><ul><li><p><code>public void write(int a)</code>:写一个字节出去 。</p></li><li><p><code>public void write(byte[] buffer)</code>:写一个字节数组出去。</p></li><li><p><code>public void write(byte[] buffer , int pos , int len)</code>:写一个字节数组的一部分出去。</p><p>参数一，字节数组；参数二：起始字节索引位置，参数三：写多少个字节数出去。</p></li></ul><blockquote><ul><li>字节输出流只能写字节出去</li><li>字节输出流默认是覆盖数据管道</li><li>换行用： <code>os.write(&quot;\r\n&quot;.getBytes());</code></li><li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了！</li></ul></blockquote><p><code>FileOutputStream</code>字节输出流每次启动写数据的时候都会先清空之前的全部数据</p><h3 id="字节流做文件复制"><a href="#字节流做文件复制" class="headerlink" title="字节流做文件复制"></a>字节流做文件复制</h3><p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制。</p><p>复制是把源文件的全部字节一字不漏的转移到目标文件，只要文件前后的格式一样，绝对不会有问题。</p><p>复制步骤：</p><ul><li>创建一个字节输入流管道与源文件接通。</li><li>创建一个字节输出流与目标文件接通。</li><li>创建一个字节数组作为桶</li><li>从字节输入流管道中读取数据，写出到字节输出流管道即可。</li><li>关闭资源！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span><br>    is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\itcast\\图片资源\\meinv.jpg&quot;</span>);<br>    <span class="hljs-comment">/** （2）创建一个字节输出流与目标文件接通。*/</span><br>    os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\itcast\\meimei.jpg&quot;</span>);<br>    <span class="hljs-comment">/** （3）创建一个字节数组作为桶*/</span><br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">/** （4）从字节输入流管道中读取数据，写出到字节输出流管道即可。*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 读取多少就倒出多少</span><br>        os.write(buffer, <span class="hljs-number">0</span> , len);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">/**（5）关闭资源！ */</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">if</span>(os!=<span class="hljs-literal">null</span>)os.close();<br>        <span class="hljs-keyword">if</span>(is!=<span class="hljs-literal">null</span>)is.close();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.7 开始之后释放资源的新方式</p><p>try-with-resources:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<br>    <span class="hljs-comment">// 这里只能放置资源对象，用完会自动调用close()关闭</span><br>)&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>什么是资源？</p><ul><li>资源类一定是实现了Closeable接口，实现这个接口的类就是资源</li><li>有close()方法，try-with-resources会自动调用它的close()关闭资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<br>    <span class="hljs-comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\itcast\\图片资源\\meinv.jpg&quot;</span>);<br>    <span class="hljs-comment">/** （2）创建一个字节输出流与目标文件接通。*/</span><br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\itcast\\meimei.jpg&quot;</span>);<br>    <span class="hljs-comment">/** （5）关闭资源！是自动进行的 */</span><br>)&#123;<br>    <span class="hljs-comment">/** （3）创建一个字节数组作为桶*/</span><br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">/** （4）从字节输入流管道中读取数据，写出到字节输出流管道即可。*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 读取多少就倒出多少</span><br>        os.write(buffer, <span class="hljs-number">0</span> , len);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day10-缓冲流、转换流、序列流"><a href="#day10-缓冲流、转换流、序列流" class="headerlink" title="day10-缓冲流、转换流、序列流"></a>day10-缓冲流、转换流、序列流</h1><h2 id="第一章-字符流"><a href="#第一章-字符流" class="headerlink" title="第一章 字符流"></a>第一章 字符流</h2><p><code>FileReader</code>:文件字符输入流。</p><p>作用：以内存为基准，把磁盘文件的数据以字符的形式读入到内存。简单来说，读取文本文件内容到内存中去。</p><p>构造器：</p><ul><li><code>public FileReader(File file)</code>:创建一个字符输入流与源文件对象接通。</li><li><code>public FileReader(String filePath)</code>:创建一个字符输入流与源文件路径接通。</li></ul><p>方法：</p><ul><li><p><code>public int read()</code>: 读取一个字符的编号返回！ 读取完毕返回-1</p></li><li><p><code>public int read(char[] buffer)</code>:读取一个字符数组，读取多少个字符就返回多少个数量，读取完毕返回-1</p></li><li><p>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。</p></li><li><p>字符流很适合操作文本文件内容。</p></li><li><p>但是：一个一个字符的读取文本内容性能较差！！</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个文件对象定位源文件</span><br><span class="hljs-comment">// File f = new File(&quot;Day10Demo/src/dlei01.txt&quot;);</span><br><span class="hljs-comment">// 2.创建一个字符输入流管道与源文件接通</span><br><span class="hljs-comment">// Reader fr = new FileReader(f);</span><br><span class="hljs-comment">// 3.简化写法：创建一个字符输入流管道与源文件路径接通</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei01.txt&quot;</span>);<br><span class="hljs-comment">// 4.按照字符读取，每次读取一个字符的编号返回。</span><br><span class="hljs-comment">//        int code1 = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code1);</span><br><span class="hljs-comment">//        int code2 = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code2);</span><br><span class="hljs-comment">//        int code3 = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code3);</span><br><span class="hljs-comment">//        int code4 = fr.read(); // 读取完毕返回-1</span><br><span class="hljs-comment">//        System.out.print(code4);</span><br><br><span class="hljs-comment">// 5.while循环一个一个字符读取。</span><br><span class="hljs-comment">// 定义一个变量存储一个字符的编号</span><br><span class="hljs-type">int</span> ch ;<br><span class="hljs-keyword">while</span> ((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>)ch);<br>&#125;<br><br><span class="hljs-comment">// a.按照字符数组读取数据使用循环</span><br><span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 1K</span><br><span class="hljs-comment">// b.定义一个整数记录每次桶读取的字符数据量。</span><br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len = fr.read(buffer)) != -<span class="hljs-number">1</span> ) &#123;<br>    <span class="hljs-comment">// 读取多少倒出多少字符</span><br>    System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span> , len));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileWriter</code>文件字符输出流的使用。</p><p>作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。简单来说，就是把内存的数据以字符写出到文件中去。</p><p>构造器：</p><ul><li><code>public FileWriter(File file)</code>:创建一个字符输出流管道通向目标文件对象。</li><li><code>public FileWriter(String filePath)</code>:创建一个字符输出流管道通向目标文件路径。</li><li><code>public FileWriter(File file,boolean append</code>):创建一个追加数据的字符输出流管道通向目标文件对象。</li><li><code>public FileWriter(String filePath,boolean append)</code>:创建一个追加数据的字符输出流管道通向目标文件路径。</li></ul><p>方法：</p><ul><li><code>public void write(int c)</code>:写一个字符出去</li><li><code>public void write(String c)</code> 写一个字符串出去：</li><li><code>public void write(char[] buffer)</code>:写一个字符数组出去</li><li><code>public void write(String c ,int pos ,int len)</code>:写字符串的一部分出去</li><li><code>public void write(char[] buffer ,int pos ,int len)</code>:写字符数组的一部分出去</li></ul><p>小结：</p><p>字符输出流可以写字符数据出去，总共有5个方法写字符。</p><p>覆盖管道：</p><p><code>Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</code></p><p>追加数据管道：</p><p><code>Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true); // 追加数据管道</code></p><p>换行：</p><p><code>fw.write(&quot;\r\n&quot;); // 换行</code> </p><p>读写字符文件数据建议使用字符流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个字符输出流管道通向目标文件路径</span><br><span class="hljs-comment">//Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</span><br><span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei03.txt&quot;</span>,<span class="hljs-literal">true</span>); <span class="hljs-comment">// 追加数据管道</span><br><br><span class="hljs-comment">// 2.写一个字符出去：public void write(int c):写一个字符出去</span><br>fw.write(<span class="hljs-number">97</span>);   <span class="hljs-comment">// 字符a</span><br>fw.write(<span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// 字符b</span><br>fw.write(<span class="hljs-string">&#x27;磊&#x27;</span>); <span class="hljs-comment">// 字符磊，此时没有任何问题。</span><br>fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">// 3.写一个字符串出去：public void write(String c)写一个字符串出去：</span><br>fw.write(<span class="hljs-string">&quot;Java是最优美的语言！&quot;</span>);<br>fw.write(<span class="hljs-string">&quot;我们在黑马学习它！&quot;</span>);<br>fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">// 4.写一个字符数组出去：public void write(char[] buffer):写一个字符数组出去</span><br>fw.write(<span class="hljs-string">&quot;我爱中国&quot;</span>.toCharArray());<br>fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">// 5.写字符串的一部分出去: public void write(String c ,int pos ,int len):写字符串的一部分出去</span><br>fw.write(<span class="hljs-string">&quot;Java是最优美的语言！&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>);<br>fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">// 6.写字符数组的一部分出去：public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br>fw.write(<span class="hljs-string">&quot;我爱中国&quot;</span>.toCharArray(),<span class="hljs-number">0</span> ,<span class="hljs-number">2</span>);<br>fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br>fw.close();<br></code></pre></td></tr></table></figure><h2 id="第二章-IO资源的处理"><a href="#第二章-IO资源的处理" class="headerlink" title="第二章 IO资源的处理"></a>第二章 IO资源的处理</h2><p>…</p><h2 id="第三章-属性集"><a href="#第三章-属性集" class="headerlink" title="第三章 属性集"></a>第三章 属性集</h2><p><code>Properties</code>：属性集对象。</p><p>其实就是一个Map集合。也就是一个键值对集合。但是我们一般不会当集合使用，</p><p>因为有HashMap。</p><p><code>Properties</code>核心作用：</p><p>Properties代表的是一个属性文件，可以把键值对的数据存入到一个属性文件中去。</p><p>属性文件：后缀是.properties结尾的文件,里面的内容都是 key&#x3D;value。</p><p>大家在后期学的很多大型框架技术中，属性文件都是很重要的系统配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">users.properties<br>admin=<span class="hljs-number">123456</span><br>dlei=dlei<br></code></pre></td></tr></table></figure><p> 需求：使用Properties对象生成一个属性文件，里面存入用户名和密码信息。</p><p>Properties的方法：</p><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合</li><li><code>public void store(OutputStream out, String comments)</code>：保存数据到属性文件中去</li><li><code>public void store(Writer fw, String comments)</code>：保存数据到属性文件中去</li><li><code>public synchronized void load(InputStream inStream)</code>:加载属性文件的数据到属性集对象中去</li><li><code>public synchronized void load(Reader fr)</code>:加载属性文件的数据到属性集对象中去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;admin&quot;</span> , <span class="hljs-string">&quot;123456&quot;</span>);<br>properties.setProperty(<span class="hljs-string">&quot;dlei&quot;</span> , <span class="hljs-string">&quot;101333&quot;</span>);<br>System.out.println(properties);<br><br><span class="hljs-comment">// b.把属性集对象的数据存入到属性文件中去（重点）</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/users.properties&quot;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数一：被保存数据的输出管道</span><br><span class="hljs-comment">         * 参数二：保存心得。就是对象保存的数据进行解释说明！</span><br><span class="hljs-comment">         */</span><br>properties.store(os , <span class="hljs-string">&quot;i am very happy!!我快乐的保存了用户数据!&quot;</span>);<br></code></pre></td></tr></table></figure><p>导入属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个属性集对象</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>System.out.println(properties);<br><br><span class="hljs-comment">// 2.字节输入流加载属性文件的数据到属性集对象properties中去。</span><br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/users.properties&quot;</span>));<br>System.out.println(properties);<br><br>System.out.println(properties.getProperty(<span class="hljs-string">&quot;dlei&quot;</span>));<br>System.out.println(properties.getProperty(<span class="hljs-string">&quot;admin&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="第四章-缓冲流"><a href="#第四章-缓冲流" class="headerlink" title="第四章 缓冲流"></a>第四章 缓冲流</h2><h3 id="缓冲流的概述和分类"><a href="#缓冲流的概述和分类" class="headerlink" title="缓冲流的概述和分类"></a>缓冲流的概述和分类</h3><p>什么是缓冲流：缓冲流可以提高字节流和字符流的读写数据的性能</p><p>缓冲流分为四类：</p><ul><li><code>BufferedInputStream</code>：字节缓冲输入流，可以提高字节输入流读数据的性能。</li><li><code>BufferedOutStream</code>：  字节缓冲输出流，可以提高字节输出流写数据的性能。</li><li><code>BufferedReader</code>：  字符缓冲输入流，可以提高字符输入流读数据的性能。</li><li><code>BufferedWriter</code>：  字符缓冲输出流，可以提高字符输出流写数据的性能。</li></ul><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>字节缓冲输入流：<code>BufferedInputStream</code></p><p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能。</p><p>构造器: <code>public BufferedInputStream(InputStream in)</code></p><p>原理：缓冲字节输入流管道自带了一个8KB的缓冲池，每次可以直接借用操作系统的功能最多提取8KB的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好！</p><blockquote><ul><li>字节缓冲输入流：<code>BufferedInputStream</code></li><li>可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道,从而提高字节输入流读数据的性能。</li><li>功能几乎无变化。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.定义一个低级的字节输入流与源文件接通</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei04.txt&quot;</span>);<br><br><span class="hljs-comment">// 3.把低级的字节输入流包装成一个高级的缓冲字节输入流。</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(is);<br><br><span class="hljs-comment">// 2.定义一个字节数组按照循环读取。</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> len ;<br><span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span> , len);<br>    System.out.print(rs);<br>&#125;<br></code></pre></td></tr></table></figure><p>字节缓冲输出流：<code>BufferedOutputStream</code></p><p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能。</p><p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p><p>原理：缓冲字节输出流自带了8KB缓冲池,数据就直接写入到缓冲池中去，性能极高了！</p><blockquote><ul><li>字节缓冲输出流可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能。</li><li>功能几乎不变。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.写一个原始的字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei05.txt&quot;</span>);<br><span class="hljs-comment">// 3.把低级的字节输出流包装成一个高级的缓冲字节输出流</span><br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(os);<br><span class="hljs-comment">// 2.写数据出去</span><br>bos.write(<span class="hljs-string">&#x27;a&#x27;</span>);<br>bos.write(<span class="hljs-number">100</span>);<br>bos.write(<span class="hljs-string">&#x27;b&#x27;</span>);<br>bos.write(<span class="hljs-string">&quot;我爱中国&quot;</span>.getBytes());<br>bos.close();<br></code></pre></td></tr></table></figure><blockquote><p>高级的字节缓冲流按照一个一个字节数组的形式复制性能极高，建议以后使用</p></blockquote><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符缓冲输入流：<code>BufferedReader</code></p><p>作用：字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p><p>构造器：<code>public BufferedReader(Reader reader)</code></p><p>原理：缓冲字符输入流默认会有一个8K的字符缓冲池,可以提高读字符的性能。缓冲字符输入流除了提高了字符输入流的读数据性能，缓冲字符输入流还多了一个按照行读取数据的功能（重点）:<code>public String readLine()</code>: 读取一行数据返回，读取完毕返回<code>null</code>;</p><p>字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，</p><p>可以提高字符输入流读数据的性能。</p><p>除此之外多了一个按照行读取数据的功能：</p><p><code>public String readLine()</code>: 读取一行数据返回，读取完毕返回<code>null</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.定义一个原始的字符输入流读取源文件</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei06.txt&quot;</span>);<br><br><span class="hljs-comment">// 3.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br><span class="hljs-comment">// 定义一个字符串变量存储每行数据</span><br>String line;<br><span class="hljs-comment">// 使用一个循环读取数据(经典代码)</span><br><span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(line);<br>&#125;<br><br><span class="hljs-comment">//        // 2.定义一个字符数组循环读取</span><br><span class="hljs-comment">//        char[] buffer = new char[1024];</span><br><span class="hljs-comment">//        int len ;</span><br><span class="hljs-comment">//        while((len = br.read(buffer))!=-1)&#123;</span><br><span class="hljs-comment">//            System.out.println(new String(buffer , 0 , len));</span><br><span class="hljs-comment">//        &#125;</span><br><br>br.close();<br></code></pre></td></tr></table></figure><p>字符缓冲输出流：<code>BufferedWriter</code></p><p>作用：把字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p><p>构造器：<code>public BufferedWriter(Writer writer)</code>:</p><p>原理：高级的字符缓冲输出流多了一个8k的字符缓冲池，写数据性能极大提高了!</p><p>字符缓冲输出流除了提高字符输出流写数据的性能，还多了一个换行的特有功能：<code>public void newLine()</code>：新建一行。</p><p>缓冲字符输出流可以把低级的字符输出流进行包装。提高了写字符的性能。</p><p>多了一个换行的功能：public void newLine()：新建一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.定义一个低级的字符输出流写数据出去</span><br><span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei07.txt&quot;</span>,<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 3.把低级的字符输出流包装成高级的缓冲字符输出流</span><br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fw);<br><br><span class="hljs-comment">// 2.写字符输出</span><br>bw.write(<span class="hljs-string">&quot;我在黑马学IO流~~~~&quot;</span>);<br>bw.newLine(); <span class="hljs-comment">// 换行</span><br>bw.write(<span class="hljs-string">&quot;我在黑马学IO流~~~~&quot;</span>);<br>bw.newLine();<span class="hljs-comment">// 换行</span><br><br>bw.close();<br></code></pre></td></tr></table></figure><h3 id="不同编码读取乱码问题"><a href="#不同编码读取乱码问题" class="headerlink" title="不同编码读取乱码问题"></a>不同编码读取乱码问题</h3><ul><li>如果代码编码和读取的文件编码一致。字符流读取的时候不会乱码。</li><li>如果代码编码和读取的文件编码不一致。字符流读取的时候会乱码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.定义一个原始的字符输入流读取源文件</span><br><span class="hljs-comment">//  代码UTF-8  文件UTF-8 不会出现乱码！</span><br><span class="hljs-comment">// Reader fr = new FileReader(&quot;Day10Demo/src/dlei06.txt&quot;);</span><br><span class="hljs-comment">//  代码UTF-8  文件GBK   会出现乱码！</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\itcast\\网络编程公开课\\Netty.txt&quot;</span>);<br><span class="hljs-comment">// 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br><span class="hljs-comment">// 3.定义一个字符串变量存储每行数据</span><br>String line;<br><span class="hljs-comment">// 使用一个循环读取数据(经典代码)</span><br><span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(line);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章-转换流"><a href="#第五章-转换流" class="headerlink" title="第五章 转换流"></a>第五章 转换流</h2><p>字符输入转换流<code>InputStreamReader</code></p><p>作用</p><ul><li>可以解决字符流读取不同编码乱码的问题。</li><li>可以把原始的字节流按照当前默认的代码编码转换成字符输入流。</li><li>也可以把原始的字节流按照指定编码转换成字符输入流</li></ul><p>构造器：</p><ul><li>public InputStreamReader(InputStream is)：可以使用当前代码默认编码转换成字符流，几乎不用！</li><li>public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流</li></ul><p>字符输入转换流可以把字节输入流按照默认编码转换成字符输入流。</p><p>Reader isr &#x3D; new InputStreamReader(is); &#x2F;&#x2F; 使用当前代码默认编码UTF-8转换成字符流，几乎不用！</p><p>字符输入转换流也可以指定编码把字节输入流转换成字符输入流。</p><p>Reader isr &#x3D; new InputStreamReader(is,”GBK”); &#x2F;&#x2F; 指定编码把字节流转换成字符流</p><p>字符输入转换流可以解决不同编码读取乱码的问题！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码：UTF-8    文件：GBK(ab我爱你： o o [oo] [oo] [oo])</span><br><span class="hljs-comment">// 1.提取GBK文件的原始字节流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\itcast\\网络编程公开课\\Netty.txt&quot;</span>);<br><span class="hljs-comment">// 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader</span><br><span class="hljs-comment">//Reader isr = new InputStreamReader(is); // 使用当前代码默认编码UTF-8转换成字符流，几乎不用！</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is,<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定编码把字节流转换成字符流</span><br><span class="hljs-comment">// 3.包装成缓冲流</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br><span class="hljs-comment">// 4.定义一个字符串变量存储每行数据</span><br>String line;<br><span class="hljs-comment">// 使用一个循环读取数据(经典代码)</span><br><span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(line);<br>&#125;<br></code></pre></td></tr></table></figure><p>字符输出转换流：<code>OutputStreamWriter</code></p><p>作用：可以指定编码把字节输出流转换成字符输出流。可以指定写出去的字符的编码。</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream os) </code>:   用当前默认编码UTF-8把字节输出流转换成字符输出流</li><li><code>public OutputStreamWriter(OutputStream os , String charset)</code>:指定编码把字节输出流转换成字符输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.写一个字节输出流通向文件</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei07.txt&quot;</span>);<br><br><span class="hljs-comment">// 2.把字节输出流转换成字符输出流。</span><br><span class="hljs-comment">// Writer fw = new OutputStreamWriter(os); // .把字节输出流按照默认编码UTF-8转换成字符输出流。</span><br><span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(os,<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// .  把字节输出流按照指定编码GBK转换成字符输出流。</span><br>fw.write(<span class="hljs-string">&quot;abc我是中国人&quot;</span>);<br>fw.close();<br></code></pre></td></tr></table></figure><h2 id="第六章-序列流"><a href="#第六章-序列流" class="headerlink" title="第六章 序列流"></a>第六章 序列流</h2><p><strong>对象序列化</strong>：就是把Java对象数据直接存储到文件中去。           对象 &#x3D;&gt; 文件中</p><p><strong>对象反序列化</strong>：就是把Java对象的文件数据恢复到Java对象中。     文件中 &#x3D;&gt; 对象</p><p>对象序列化流（对象字节输出流）：<code>ObjectOutputStream</code></p><p><strong>作用</strong>：把内存中的Java对象数据保存到文件中去。</p><p>构造器：   <code>public ObjectOutputStream(OutputStream out)</code></p><p>序列化方法：<code>public final void writeObject(Object obj)</code></p><blockquote><p>对象如果想参与序列化，对象必须实现序列化接口 implements Serializable ，否则序列化失败！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建User用户对象</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;tsgz&quot;</span>,<span class="hljs-string">&quot;003197&quot;</span>,<span class="hljs-string">&quot;铁扇公主&quot;</span>);<br><span class="hljs-comment">// 2.创建低级的字节输出流通向目标文件</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/obj.dat&quot;</span>);<br><span class="hljs-comment">// 3.把低级的字节输出流包装成高级的对象字节输出流ObjectOutputStream</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(os);<br><span class="hljs-comment">// 4.通过对象字节输出流序列化对象：</span><br>oos.writeObject(user);<br><span class="hljs-comment">// 6.释放资源</span><br>oos.close();<br>System.out.println(<span class="hljs-string">&quot;序列化对象成功~~~~&quot;</span>);<br></code></pre></td></tr></table></figure><p>对象反序列化（对象字节输入流）：<code>ObjectInputStream</code></p><p>作用：读取序列化的对象文件恢复到Java对象中。</p><p>构造器：<code>public ObjectInputStream(InputStream is)</code></p><p>方法：<code>public final Object readObject()</code></p><p>如果一个字段不想参数序列化：<code>transient</code>修饰该成员变量，它将不参与序列化！</p><p>序列化版本号：</p><p>private static final long serialVersionUID &#x3D; 2L;</p><p>必须序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化！否则报错！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.定义一个低级的字节输入流通向源文件</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Day10Demo/src/obj.dat&quot;</span>);<br><span class="hljs-comment">// 2.把字节输入流包装成高的对象字节输入流</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(is);<br><span class="hljs-comment">// 3.反序列化</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) ois.readObject();<br>System.out.println(user);<br>System.out.println(<span class="hljs-string">&quot;反序列化完成！&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="第七章-打印流"><a href="#第七章-打印流" class="headerlink" title="第七章 打印流"></a>第七章 打印流</h2><p>打印流 <code>PrintStream </code>&#x2F; <code>PrintWriter</code></p><p>打印流的作用：</p><p>可以方便，快速的写数据出去。</p><p>可以实现打印啥出去，就是啥出去。</p><p>打印流的构造器：</p><ul><li><code>public PrintStream(OutputStream os)</code></li><li><code>public PrintStream(String filepath)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.打印流PrintStream</span><br><span class="hljs-comment">//OutputStream os = new FileOutputStream(&quot;Day10Demo/src/dlei08.txt&quot;);</span><br><span class="hljs-comment">//PrintStream ps = new PrintStream(os);</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;Day10Demo/src/dlei08.txt&quot;</span>);<br><span class="hljs-comment">//PrintWriter pw = new  PrintWriter(&quot;Day10Demo/src/dlei08.txt&quot;);</span><br><br>ps.println(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写97</span><br>ps.println(<span class="hljs-number">110</span>); <span class="hljs-comment">// 写110</span><br>ps.println(<span class="hljs-string">&quot;我在黑马快乐的调皮~~&quot;</span>);<br>ps.println(<span class="hljs-number">99.8</span>);<br>ps.println(<span class="hljs-literal">false</span>);<br>ps.println(<span class="hljs-string">&#x27;徐&#x27;</span>);<br><br><span class="hljs-comment">// 写字节数据出去</span><br><span class="hljs-comment">// ps.write(&quot;我爱你&quot;.getBytes());</span><br><br>ps.close();<br></code></pre></td></tr></table></figure><p><code>public static void setOut(PrintStream out)</code> :让系统的输出流向打印流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;==itheima0==&quot;</span>);<br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;Day10Demo/src/log.txt&quot;</span>);<br>System.setOut(ps); <span class="hljs-comment">// 让系统的输出流向打印流。</span><br><br>System.out.println(<span class="hljs-string">&quot;==itheima1==&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==itheima2==&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==itheima3==&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==itheima4==&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==itheima5==&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="day11-网络编程和NIO"><a href="#day11-网络编程和NIO" class="headerlink" title="day11-网络编程和NIO"></a>day11-网络编程和NIO</h1><h2 id="第一章-网络编程"><a href="#第一章-网络编程" class="headerlink" title="第一章 网络编程"></a>第一章 网络编程</h2><p>通信一定是基于软件结构实现的</p><ul><li>C&#x2F;S结构 ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷，IDEA等软件</li><li>B&#x2F;S结构 ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等、软件：博学谷、京东、淘宝。（开发中的重点，基于网页设计界面，界面效果可以更丰富: Java Web开发）</li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的技术</p><h3 id="网络通信的三要素"><a href="#网络通信的三要素" class="headerlink" title="网络通信的三要素"></a>网络通信的三要素</h3><ol><li><p>协议：计算机网络客户端与服务端通信必须事先约定和彼此遵守的通信规则。<br>HTTP , FTP , TCP , UDP , SSH , SMTP。</p></li><li><p>IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。</p><p>IP地址用来给一个网络中的计算机设备做唯一的编号</p><p>IPv4: <strong>4个字节，32位组成</strong>。  192.168.70.70</p><p>局域网：公司内部用</p><p>城域网</p><p>广域网（公网）：可以在任何地方访问</p><p>IPv6: 可以实现为所有设备分配IP  <strong>128位</strong></p><p>ipconfig：查看本机的IP</p><p>ping 检查本机与某个IP指定的机器是否联通，或者说是检测对方是否在线。</p><p>ping 空格 IP地址</p><p>ping 220.181.57.216</p><p>ping <a href="http://www.baidu.com/">www.baidu.com</a></p><p>注意：特殊的IP地址： 本机IP地址.(不受环境的影响，任何时候都存在这两个ip,可以直接找本机！)</p><p>127.0.0.1 &#x3D;&#x3D; localhost。</p></li><li><p>端口：端口号就可以唯一标识设备中的进程（应用程序）了</p><p>端口号：用两个字节表示的整数，它的取值范围是0~65535。</p><ul><li>0~1023之间的端口号用于一些知名的网络服务和应用。</li><li>普通的应用程序需要使用1024以上的端口号。</li><li>如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。报出端口被占用异常！！</li></ul></li></ol><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h3 id="网络通信的分层和协议"><a href="#网络通信的分层和协议" class="headerlink" title="网络通信的分层和协议"></a>网络通信的分层和协议</h3><p>网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">-------------------------------------------------------------------------------</span><br><span class="hljs-code">应用层  ：应用程序（QQ,微信,浏览器）,可能用到的协议（HTTP,FTP,SMTP）   通常程序员只需要关心这一层</span><br><span class="hljs-code">------------------------------------------------------------------------------</span><br><span class="hljs-section">传输层  ：TCP/IP协议 - UDP协议    计算机网络工程师需要精通的协议，有些技术我们也需要精通这一层协议，</span><br><span class="hljs-section">-----------------------------------------------------------------</span><br><span class="hljs-section">网络层  ：IP协议  封装自己的IP和对方的IP和端口</span><br><span class="hljs-section">-----------------------------------------------------------------</span><br><span class="hljs-section">数据链路层 ： 进入到硬件（网）</span><br><span class="hljs-section">-----------------------------------------------------------------</span><br></code></pre></td></tr></table></figure><ul><li><p>TCP&#x2F;IP协议：传输控制协议 (Transmission Control Protocol)。</p><p>TCP协议是<strong>面向连接</strong>的安全的可靠的传输通信协议。</p><ol><li>在通信之前必须确定对方在线并且连接成功才可以通信。</li><li>例如下载文件、浏览网页等(要求可靠传输)</li></ol></li><li><p>UDP：用户数据报协议(User Datagram Protocol)。</p><p>UDP协议是一个<strong>面向无连接</strong>的不可靠传输的协议。</p><ol><li>直接发消息给对方，不管对方是否在线，发消息后也不需要确认。</li><li>无线（视频会议，通话），性能好，可能丢失一些数据！！</li></ol></li></ul><h3 id="InetAddress类概述"><a href="#InetAddress类概述" class="headerlink" title="InetAddress类概述"></a>InetAddress类概述</h3><p><code>InetAddress</code>类的对象就代表一个IP地址对象。</p><p><code>InetAddress</code>类成员方法：</p><ul><li><p>获得本地主机IP地址对象</p><p><code>static InetAddress getLocalHost()</code></p></li><li><p>根据IP地址字符串或主机名获得对应的IP地址对象</p><p><code>static InetAddress getByName(String host)</code></p></li><li><p>获得主机名</p><p><code>String getHostName()</code></p></li><li><p>获得IP地址字符串</p><p><code>String getHostAddress()</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.获取本机地址对象。</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>System.out.println(ip.getHostName());<br>System.out.println(ip.getHostAddress());<br><span class="hljs-comment">// 2.获取域名ip对象</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip2</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>System.out.println(ip2.getHostName());<br>System.out.println(ip2.getHostAddress());<br><br><span class="hljs-comment">// 3.获取公网IP对象。</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip3</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;182.61.200.6&quot;</span>);<br>System.out.println(ip3.getHostName());<br>System.out.println(ip3.getHostAddress());<br><br><span class="hljs-comment">// 4.判断是否能通： ping  5s之前测试是否可通</span><br>System.out.println(ip2.isReachable(<span class="hljs-number">5000</span>)); <span class="hljs-comment">// ping</span><br></code></pre></td></tr></table></figure><h2 id="第二章-UDP通信"><a href="#第二章-UDP通信" class="headerlink" title="第二章 UDP通信"></a>第二章 UDP通信</h2><p>UDP协议的特点</p><ul><li><strong>面向无连接</strong>的协议</li><li>发送端只管发送，不确认对方是否能收到</li><li>基于数据包进行数据传输</li><li>发送数据的包的大小限制<strong>64KB以内</strong></li><li><strong>因为面向无连接，速度快，但是不可靠。会丢失数据！</strong></li></ul><p>UDP协议的使用场景</p><ul><li>在线视频</li><li>网络语音电话</li></ul><p>UDP协议相关的两个类</p><ul><li><code>DatagramPacket</code><ul><li>数据包对象</li><li>作用：用来封装要发送或要接收的数据，比如：集装箱</li></ul></li><li><code>DatagramSocket</code><ul><li>发送对象</li><li>作用：用来发送或接收数据包，比如：码头</li></ul></li></ul><p><code>DatagramPacket</code>类构造器</p><p>发送端用：<code>new DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code> 创建发送端数据包对象</p><ul><li><code>buf</code>：要发送的内容，字节数组</li><li><code>length</code>：要发送内容的长度，单位是字节</li><li><code>address</code>：接收端的IP地址对象</li><li><code>port</code>：接收端的端口号</li></ul><p>接收端用：<code>new DatagramPacket(byte[] buf, int length)</code></p><ul><li>创建接收端的数据包对象</li><li><code>buf</code>：用来存储接收到内容</li><li><code>length</code>：能够接收内容的长度</li></ul><p><code>DatagramPacket</code>类常用方法</p><pre><code class="hljs">* `int getLength()` 获得实际接收到的字节个数</code></pre><p><code>DatagramSocket</code>类构造方法</p><ul><li><code>DatagramSocket()</code> 创建发送端的Socket对象，系统会随机分配一个端口号。</li><li><code>DatagramSocket(int port)</code> 创建接收端的Socket对象并指定端口号</li></ul><p><code>DatagramSocket</code>类成员方法</p><ul><li><code>void send(DatagramPacket dp)</code> 发送数据包</li><li><code>void receive(DatagramPacket p)</code> 接收数据包</li></ul><p>需求：使用UDP实现客户端发，服务端收。(了解)</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;===启动客户端===&quot;</span>);<br><span class="hljs-comment">// 1.创建一个集装箱对象，用于封装需要发送的数据包!</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         new DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span><br><span class="hljs-comment">         参数一：封装数据的字节数组。</span><br><span class="hljs-comment">         参数二：发送数据的长度!</span><br><span class="hljs-comment">         参数三：服务端的IP地址</span><br><span class="hljs-comment">         参数四：服务端程序的端口号码。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-string">&quot;今晚，约吗？&quot;</span>.getBytes();<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length,  InetAddress.getLocalHost(), <span class="hljs-number">6666</span>);<br><br><span class="hljs-comment">// 2.创建一个码头对象</span><br><span class="hljs-comment">// 参数可以申明客户端端口，可以有可以没有，默认会给一个端口。</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br><span class="hljs-comment">// 3.开始发送数据包对象</span><br>socket.send(packet);<br><br>socket.close();<br></code></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;==启动服务端程序==&quot;</span>);<br><span class="hljs-comment">// 1.创建一个接收客户都端的数据包对象（集装箱）</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * new DatagramPacket(byte[] buffer ,int lenght):</span><br><span class="hljs-comment">         * 参数一：接收数据的数组。</span><br><span class="hljs-comment">         * 参数二：接收数据的数组的长度！</span><br><span class="hljs-comment">         */</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br><span class="hljs-comment">// 2.创建一个接收端的码头对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">6666</span>);<br><br><span class="hljs-comment">// 3.开始接收</span><br>socket.receive(packet);<br><br><span class="hljs-comment">// 4.从集装箱中获取本次读取的数据量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br><br><span class="hljs-comment">// 5.输出数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer , <span class="hljs-number">0</span> , len);<br>System.out.println(rs);<br><br><span class="hljs-comment">// 6.服务端还可以获取发来信息的客户端的IP和端口。</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> packet.getAddress().getHostAddress();<br><span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> packet.getPort();<br>System.out.println(<span class="hljs-string">&quot;对方：&quot;</span>+ip+<span class="hljs-string">&quot;:&quot;</span>+port);<br>socket.close();<br></code></pre></td></tr></table></figure><h2 id="第三章-TCP通信"><a href="#第三章-TCP通信" class="headerlink" title="第三章 TCP通信"></a>第三章 TCP通信</h2><p>TCP&#x2F;IP协议 &#x3D;&#x3D;&gt; Transfer Control Protocol &#x3D;&#x3D;&gt; 传输控制协议<br>TCP&#x2F;IP协议的特点</p><ul><li><strong>面向连接</strong>的协议</li><li>只能由客户端主动发送数据给服务器端，服务器端接收到数据之后，可以给客户端响应数据。</li><li>通过<strong>三次握手建立连接</strong>，连接成功形成数据传输通道。</li><li>通过<strong>四次挥手断开连接</strong></li><li>基于IO流进行数据传输</li><li>传输数据大小没有限制</li><li>因为<strong>面向连接的协议，速度慢，但是是可靠的协议</strong>。</li></ul><p>TCP协议的使用场景</p><ul><li>文件上传和下载</li><li>邮件发送和接收</li><li>远程登录</li></ul><p>TCP协议相关的类</p><ul><li><p><code>Socket</code></p><p>一个该类的对象就代表一个客户端程序</p></li><li><p><code>ServerSocket</code></p><p>一个该类的对象就代表一个服务器端程序</p></li></ul><p>TCP通信也叫<code>Socket</code>网络编程，只要代码基于<code>Socket</code>开发，底层就是基于了可靠传输的TCP通信。</p><p><code>Socket</code>类构造方法</p><pre><code class="hljs">* `Socket(String host, int port)`    根据ip地址字符串和端口号创建客户端Socket对象            &gt; 只要执行该方法，就会立即连接指定的服务器程序，如果连接不成功，则会抛出异常。如果连接成功，则表示三次握手通过。</code></pre><p><code>Socket</code>类常用方法</p><ul><li><code>OutputStream getOutputStream()</code>; 获得字节输出流对象</li><li><code>InputStream getInputStream()</code>;获得字节输入流对象</li></ul><p><strong>客户端的开发流程</strong></p><ol><li>客户端要请求于服务端的<code>socket</code>管道连接。</li><li>从<code>socket</code>通信管道中得到一个字节输出流</li><li>通过字节输出流给服务端写出数据。</li></ol><p><strong>服务端的开发流程</strong></p><ol><li>注册端口。</li><li>接收客户端的<code>Socket</code>管道连接。</li><li>从<code>socket</code>通信管道中得到一个字节输入流。</li><li>从字节输入流中读取客户端发来的数据。</li></ol><p>需求：客户端发送一行数据，服务端接收一行数据！！</p><blockquote><ol><li>客户端用<code>Socket</code>连接服务端。</li><li>服务端用<code>ServerSocket</code>注册端口，接收客户端的<code>Socket</code>连接。</li><li>通信是很严格的，对方怎么发，你就应该怎么收，对方发多少你就只能收多少。</li><li>实现的面向连接的<code>socket</code>端到端的通信管道，一方如果出现对象，另一方会出现异常！</li></ol></blockquote><h3 id="TCP通信的第一个入门案例"><a href="#TCP通信的第一个入门案例" class="headerlink" title="TCP通信的第一个入门案例"></a>TCP通信的第一个入门案例</h3><p>简单的发送一条信息</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.客户端要请求于服务端的socket管道连接。</span><br><span class="hljs-comment">// Socket(String host, int port)</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span> , <span class="hljs-number">9999</span>);<br><span class="hljs-comment">// 2.从socket通信管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3.把低级的字节输出流包装成高级的打印流。</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><span class="hljs-comment">// 4.开始发消息出去</span><br>ps.println(<span class="hljs-string">&quot;我是客户端，喜欢你很久了，第一次给你发消息，只想说：约吗？&quot;</span>);<br>ps.flush();<br>System.out.println(<span class="hljs-string">&quot;客户端发送完毕~~~~&quot;</span>);<br></code></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;----服务端启动----&quot;</span>);<br><span class="hljs-comment">// 1.注册端口: public ServerSocket(int port)</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br><span class="hljs-comment">// 2.开始等待接收客户端的Socket管道连接。</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><span class="hljs-comment">// 3.从socket通信管道中得到一个字节输入流。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><span class="hljs-comment">// 4.把字节输入流转换成字符输入流</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is);<br><span class="hljs-comment">// 5.把字符输入流包装成缓冲字符输入流。</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br><span class="hljs-comment">// 6.按照行读取消息 。</span><br>String line ;<br><span class="hljs-keyword">if</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(line);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TCP通信的第二个案例-循环发送"><a href="#TCP通信的第二个案例-循环发送" class="headerlink" title="TCP通信的第二个案例-循环发送"></a>TCP通信的第二个案例-循环发送</h3><p>客户端可以反复发送数据，服务端可以反复接受数据</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.客户端要请求于服务端的socket管道连接。</span><br><span class="hljs-comment">// Socket(String host, int port)</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span> , <span class="hljs-number">9999</span>);<br><span class="hljs-comment">// 2.从socket通信管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3.把低级的字节输出流包装成高级的打印流。</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><span class="hljs-comment">// 4.开始发消息出去</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.print(<span class="hljs-string">&quot;请说：&quot;</span>);<br>ps.println(sc.nextLine());<br>ps.flush();<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;----服务端启动----&quot;</span>);<br><span class="hljs-comment">// 1.注册端口: public ServerSocket(int port)</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br><span class="hljs-comment">// 2.开始等待接收客户端的Socket管道连接。</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><span class="hljs-comment">// 3.从socket通信管道中得到一个字节输入流。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><span class="hljs-comment">// 4.把字节输入流转换成字符输入流</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is);<br><span class="hljs-comment">// 5.把字符输入流包装成缓冲字符输入流。</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br><span class="hljs-comment">// 6.按照行读取消息 。</span><br>String line ;<br><span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>System.out.println(line);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TCP通信的第三个案例-一个服务端同时接受多个客户端消息"><a href="#TCP通信的第三个案例-一个服务端同时接受多个客户端消息" class="headerlink" title="TCP通信的第三个案例-一个服务端同时接受多个客户端消息"></a>TCP通信的第三个案例-一个服务端同时接受多个客户端消息</h3><p>需要在服务端引入多线程。每接收一个客户端的Socket通道，就为它分配一个独立的线程来处理它的消息。如此便可实现：一个服务端可以同时接收多个客户端的消息。</p><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;----服务端启动----&quot;</span>);<br>        <span class="hljs-comment">// 1.注册端口: public ServerSocket(int port)</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">// 2.定义一个循环不断的接收客户端的连接请求</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 3.开始等待接收客户端的Socket管道连接。</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-comment">// 4.每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 3.从socket通信管道中得到一个字节输入流。</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4.把字节输入流转换成字符输入流</span><br>            <span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is);<br>            <span class="hljs-comment">// 5.把字符输入流包装成缓冲字符输入流。</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>            <span class="hljs-comment">// 6.按照行读取消息 。</span><br>            String line ;<br>            <span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress()+<span class="hljs-string">&quot;说：&quot;</span>+line);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(socket.getRemoteSocketAddress()+<span class="hljs-string">&quot;下线了~~~~~~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.客户端要请求于服务端的socket管道连接。</span><br><span class="hljs-comment">// Socket(String host, int port)</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span> , <span class="hljs-number">9999</span>);<br><span class="hljs-comment">// 2.从socket通信管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3.把低级的字节输出流包装成高级的打印流。</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><span class="hljs-comment">// 4.开始发消息出去</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.print(<span class="hljs-string">&quot;请说：&quot;</span>);<br>    ps.println(sc.nextLine());<br>    ps.flush();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TCP通信的第四个案例-线程池"><a href="#TCP通信的第四个案例-线程池" class="headerlink" title="TCP通信的第四个案例-线程池"></a>TCP通信的第四个案例-线程池</h3><p>我们之前引入的线程解决一个服务端可以接收多个客户端消息。客户端与服务端的线程模型是： N-N的关系。 一个客户端要一个线程。这种模型是不行的，并发越高，系统瘫痪的越快</p><p>我们可以在服务端引入<strong>线程池</strong>，使用线程池来处理与客户端的消息通信，线程池不会引起出现过多的线程而导致系统死机</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 1.客户端要请求于服务端的socket管道连接。</span><br>    <span class="hljs-comment">// Socket(String host, int port)</span><br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span> , <span class="hljs-number">9999</span>);<br>    <span class="hljs-comment">// 2.从socket通信管道中得到一个字节输出流</span><br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>    <span class="hljs-comment">// 3.把低级的字节输出流包装成高级的打印流。</span><br>    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        System.out.print(<span class="hljs-string">&quot;请说：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        ps.println(msg);<br>        ps.flush();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;----------服务端启动成功------------&quot;</span>);<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">// 一个服务端只需要对应一个线程池</span><br>    <span class="hljs-type">HandlerSocketThreadPool</span> <span class="hljs-variable">handlerSocketThreadPool</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerSocketThreadPool</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 客户端可能有很多个</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept() ;<br>        System.out.println(<span class="hljs-string">&quot;有人上线了！！&quot;</span>);<br>        <span class="hljs-comment">// 每次收到一个客户端的socket请求，都需要为这个客户端分配一个</span><br>        <span class="hljs-comment">// 独立的线程 专门负责对这个客户端的通信！！</span><br>        handlerSocketThreadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderClientRunnable</span>(socket));<br>    &#125;<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>HandlerSocketThreadPool</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池处理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerSocketThreadPool</span> &#123;<br><br><span class="hljs-comment">// 线程池 </span><br><span class="hljs-keyword">private</span> ExecutorService executor;<br><span class="hljs-comment">// 线程池：3个线程  100个</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HandlerSocketThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPoolSize, <span class="hljs-type">int</span> queueSize)</span>&#123;<br>executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>maxPoolSize,<br>maxPoolSize,<br><span class="hljs-number">120L</span>, <br>TimeUnit.SECONDS,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(queueSize) );<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span>&#123;<br><span class="hljs-built_in">this</span>.executor.execute(task);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReaderClientRunnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderClientRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-keyword">private</span> Socket socket ;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReaderClientRunnable</span><span class="hljs-params">(Socket socket)</span> &#123;<br><span class="hljs-built_in">this</span>.socket = socket;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 读取一行数据</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream() ;<br><span class="hljs-comment">// 转成一个缓冲字符流</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br><span class="hljs-comment">// 一行一行的读取数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br><span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 阻塞式的！！</span><br>System.out.println(<span class="hljs-string">&quot;服务端收到了数据：&quot;</span>+line);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.out.println(<span class="hljs-string">&quot;有人下线了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h3><p><code>ClientChat</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.ActionEvent;<br><span class="hljs-keyword">import</span> java.awt.event.ActionListener;<br><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> xlei(徐磊)</span><br><span class="hljs-comment"> * 客户端界面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientChat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span> &#123;<br><span class="hljs-comment">/** 1.设计界面  */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">JFrame</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>();<br><span class="hljs-comment">/** 2.消息内容框架 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">JTextArea</span> <span class="hljs-variable">smsContent</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextArea</span>(<span class="hljs-number">23</span> , <span class="hljs-number">50</span>);<br><span class="hljs-comment">/** 3.发送消息的框  */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">JTextArea</span> <span class="hljs-variable">smsSend</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextArea</span>(<span class="hljs-number">4</span>,<span class="hljs-number">40</span>);<br><span class="hljs-comment">/** 4.在线人数的区域  */</span><br><span class="hljs-comment">/** 存放人的数据 */</span><br><span class="hljs-comment">/** 展示在线人数的窗口 */</span><br><span class="hljs-keyword">public</span> JList&lt;String&gt; onLineUsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 是否私聊按钮</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">isPrivateBn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(<span class="hljs-string">&quot;私聊&quot;</span>);<br><span class="hljs-comment">// 消息按钮</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">JButton</span> <span class="hljs-variable">sendBn</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;发送&quot;</span>);<br><br><span class="hljs-comment">// 登录界面</span><br><span class="hljs-keyword">private</span> JFrame loginView;<br><br><span class="hljs-keyword">private</span> JTextField ipEt , nameEt , idEt;<br><br><span class="hljs-keyword">private</span> Socket socket ;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientChat</span>().initView();<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initView</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">/** 初始化聊天窗口的界面 */</span><br>win.setSize(<span class="hljs-number">650</span>, <span class="hljs-number">600</span>);<br><br><span class="hljs-comment">/** 展示登录界面  */</span><br>displayLoginView();<br><br><span class="hljs-comment">/** 展示聊天界面 */</span><br><span class="hljs-comment">//displayChatView();</span><br><br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayChatView</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-type">JPanel</span> <span class="hljs-variable">bottomPanel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>());<br><span class="hljs-comment">//-----------------------------------------------</span><br><span class="hljs-comment">// 将消息框和按钮 添加到窗口的底端</span><br>win.add(bottomPanel, BorderLayout.SOUTH);<br>bottomPanel.add(smsSend);<br><span class="hljs-type">JPanel</span> <span class="hljs-variable">btns</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>(FlowLayout.LEFT));<br>btns.add(sendBn);<br>btns.add(isPrivateBn);<br>bottomPanel.add(btns, BorderLayout.EAST);<br><span class="hljs-comment">//-----------------------------------------------</span><br><span class="hljs-comment">// 给发送消息按钮绑定点击事件监听器</span><br><span class="hljs-comment">// 将展示消息区centerPanel添加到窗口的中间</span><br>smsContent.setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">0xdd</span>,<span class="hljs-number">0xdd</span>,<span class="hljs-number">0xdd</span>));<br><span class="hljs-comment">// 让展示消息区可以滚动。</span><br>win.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(smsContent), BorderLayout.CENTER);<br>smsContent.setEditable(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//-----------------------------------------------</span><br><span class="hljs-comment">// 用户列表和是否私聊放到窗口的最右边</span><br><span class="hljs-type">Box</span> <span class="hljs-variable">rightBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(BoxLayout.Y_AXIS);<br>onLineUsers.setFixedCellWidth(<span class="hljs-number">120</span>);<br>onLineUsers.setVisibleRowCount(<span class="hljs-number">13</span>);<br>rightBox.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(onLineUsers));<br>win.add(rightBox, BorderLayout.EAST);<br><span class="hljs-comment">//-----------------------------------------------</span><br><span class="hljs-comment">// 关闭窗口退出当前程序</span><br>win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>win.pack();  <span class="hljs-comment">// swing 加上这句 就可以拥有关闭窗口的功能</span><br><span class="hljs-comment">/** 设置窗口居中,显示出来  */</span><br>setWindowCenter(win,<span class="hljs-number">650</span>,<span class="hljs-number">600</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 发送按钮绑定点击事件</span><br>sendBn.addActionListener(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayLoginView</span><span class="hljs-params">()</span>&#123;<br><br><span class="hljs-comment">/** 先让用户进行登录</span><br><span class="hljs-comment"> *  服务端ip</span><br><span class="hljs-comment"> *  用户名</span><br><span class="hljs-comment"> *  id</span><br><span class="hljs-comment"> *  */</span><br><span class="hljs-comment">/** 显示一个qq的登录框     */</span><br>loginView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;登录&quot;</span>);<br>loginView.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>));<br>loginView.setSize(<span class="hljs-number">400</span>, <span class="hljs-number">230</span>);<br><br><span class="hljs-type">JPanel</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br><span class="hljs-type">JLabel</span> <span class="hljs-variable">label</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;   IP:&quot;</span>);<br>ip.add(label);<br>ipEt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-number">20</span>);<br>ip.add(ipEt);<br>loginView.add(ip);<br><br><span class="hljs-type">JPanel</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br><span class="hljs-type">JLabel</span> <span class="hljs-variable">label1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;姓名:&quot;</span>);<br>name.add(label1);<br>nameEt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-number">20</span>);<br>name.add(nameEt);<br>loginView.add(name);<br><br><span class="hljs-type">JPanel</span> <span class="hljs-variable">btnView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br><span class="hljs-type">JButton</span> <span class="hljs-variable">login</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;登陆&quot;</span>);<br>btnView.add(login);<br><span class="hljs-type">JButton</span> <span class="hljs-variable">cancle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;取消&quot;</span>);<br>btnView.add(cancle);<br>loginView.add(btnView);<br><span class="hljs-comment">// 关闭窗口退出当前程序</span><br>loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>setWindowCenter(loginView,<span class="hljs-number">400</span>,<span class="hljs-number">260</span>,<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">/** 给登录和取消绑定点击事件 */</span><br>login.addActionListener(<span class="hljs-built_in">this</span>);<br>cancle.addActionListener(<span class="hljs-built_in">this</span>);<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWindowCenter</span><span class="hljs-params">(JFrame frame, <span class="hljs-type">int</span> width , <span class="hljs-type">int</span> height, <span class="hljs-type">boolean</span> flag)</span> &#123;<br><span class="hljs-comment">/** 得到所在系统所在屏幕的宽高 */</span><br><span class="hljs-type">Dimension</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> frame.getToolkit().getScreenSize();<br><br><span class="hljs-comment">/** 拿到电脑的宽 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">width1</span> <span class="hljs-operator">=</span> ds.width;<br><span class="hljs-comment">/** 高 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">height1</span> <span class="hljs-operator">=</span> ds.height ;<br><br>System.out.println(width1 +<span class="hljs-string">&quot;*&quot;</span> + height1);<br><span class="hljs-comment">/** 设置窗口的左上角坐标 */</span><br>frame.setLocation(width1/<span class="hljs-number">2</span> - width/<span class="hljs-number">2</span>, height1/<span class="hljs-number">2</span> -height/<span class="hljs-number">2</span>);<br>frame.setVisible(flag);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br><span class="hljs-comment">/** 得到点击的事件源 */</span><br><span class="hljs-type">JButton</span> <span class="hljs-variable">btn</span> <span class="hljs-operator">=</span> (JButton) e.getSource();<br><span class="hljs-keyword">switch</span>(btn.getText())&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;登陆&quot;</span>:<br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> ipEt.getText().toString();<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> nameEt.getText().toString();<br><span class="hljs-comment">// 校验参数是否为空</span><br><span class="hljs-comment">// 错误提示</span><br><span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> ;<br><span class="hljs-comment">// 12.1.2.0</span><br><span class="hljs-comment">// \d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\</span><br><span class="hljs-keyword">if</span>(ip==<span class="hljs-literal">null</span> || !ip.matches(<span class="hljs-string">&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;</span>))&#123;<br>msg = <span class="hljs-string">&quot;请输入合法的服务端ip地址&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name==<span class="hljs-literal">null</span> || !name.matches(<span class="hljs-string">&quot;\\S&#123;1,&#125;&quot;</span>))&#123;<br>msg = <span class="hljs-string">&quot;姓名必须1个字符以上&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!msg.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br><span class="hljs-comment">/** msg有内容说明参数有为空 */</span><br><span class="hljs-comment">// 参数一：弹出放到哪个窗口里面</span><br>JOptionPane.showMessageDialog(loginView, msg);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 参数都合法了</span><br><span class="hljs-comment">// 当前登录的用户,去服务端登陆</span><br><span class="hljs-comment">/** 先把当前用户的名称展示到界面 */</span><br>win.setTitle(name);<br><span class="hljs-comment">// 去服务端登陆连接一个socket管道</span><br>socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(ip, Constants.PORT);<br><br><span class="hljs-comment">//为客户端的socket分配一个线程 专门负责收消息</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientReader</span>(<span class="hljs-built_in">this</span>,socket).start();<br><br><span class="hljs-comment">// 带上用户信息过去</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(socket.getOutputStream());<br>dos.writeInt(<span class="hljs-number">1</span>); <span class="hljs-comment">// 登录消息</span><br>dos.writeUTF(name.trim());<br>dos.flush();<br><br><span class="hljs-comment">// 关系当前窗口 弹出聊天界面</span><br>loginView.dispose(); <span class="hljs-comment">// 登录窗口销毁</span><br>displayChatView(); <span class="hljs-comment">// 展示了聊天窗口了</span><br><br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>e1.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;取消&quot;</span>:<br><span class="hljs-comment">/** 退出系统 */</span><br>System.exit(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;发送&quot;</span>:<br><span class="hljs-comment">// 得到发送消息的内容</span><br><span class="hljs-type">String</span> <span class="hljs-variable">msgSend</span> <span class="hljs-operator">=</span> smsSend.getText().toString();<br><span class="hljs-keyword">if</span>(!msgSend.trim().equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br><span class="hljs-comment">/** 发消息给服务端 */</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 判断是否对谁发消息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">selectName</span> <span class="hljs-operator">=</span> onLineUsers.getSelectedValue();<br><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;<span class="hljs-comment">// 群发 @消息</span><br><span class="hljs-keyword">if</span>(selectName!=<span class="hljs-literal">null</span>&amp;&amp;!selectName.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>msgSend =(<span class="hljs-string">&quot;@&quot;</span>+selectName+<span class="hljs-string">&quot;,&quot;</span>+msgSend);<br><span class="hljs-comment">/** 判断是否选中了私法 */</span><br><span class="hljs-keyword">if</span>(isPrivateBn.isSelected())&#123;<br><span class="hljs-comment">/** 私法 */</span><br>flag = <span class="hljs-number">3</span> ;<span class="hljs-comment">//私发消息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(socket.getOutputStream());<br>dos.writeInt(flag); <span class="hljs-comment">// 群发消息  发送给所有人</span><br>dos.writeUTF(msgSend);<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">3</span>)&#123;<br><span class="hljs-comment">// 告诉服务端我对谁私发</span><br>dos.writeUTF(selectName.trim());<br>&#125;<br>dos.flush();<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>e1.printStackTrace();<br>&#125;<br><br>&#125;<br>smsSend.setText(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br><span class="hljs-keyword">private</span> Socket socket;<br><span class="hljs-keyword">private</span> ClientChat clientChat ;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientReader</span><span class="hljs-params">(ClientChat clientChat, Socket socket)</span> &#123;<br><span class="hljs-built_in">this</span>.clientChat = clientChat;<br><span class="hljs-built_in">this</span>.socket = socket;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(socket.getInputStream());<br><span class="hljs-comment">/** 循环一直等待客户端的消息 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-comment">/** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dis.readInt();<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">// 在线人数消息回来了</span><br><span class="hljs-type">String</span> <span class="hljs-variable">nameDatas</span> <span class="hljs-operator">=</span> dis.readUTF();<br><span class="hljs-comment">// 展示到在线人数的界面</span><br>String[] names = nameDatas.split(Constants.SPILIT);<br><br>clientChat.onLineUsers.setListData(names);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-comment">// 群发消息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis.readUTF() ;<br>clientChat.smsContent.append(msg);<br><span class="hljs-comment">//滾動到底端</span><br>clientChat.smsContent.setCaretPosition(clientChat.smsContent.getText().length());<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>User</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span> Integer id ;<br><span class="hljs-keyword">private</span> String name ;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Integer id, String name)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerChat</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Email</span> dlei0009@163.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerChat</span> &#123;<br><br><span class="hljs-comment">/** 定义一个集合存放所有在线的socket  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Socket, String&gt; onLineSockets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">/** 注册端口   */</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(Constants.PORT);<br><br><span class="hljs-comment">/** 循环一直等待所有可能的客户端连接 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><span class="hljs-comment">/** 把客户端的socket管道单独配置一个线程来处理 */</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket).start();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br><span class="hljs-keyword">private</span> Socket socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReader</span><span class="hljs-params">(Socket socket)</span> &#123;<br><span class="hljs-built_in">this</span>.socket = socket;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(socket.getInputStream());<br><span class="hljs-comment">/** 循环一直等待客户端的消息 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-comment">/** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dis.readInt();<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">/** 先将当前登录的客户端socket存到在线人数的socket集合中   */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> dis.readUTF() ;<br>System.out.println(name+<span class="hljs-string">&quot;----&gt;&quot;</span>+socket.getRemoteSocketAddress());<br>ServerChat.onLineSockets.put(socket, name);<br>&#125;<br>writeMsg(flag,dis);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.out.println(<span class="hljs-string">&quot;--有人下线了--&quot;</span>);<br><span class="hljs-comment">// 从在线人数中将当前socket移出去  </span><br>ServerChat.onLineSockets.remove(socket);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 从新更新在线人数并发给所有客户端 </span><br>writeMsg(<span class="hljs-number">1</span>,dis);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>e1.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, DataInputStream dis)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); </span><br><span class="hljs-comment">// 定义一个变量存放最终的消息形式 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */</span><br><span class="hljs-comment">/** onlineNames = [徐磊,zhangsan,李刚]*/</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();<br><span class="hljs-comment">// 判断是否存在在线人数 </span><br><span class="hljs-keyword">if</span>(onlineNames != <span class="hljs-literal">null</span> &amp;&amp; onlineNames.size() &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(String name : onlineNames)&#123;<br>rs.append(name+ Constants.SPILIT);<br>&#125;<br><span class="hljs-comment">// 徐磊003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣李刚003197♣♣㏘♣④④♣</span><br><span class="hljs-comment">// 去掉最后的一个分隔符 </span><br>msg = rs.substring(<span class="hljs-number">0</span>, rs.lastIndexOf(Constants.SPILIT));<br><br><span class="hljs-comment">/** 将消息发送给所有的客户端 */</span><br>sendMsgToAll(flag,msg);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">2</span> || flag == <span class="hljs-number">3</span>)&#123;<br><span class="hljs-comment">// 读到消息  群发的 或者 @消息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">newMsg</span> <span class="hljs-operator">=</span> dis.readUTF() ; <span class="hljs-comment">// 消息</span><br><span class="hljs-comment">// 得到发件人 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">sendName</span> <span class="hljs-operator">=</span> ServerChat.onLineSockets.get(socket);<br><br><span class="hljs-comment">// 李刚 时间</span><br><span class="hljs-comment">//    内容--</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">msgFinal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-comment">// 时间  </span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss EEE&quot;</span>);<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">2</span>)&#123;<br>msgFinal.append(sendName).append(<span class="hljs-string">&quot;  &quot;</span>).append(sdf.format(System.currentTimeMillis())).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>msgFinal.append(<span class="hljs-string">&quot;    &quot;</span>).append(newMsg).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>sendMsgToAll(flag,msgFinal.toString());<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">3</span>)&#123;<br>msgFinal.append(sendName).append(<span class="hljs-string">&quot;  &quot;</span>).append(sdf.format(System.currentTimeMillis())).append(<span class="hljs-string">&quot;对您私发\r\n&quot;</span>);<br>msgFinal.append(<span class="hljs-string">&quot;    &quot;</span>).append(newMsg).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><span class="hljs-comment">// 私发 </span><br><span class="hljs-comment">// 得到给谁私发 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">destName</span> <span class="hljs-operator">=</span> dis.readUTF();<br>sendMsgToOne(destName,msgFinal.toString());<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> destName 对谁私发 </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg 发的消息内容 </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgToOne</span><span class="hljs-params">(String destName, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 拿到所有的在线socket管道 给这些管道写出消息</span><br>Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();<br><span class="hljs-keyword">for</span>(Socket sk :  allOnLineSockets)&#123;<br><span class="hljs-comment">// 得到当前需要私发的socket </span><br><span class="hljs-comment">// 只对这个名字对应的socket私发消息</span><br><span class="hljs-keyword">if</span>(ServerChat.onLineSockets.get(sk).trim().equals(destName))&#123;<br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(sk.getOutputStream());<br>dos.writeInt(<span class="hljs-number">2</span>); <span class="hljs-comment">// 消息类型</span><br>dos.writeUTF(msg);<br>dos.flush();<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgToAll</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 拿到所有的在线socket管道 给这些管道写出消息</span><br>Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();<br><span class="hljs-keyword">for</span>(Socket sk :  allOnLineSockets)&#123;<br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(sk.getOutputStream());<br>dos.writeInt(flag); <span class="hljs-comment">// 消息类型</span><br>dos.writeUTF(msg);<br>dos.flush();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Constants</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constants</span> &#123;<br><span class="hljs-comment">/** 常量 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">7778</span> ;<br><br><span class="hljs-comment">/** 协议分隔符 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SPILIT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;003197♣♣㏘♣④④♣&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>实现客户端上传图片给服务端保存起来</p><p>服务端实现：</p><ul><li>接受多个客户端传输来的图片数据存储到服务器路径</li><li>响应一个成功的消息给当前客户端</li></ul><p><code>ClientDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo</span> &#123;<br>    <span class="hljs-comment">// 本地图片路径、</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.请求于服务端的Socket管道连接。</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(Constants.SERVER_IP , Constants.SERVER_PORT);<br>        <span class="hljs-comment">// 2.从socket管道中得到一个字节输出流包装成缓冲字节输出流</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(socket.getOutputStream());<br>        <span class="hljs-comment">// 3.提取本机的图片上传给服务端</span><br>        <span class="hljs-comment">// 4.得到一个缓冲字节输入流与本地图片接通</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Constants.SRC_IMAGE));<br>        <span class="hljs-comment">// 5.定义一个字节数组</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len ;<br>        <span class="hljs-keyword">while</span>((len = bis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(buffer, <span class="hljs-number">0</span> ,len);<br>        &#125;<br>        bos.flush(); <span class="hljs-comment">// 刷新图片数据到服务端！！</span><br>        socket.shutdownOutput(); <span class="hljs-comment">// 告诉服务端我的数据已经发送完毕，请不要在等我了！</span><br>        bis.close(); <span class="hljs-comment">// 可以关闭</span><br><br>        <span class="hljs-comment">// 6.等待着服务端的响应数据！！</span><br>        <span class="hljs-type">BufferedReader</span>  <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        System.out.println(<span class="hljs-string">&quot;收到服务端响应：&quot;</span>+br.readLine());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Constants</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端常量包</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constants</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SRC_IMAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\itcast\\图片资源\\beautiful.jpg&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\itcast\\约吧图片服务器\\&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">8888</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      功能点：</span><br><span class="hljs-comment">      1.接收多个客户端传输来的图片数据存储到服务器路径：</span><br><span class="hljs-comment">      2.响应一个成功的消息给当前客户端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;----服务端启动----&quot;</span>);<br>        <span class="hljs-comment">// 1.注册端口: public ServerSocket(int port)</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(Constants.SERVER_PORT);<br>        <span class="hljs-comment">// 2.定义一个循环不断的接收客户端的连接请求</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 3.开始等待接收客户端的Socket管道连接。</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-comment">// 4.每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 1.从socket通信管道中得到一个字节输入流读取客户端发来的图片数据！</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 2.包装成高级的缓冲字节输入流</span><br>            <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(is);<br>            <span class="hljs-comment">// 3.定义一个缓冲字节输出流通向目标路径（服务端路径）</span><br>            <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(Constants.SERVER_DIR+ UUID.randomUUID().toString()+<span class="hljs-string">&quot;.jpg&quot;</span>));<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len ;<br>            <span class="hljs-keyword">while</span>((len = bis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(buffer, <span class="hljs-number">0</span> ,len);<br>            &#125;<br>            bos.close();<br>            System.out.println(<span class="hljs-string">&quot;服务端接收完毕了！&quot;</span>);<br><br>            <span class="hljs-comment">// 4.响应数据给客户端</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br>            ps.println(<span class="hljs-string">&quot;您好，已成功接收您上传的图片！&quot;</span>);<br>            ps.flush();<br><br>            Thread.sleep(<span class="hljs-number">100000</span>); <span class="hljs-comment">// 等消失发送完毕被客户端接收后死亡！</span><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(socket.getRemoteSocketAddress()+<span class="hljs-string">&quot;下线了~~~~~~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-BS架构"><a href="#第四章-BS架构" class="headerlink" title="第四章 BS架构"></a>第四章 BS架构</h2><p>之前客户端和服务端都需要自己开发。也就是CS架构。接下来模拟一下BS架构。</p><p>客户端：浏览器。（无需开发）</p><p>服务端：自己开发。</p><p>需求：在浏览器中请求本程序，响应一个网页文字给浏览器显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 响应消息数据给浏览器显示。</span><br>            <span class="hljs-comment">// 浏览器是基于HTTP协议通信！响应格式必须满足HTTP协议数据格式的要求，浏览器</span><br>            <span class="hljs-comment">// 才能够识别，否则响应消息浏览器根本不认识。</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br>            ps.println(<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>); <span class="hljs-comment">// 响应数据的响应头数据！</span><br>            ps.println(<span class="hljs-string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);<span class="hljs-comment">//响应数据的类型。网页或者文本内容！</span><br>            ps.println(); <span class="hljs-comment">// 必须换一行</span><br>            <span class="hljs-comment">// 以下开始响应真实的数据！！</span><br>            ps.println(<span class="hljs-string">&quot;&lt;span style=&#x27;color:green;font-size:100px;&#x27;&gt;Hello, world&lt;span&gt;&quot;</span>);<br><br>            Thread.sleep(<span class="hljs-number">4000</span>);<br>            ps.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章-基本通信模型"><a href="#第五章-基本通信模型" class="headerlink" title="第五章 基本通信模型"></a>第五章 基本通信模型</h2><ol><li><p>BIO通信模式：同步阻塞式通信。（Socket网络编程也就是上面的通信架构）</p><p>同步：当前线程要自己进行数据的读写操作。（自己去银行取钱）</p><p>异步: 当前线程可以去做其他事情，（委托一小弟拿银行卡到银行取钱，然后给你）</p><p>阻塞： 在数据没有的情况下，还是要继续等待着读。（排队等待）</p><p>非阻塞：在数据没有的情况下，会去做其他事情，一旦有了数据再来获取。（柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理）</p><blockquote><ul><li>BIO表示同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>同步阻塞式性能极差：大量线程，大量阻塞。</li></ul></blockquote></li><li><p>伪异步通信：引入了线程池。</p><p>不需要一个客户端一个线程，可以实现1个线程复用来处理很多个客户端！</p><p>这种架构，可以避免系统的死机，因为不会出现很多线程，线程可控。</p><p>但是高并发下性能还是很差：a.线程数量少，数据依然是阻塞的。数据没有来线程还是要等待！</p></li><li><p>NIO表示同步非阻塞IO，服务器实现模式为请求对应一个线程，</p><p>即客户端发送的连接请求都会注册到多路复用器上，</p><p>多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</p><blockquote><p>1个主线程专门负责接收客户端：</p><p>1个线程[c1 ,s2 ,c3,c4, ,s2 ,c3,c4,,c3,c4, ,s2 ,c3,c4]轮询所有的客户端，发来了数据才会开启线程处理</p><p>这种架构性能还可以！！</p><p><strong>同步</strong>：线程还是要不断的接收客户端连接，以及处理数据。</p><p><strong>非阻塞</strong>：如果一个管道没有数据，不需要等待，可以轮询下一个管道是否有数据！</p></blockquote></li><li><p>AIO表示异步非阻塞IO，服务器实现模式为一个有效请求一个线程，</p><p>客户端的I&#x2F;O请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程进行处理。</p><p>异步：服务端线程接收到了客户端管道以后就交给底层处理它的io通信。</p><p>自己可以做其他事情。</p><p>非阻塞：底层也是客户端有数据才会处理，有了数据以后处理好通知服务器应用来启动线程进行处理。</p></li></ol><p>各种模型应用场景：</p><p>BIO适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，JDK 1.4以前的唯一选择。</p><p>NIO适用于连接数目多且连接比较短（轻操作）的架构，如聊天服务器，编程复杂，</p><p>JDK 1.4开始支持。</p><p>AIO适用于连接数目多且连接比较长（重操作）的架构，如相册服务器，充分调用操作系统参与并发操作，编程复杂，JDK 1.7开始支持。</p><h1 id="day12-JUnit单元测试、反射、注解、动态代理"><a href="#day12-JUnit单元测试、反射、注解、动态代理" class="headerlink" title="day12-JUnit单元测试、反射、注解、动态代理"></a>day12-JUnit单元测试、反射、注解、动态代理</h1><h2 id="第一章-单元测试"><a href="#第一章-单元测试" class="headerlink" title="第一章 单元测试"></a>第一章 单元测试</h2><p>单元测试是指程序员写的测试代码给自己的类中的方法进行预期正确性的验证。</p><p>单元测试一旦写好了这些测试代码，就可以一直使用，可以实现一定程度上的自动化测试。</p><p>单元测试一般要使用框架进行。<br>什么是框架？<br>框架是前人或者一些牛逼的技术公司在实战或者研发中设计的一些优良的设计方案或者成型的 代码功能，作为一个完整的技术体系发行出来称为框架。</p><p>框架可以让程序员快速拥有一个强大的解决方案，可以快速的开发功能，提高效率并且直接就有了很好的性能。</p><p>单元测试的经典框架：<code>Junit</code></p><p><code>Junit</code>是什么</p><ul><li><code>Junit</code>是Java语言编写的第三方单元测试框架</li><li><code>Junit</code>框架的方案可以帮助我们方便且快速的测试我们的代码的正确性。</li></ul><p>单元测试概念</p><ul><li>单元：在Java中，一个类就是一个单元</li><li>单元测试：程序猿用<code>Junit</code>编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试。</li></ul><p><code>Junit</code>单元测试框架的作用</p><ul><li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性。</li><li>能够独立的测试某个方法或者所有方法的预期正确性。</li></ul><p>Junit框架的使用步骤:</p><ol><li><p>下载这个框架。（别人设计好的技术体系）</p><p>框架一般是jar包的形式，jar包里面都是class文件。（Java工程的最终形式）class文件就是我们调用的核心代码</p><p>现在不需要大家去官网下载，因为很多知名框架其实IDEA工具早就整合好了，程序员可以直接使用。</p><p>Junit已经被IDEA下载好了，可以直接导入到项目使用的。</p></li><li><p>直接用Junit测试代码即可</p><ul><li>先模拟业务代码</li><li>写测试类<ul><li>测试类的命名规范：以Test开头，以业务类类名结尾，使用驼峰命名法</li><li>业务名称是：UserService</li><li>测试这个业务类的测试类：TestUserService&#x2F;UserServiceTest</li></ul></li><li>在测试类中写测试方法<ul><li>测试方法的命名规则：以test开头，以业务方法名结尾</li><li>比如被测试业务方法名为：login，那么测试方法名就应该叫：testLogin</li></ul></li><li>测试方法注意事项<ul><li>必须是<code>public</code>修饰的，没有返回值，没有参数</li><li>必须使注解<code>@Test</code>修饰</li></ul></li></ul></li><li><p>如何运行测试方法</p><ul><li><p>选中方法名 –&gt; 右键 –&gt; Run ‘测试方法名’  运行选中的测试方法</p></li><li><p>选中测试类名 –&gt; 右键 –&gt; Run ‘测试类类名’  运行测试类中所有测试方法</p></li><li><p>选中模块名 –&gt; 右键 –&gt; Run ‘All Tests’  运行模块中的所有测试类的所有测试方法</p></li></ul></li></ol><p>​    如何查看测试结果</p><ul><li>绿色：表示测试通过</li><li>红色：表示测试失败，有问题</li></ul><p>​    <code>Junit</code>常用注解(Junit 4.xxxx版本)</p><ul><li><code>@Test</code> 测试方法！</li><li><code>@Before</code>：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</li><li><code>@After</code>：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</li><li><code>@BeforeClass</code>：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</li><li><code>@AfterClass</code>：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</li></ul><p>开始执行的方法:初始化资源。</p><p>执行完之后的方法:释放资源。</p><p>Junit常用注解(Junit5.xxxx版本)</p><ul><li><code>@Test</code> 测试方法！</li><li><code>@BeforeEach</code>：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</li><li><code>@AfterEach</code>：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</li><li><code>@BeforeAll</code>：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</li><li><code>@AfterAll</code>：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> &#123;<br>    <span class="hljs-comment">// @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</span><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===before===&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</span><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===after===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</span><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===beforeClass===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</span><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===afterClass===&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试方法的要求：</span><br><span class="hljs-comment">     *  1.必须public修饰</span><br><span class="hljs-comment">     *  2.没有返回值没有参数</span><br><span class="hljs-comment">     *  3. 必须使注解<span class="hljs-doctag">@Test</span>修饰</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLogin</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> userService.login(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 断言预期结果的正确性。</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数一：测试失败的提示信息。</span><br><span class="hljs-comment">         * 参数二：期望值。</span><br><span class="hljs-comment">         * 参数三：实际值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// public static void assertEquals(String message, Object expected, Object actual)</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;登录业务功能方法有错误，请检查！&quot;</span>,<span class="hljs-string">&quot;success&quot;</span>,rs);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testChu</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        userService.chu(<span class="hljs-number">10</span> , <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章-反射"><a href="#第二章-反射" class="headerlink" title="第二章 反射"></a>第二章 反射</h2><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><p>反射，注解，代理，泛型是Java的高级技术，是以后框架的底层原理必须使用到的技术。</p><p>反射：是Java独有的技术。是Java技术显著的特点。</p><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分。</p><ul><li>在运行时,可以直接得到这个类的构造器对象。（Constructor）</li><li>在运行时,可以直接得到这个类的成员变量对象。（Field）</li><li>在运行时,可以直接得到这个类的成员方法对象。（Method）</li></ul><p>反射的核心思想和关键就是得到：编译以后的class文件对象。</p><p>反射提供了一个Class类型，就是可以得到编译以后的class类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">HelloWorld.java -&gt; javac -&gt; HelloWorld.<span class="hljs-keyword">class</span><br><br><span class="hljs-title class_">Class</span> c = HelloWorld.class;<br></code></pre></td></tr></table></figure><blockquote><p>反射是工作在运行时的技术，因为只有运行之后才会有class类对象</p><p>反射的核心思想和关键就是得到：编译以后的class文件对象</p><p>反射是在运行时获取类的字节码文件对象：然后可以解析类中的全部成分</p></blockquote><h3 id="获取Class类对象"><a href="#获取Class类对象" class="headerlink" title="获取Class类对象"></a>获取Class类对象</h3><p>反射是通过先得到编译以后的Class类对象：字节码文件。然后才可以得到类中的全部成分，进行一些功能设计。</p><p>反射为一个类的全部成分都设计了一个类型来代表这个对象：</p><ul><li><code>Class </code>: 字节码文件的类型</li><li><code>Constructor </code>: 构造器的类型</li><li><code>Field</code> : 成员变量的类型</li><li><code>Method </code>: 方法的类型</li></ul><p>反射技术的第一步永远是先得到Class类对象:有三种方式获取</p><ol><li><p>类名.class</p></li><li><p>通过类的对象.getClass()方法</p></li><li><p>Class.forName(“类的全限名”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br></code></pre></td></tr></table></figure></li></ol><p>Class类下的方法：</p><ul><li>String getSimpleName(); 获得类名字符串：类名</li><li>String getName();  获得类全名：包名+类名</li><li>T newInstance() ;  创建Class对象关联类的对象,其实底层也是调用无参数构造器，已经被淘汰。</li></ul><p>Class类对象的获取有三种方式：</p><ol><li>类名.class。</li><li>通过类的对象.getClass()方法。</li><li>Class.forName(“类的全限名”)。</li><li>Class类的方法：<ul><li><code>String getSimpleName();</code> 获得类名字符串：类名</li><li><code>String getName(); </code> 获得类全名：包名+类名</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。</span><br><span class="hljs-comment">// 1.类名.class</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Student.class;<br>System.out.println(c1);<br><br><span class="hljs-comment">// 2.对象.getClass()</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> swk.getClass();<br>System.out.println(c2);<br><br><span class="hljs-comment">// 3.Class.forName(&quot;类的全限名&quot;)</span><br><span class="hljs-comment">// 直接去加载该类的class文件。</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.itheima._03反射_获取Class类对象.Student&quot;</span>);<br>System.out.println(c3);<br><br>System.out.println(c1.getSimpleName()); <span class="hljs-comment">// 获取类名本身（简名）</span><br>System.out.println(c1.getName()); <span class="hljs-comment">// 获取类的全限名</span><br><span class="hljs-comment">// Student s1 = (Student) c1.newInstance(); // 调用无参数构造器得到对象，被淘汰了！</span><br></code></pre></td></tr></table></figure><h3 id="获取Constructor构造器对象"><a href="#获取Constructor构造器对象" class="headerlink" title="获取Constructor构造器对象"></a>获取Constructor构造器对象</h3><p>反射中Class类型获取构造器提供了很多的API:<br>     1. <code>Constructor getConstructor(Class... parameterTypes)</code><br>        根据参数匹配获取某个构造器，只能拿public修饰的构造器，几乎不用！<br>     2. <code>Constructor getDeclaredConstructor(Class... parameterTypes)</code><br>  根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！<br>     3. <code>Constructor[] getConstructors()</code><br>  获取所有的构造器，只能拿public修饰的构造器。几乎不用！！太弱了！<br>     4. <code>Constructor[] getDeclaredConstructors()</code><br>  获取所有声明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！</p><p>获取类的全部构造器对象：<code> Constructor[] getDeclaredConstructors()</code></p><p>获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！</p><p>获取类的某个构造器对象：<code>Constructor getDeclaredConstructor(Class... parameterTypes)</code></p><p>根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</p><p>对于类<code>Student</code>来说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参数构造器被执行~~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有参数构造器被执行~~~~&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>获取该类运行时的构造器可以用一下代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent</span> &#123;<br>    <span class="hljs-comment">// 1. getConstructors:</span><br>    <span class="hljs-comment">// 获取全部的构造器：只能获取public修饰的构造器。</span><br>    <span class="hljs-comment">// Constructor[] getConstructors()</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.反射第一步先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.getConstructors()：定位全部构造器，只能拿public修饰的！</span><br>        Constructor[] cons = c.getConstructors();<br>        <span class="hljs-comment">// c.遍历这些构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor con : cons) &#123;<br>            System.out.println(con.getName()+<span class="hljs-string">&quot;===&gt;&quot;</span>+con.getParameterCount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.getDeclaredConstructors():</span><br>    <span class="hljs-comment">// 获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.反射第一步先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.getDeclaredConstructors()：定位全部构造器，只要申明了就可以拿到</span><br>        Constructor[] cons = c.getDeclaredConstructors();<br>        <span class="hljs-comment">// c.遍历这些构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor con : cons) &#123;<br>            System.out.println(con.getName()+<span class="hljs-string">&quot;===&gt;&quot;</span>+con.getParameterCount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.getConstructor(Class... parameterTypes)</span><br>    <span class="hljs-comment">// 获取某个构造器：只能拿public修饰的某个构造器</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.getConstructor()：定位某个构造器，根据参数匹配，只能拿public修饰的！</span><br>        <span class="hljs-comment">// Constructor con = c.getConstructor(); // 报错!</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getConstructor(String.class  ,<span class="hljs-type">int</span>.class); <span class="hljs-comment">// 有参数的！!</span><br>        <span class="hljs-comment">// c.构造器名称和参数</span><br>        System.out.println(con.getName()+<span class="hljs-string">&quot;===&gt;&quot;</span>+con.getParameterCount());<br>    &#125;<br><br>    <span class="hljs-comment">// 4.getDeclaredConstructor</span><br>    <span class="hljs-comment">// 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.getDeclaredConstructor()：定位某个构造器，根据参数匹配，只要申明了就可以获取</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(); <span class="hljs-comment">// 可以拿到！定位无参数构造器！</span><br>        <span class="hljs-comment">//Constructor con = c.getDeclaredConstructor(String.class  , int.class); // 有参数的！!</span><br>        <span class="hljs-comment">// c.构造器名称和参数</span><br>        System.out.println(con.getName()+<span class="hljs-string">&quot;===&gt;&quot;</span>+con.getParameterCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取到构造器之后，可以通过该构造器初始化对象</p><p>反射获取<code>Class</code>中构造器对象<code>Constructor</code>的作用，就是用来初始化并得到类的一个对象返回</p><p><code>Constructor</code>的API</p><ul><li><p><code>T newInstance(Object... initargs)</code></p><p>创建对象，注入构造器需要的数据</p></li><li><p><code>void setAccessible(true)</code></p><p>修改访问权限，<code>true</code>代表暴力攻破权限，<code>false</code>表示保留不可访问权限</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent02</span> &#123;<br>    <span class="hljs-comment">// 1.调用无参数构造器得到一个类的对象返回。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createObj01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步是先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.定位无参数构造器对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>        <span class="hljs-comment">// c.暴力打开私有构造器的访问权限</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// d.通过无参数构造器初始化对象返回</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> (Student) constructor.newInstance(); <span class="hljs-comment">// 最终还是调用无参数构造器的！</span><br>        System.out.println(swk);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.调用有参数构造器得到一个类的对象返回。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createObj02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步是先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.定位有参数构造器对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class , <span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">// c.通过无参数构造器初始化对象返回</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> (Student) constructor.newInstance(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">10000</span>); <span class="hljs-comment">// 最终还是调用有参数构造器的！</span><br>        System.out.println(swk);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取Field成员变量对象"><a href="#获取Field成员变量对象" class="headerlink" title="获取Field成员变量对象"></a>获取Field成员变量对象</h3><ul><li><code>Field getField(String name);</code><br>根据成员变量名获得对应Field对象，只能获得public修饰</li><li><code>Field getDeclaredField(String name);</code><br>根据成员变量名获得对应Field对象，只要申明了就可以得到</li><li><code>Field[] getFields();</code><br>获得所有的成员变量对应的Field对象，只能获得public的</li><li><code>Field[] getDeclaredFields();</code><br>获得所有的成员变量对应的Field对象，只要申明了就可以得到</li></ul><p>对于<code>Dog</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> String color ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String school;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;宠物学校&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>获取其成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获取全部的成员变量。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredFields</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.获取全部申明的成员变量对象</span><br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName()+<span class="hljs-string">&quot;===&gt;&quot;</span>+field.getType());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        2.获取某个成员变量对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.定位某个成员变量对象 :根据名称定位！！</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageF</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(ageF.getName()+<span class="hljs-string">&quot;---&gt;&quot;</span>+ageF.getType());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>给成员变量取值和复制</p><ul><li><code>void set(Object obj, Object value)</code>：给对象注入某个成员变量数据</li><li><code>Object get(Object obj)</code> ：获取对象的成员变量的值。</li><li><code>void setAccessible(true)</code> ：暴力反射，设置为可以直接访问私有类型的属性。</li><li><code>Class getType()</code>：获取属性的类型，返回Class对象。</li><li><code>String getName()</code>：获取属性的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo02</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射的第一步获取Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class ;<br>        <span class="hljs-comment">// b.定位name成员变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameF</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// c.为这个成员变量赋值！</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">taiDi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        nameF.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴力反射！</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数一：被赋值的对象。</span><br><span class="hljs-comment">         * 参数二：该成员变量的值。</span><br><span class="hljs-comment">         */</span><br>        nameF.set(taiDi , <span class="hljs-string">&quot;勇敢的泰迪&quot;</span>);<br>        System.out.println(taiDi);<br><br>        <span class="hljs-comment">// d.获取成员变量的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> nameF.get(taiDi)+<span class="hljs-string">&quot;&quot;</span>;<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取Method方法"><a href="#获取Method方法" class="headerlink" title="获取Method方法"></a>获取Method方法</h3><p>反射获取类的Method方法对象：</p><ul><li><code>Method getMethod(String name,Class...args)</code>：根据方法名和参数类型获得对应的方法对象，只能获得public的</li><li><code>Method getDeclaredMethod(String name,Class...args)</code>：根据方法名和参数类型获得对应的方法对象，包括private的</li><li><code>Method[] getMethods()</code>：获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</li><li><code>Method[] getDeclaredMethods()</code>：获得类中的所有成员方法对象，返回数组,只获得本类申明的方法</li></ul><p>Method的方法执行：<br><code>Object invoke(Object obj, Object... args)</code></p><ul><li>参数一：触发的是哪个对象的方法执行</li><li>参数二： args：调用方法时传递的实际参数</li></ul><p><code>Dog</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗跑的贼快~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃&quot;</span>+name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;在吉山区有一只单身狗！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反射获取方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo01</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获得类中的所有成员方法对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredMethods</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class ;<br>        <span class="hljs-comment">// b.获取全部申明的方法!</span><br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-comment">// c.遍历这些方法</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName()+<span class="hljs-string">&quot;====&gt;&quot;</span><br>                    + method.getParameterCount()+<span class="hljs-string">&quot;===&gt;&quot;</span> + method.getReturnType());<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 获取某个方法对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclardMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.定位它的某个方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;run&quot;</span>);<br>        <span class="hljs-comment">// c.触发方法执行!</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">jinMao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> run.invoke(jinMao); <span class="hljs-comment">// 触发jinMao对象的run()方法执行！</span><br>        System.out.println(rs);<span class="hljs-comment">// 如果方法没有返回值，结果是null</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数一：方法名称</span><br><span class="hljs-comment">         * 参数二：方法的参数个数和类型(可变参数！)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>,String.class);<br>        eat.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴力反射！</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数一：被触发方法所在的对象</span><br><span class="hljs-comment">         * 参数二：方法需要的入参值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> eat.invoke(jinMao,<span class="hljs-string">&quot;肉&quot;</span>);<br>        System.out.println(rs1);<span class="hljs-comment">// 如果方法没有返回值，结果是null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="暴力攻击集合泛型"><a href="#暴力攻击集合泛型" class="headerlink" title="暴力攻击集合泛型"></a>暴力攻击集合泛型</h3><ul><li>反射可以破坏面向对象的封装性（暴力反射）</li><li>同时可以破坏泛型的约束性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 泛型只能工作在编译阶段，运行阶段泛型就消失了，</span><br><span class="hljs-comment">// 反射工作在运行时阶段。</span><br>List&lt;Double&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>scores.add(<span class="hljs-number">99.3</span>);<br>scores.add(<span class="hljs-number">199.3</span>);<br>scores.add(<span class="hljs-number">89.5</span>);<br><br><span class="hljs-comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。</span><br><span class="hljs-comment">// a.先得到集合对象的Class文件对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scores.getClass();<br><span class="hljs-comment">// b.从ArrayList的Class对象中定位add方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br><span class="hljs-comment">// c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）</span><br>add.invoke(scores,<span class="hljs-string">&quot;波仔&quot;</span>);<br><br>System.out.println(scores);<br></code></pre></td></tr></table></figure><h3 id="反射作用"><a href="#反射作用" class="headerlink" title="反射作用"></a>反射作用</h3><ul><li>可以在运行时得到一个类的全部成分然后操作。</li><li>可以破坏封装性。</li><li>也可以破坏泛型的约束性。</li></ul><p>更重要的用途是适合：做Java高级框架，基本上主流框架都会基于反射设计一些通用技术功能。</p><p>Mybatis框架：</p><p>你给任何一个对象数据我都可以直接帮你解析字段并且把对应数据保存起来。</p><p>Student (注册，把信息字段都存储起来)</p><p>Teacher (注册，把信息字段都存储起来)</p><p>Manager (注册，把信息字段都存储起来)</p><p>我现在用反射技术开发一个框架实现：</p><p>任何对象只要给我，我就可以把信息和字段都解析并存储起来。</p><blockquote><p>反射适合做通用技术框架的底层实现，在框架的底层源码中我们经常看到反射的影子!!</p></blockquote><h2 id="第三章-注解"><a href="#第三章-注解" class="headerlink" title="第三章 注解"></a>第三章 注解</h2><h3 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h3><ul><li>用在类上，方法上，成员变量，构造器，…上对成分进行编译约束，标记等操作的。</li><li>注解是JDK1.5的新特性。</li><li>注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。</li><li>注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span> &#123;<br><br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-meta">@interface</span> 注解名&#123;<br><span class="hljs-comment">// 注解属性</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>自定义注解用@interface关键字。</li><li>使用注解的格式：@注解名称。</li><li>注解默认可以标记很多地方。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Book</span><br><span class="hljs-meta">@MyTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBook</span> &#123;<br>    <span class="hljs-meta">@Book</span><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyBook</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-meta">@Book</span><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-meta">@MyTest</span> String[] args)</span> &#123;<br>        <span class="hljs-meta">@MyTest</span><br>        <span class="hljs-meta">@Book</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@interface</span> Book&#123;<br>&#125;<br><br><span class="hljs-meta">@interface</span> MyTest&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>属性的格式</p><ul><li>格式1：数据类型 属性名();</li><li>格式2：数据类型 属性名() default 默认值;</li></ul><p>属性适用的数据类型:</p><ul><li>八种基本数据类型<code>(int, short, long, double, byte, char, boolean, float)</code></li><li><code>String，Class</code></li><li>以上类型的数组形式都支持</li></ul><blockquote><ul><li>注解可以有属性，属性名必须带()</li><li>在用注解的时候，属性必须赋值，除非这个属性有默认值</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span> &#123;<br>    <span class="hljs-meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,</span><br><span class="hljs-meta">            price = 19.9 , address = &quot;北京&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义一个注解</span><br><span class="hljs-meta">@interface</span> MyBook&#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    String[] authors(); <span class="hljs-comment">// 数组</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">address</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;广州&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注解的特殊属性-value"><a href="#注解的特殊属性-value" class="headerlink" title="注解的特殊属性-value"></a>注解的特殊属性-value</h3><ul><li>如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写</li><li>但是如果有多个属性,且多个属性没有默认值，那么value是不能省略的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Book(value = &quot;/deleteBook.action&quot;)</span><br><span class="hljs-comment">//@Book(&quot;/deleteBook.action&quot;)</span><br><span class="hljs-comment">//@Book(value = &quot;/deleteBook.action&quot; , age = 12)</span><br><span class="hljs-comment">//@Book(&quot;/deleteBook.action&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span>&#123;<br>&#125;<br><br><span class="hljs-meta">@interface</span> Book&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li>元注解是sun公司提供的。</li><li>元注解是用在自定义注解上的注解。</li><li>元注解是用来注解自定义注解的。</li></ul><p>元注解有两个：</p><ul><li><code>@Target</code>:约束自定义注解只能在哪些地方使用，但是默认的注解可以在类，方法，构造器，成员变量，… 使用。</li><li><code>@Retention</code>：声明注解的生命周期<br>申明注解的作用范围：编译时，运行时。</li></ul><p><code>@Target</code></p><ul><li>作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。</li><li>可使用的值定义在ElementType枚举类中，常用值如下<ul><li>TYPE，类，接口</li><li>FIELD, 成员变量</li><li>METHOD, 成员方法</li><li>PARAMETER, 方法参数</li><li>CONSTRUCTOR, 构造器</li><li>LOCAL_VARIABLE, 局部变量</li></ul></li></ul><p><code>@Retention</code></p><ul><li>作用：用来标识注解的生命周期(有效存活范围)</li><li>可使用的值定义在RetentionPolicy枚举类中，常用值如下<ul><li>SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在</li><li>CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</li><li>RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</li></ul></li></ul><blockquote><ul><li><code>@Target</code>约束自定义注解可以标记的范围。</li><li><code>@Retention</code>用来约束自定义注解的存活范围。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span>&#123;<br>    <span class="hljs-comment">// @MyTest</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRun</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//@Target(&#123;ElementType.METHOD , ElementType.FIELD&#125;) // 申明只能注解方法和成员变量！</span><br><span class="hljs-meta">@Target(ElementType.METHOD )</span> <span class="hljs-comment">// 申明只能注解方法</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 申明注解从写代码一直到运行还在，永远存活！！</span><br><span class="hljs-meta">@interface</span> MyTest&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h3><p>我们会使用注解注释一个类的成分，那么就设计到要解析出这些注解的数据。开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析。</p><p>与注解解析相关的接口<br>        1. <code>Annotation</code>: 注解类型，该类是所有注解的父类。注解都是一个<code>Annotation</code>的对象<br>     1. <code>AnnotatedElement</code>:该接口定义了与注解解析相关的方法<br>          2所有的类成分Class, Method , Field , Constructor：都实现了<code>AnnotatedElement</code>接口，他们都拥有解析注解的能力：<br>       * <code>Annotation[] getDeclaredAnnotations()</code><br>          获得当前对象上使用的所有注解，返回注解数组。<br>        * <code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code><br>          根据注解类型获得对应注解对象<br>        * <code>boolean isAnnotationPresent(Class&lt;Annotation&gt; annotationClass)</code><br>          判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</p><p>解析注解数据的原理</p><ul><li>注解在哪个成分上，我们就先拿哪个成分对象。</li><li>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</li><li>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</li><li>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseClass</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 1.定位Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class ;<br>        <span class="hljs-comment">// 2.判断这个类上是否使用了某个注解</span><br>        <span class="hljs-keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;<br>            <span class="hljs-comment">// 3.获取这个注解对象</span><br>            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book) c.getDeclaredAnnotation(Book.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.authors()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.定位Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class ;<br>        <span class="hljs-comment">// 2.定位方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;run&quot;</span>);<br>        <span class="hljs-comment">// 3.判断这个方法上是否使用了某个注解</span><br>        <span class="hljs-keyword">if</span>(run.isAnnotationPresent(Book.class))&#123;<br>            <span class="hljs-comment">// 3.获取这个注解对象</span><br>            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book) run.getDeclaredAnnotation(Book.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.authors()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Book(value = &quot;《Java基础到精通》&quot; , price = 99.5 , authors = &#123;&quot;波仔&quot;,&quot;波妞&quot;&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span>&#123;<br>    <span class="hljs-meta">@Book(value = &quot;《Mybatis持久层框架》&quot; , price = 199.5 , authors = &#123;&quot;dlei&quot;,&quot;播客&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="hljs-comment">// 类和成员方法上使用</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 注解永久存活</span><br><span class="hljs-meta">@interface</span> Book&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">100</span>;<br>    String[] authors();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="注解模拟Junit框架"><a href="#注解模拟Junit框架" class="headerlink" title="注解模拟Junit框架"></a>注解模拟Junit框架</h3><p>需求：定义若干个方法，只要加了MyTest注解，就可以被自动触发执行。</p><p>分析：</p><ol><li>定义一个自定义注解MyTest.<br>只能注解方法。<br>存活范围一直都在。</li><li>定义若干个方法，只要有<code>@MyTest</code>注解的方法就能被触发执行！！<br>没有这个注解的方法不能执行</li></ol><blockquote><ul><li>注解和反射可以配合解决一些框架思想</li><li>注解可以实现标记的成分做特殊处理!!</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===test01===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===test02===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===test03===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===test04===&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TestDemo</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDemo</span>();<br>        <span class="hljs-comment">// 模拟测试类的启动按钮，实现有注解标记的方法就要触发执行。</span><br>        <span class="hljs-comment">// 1.得到类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> TestDemo.class;<br>        <span class="hljs-comment">// 2.获取类中全部方法对象</span><br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-comment">// 3.遍历全部方法，有注解就触发执行</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            <span class="hljs-keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;<br>                <span class="hljs-comment">// 触发此方法执行。</span><br>                method.invoke(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span> <span class="hljs-comment">// 只能注解方法！</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 一直都活着</span><br><span class="hljs-meta">@interface</span> MyTest&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-动态代理"><a href="#第四章-动态代理" class="headerlink" title="第四章 动态代理"></a>第四章 动态代理</h2><ul><li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事。</li><li>动态代理只能为实现接口的实现类对象做代理(也可以只为接口做代理对象)</li></ul><p>引入：</p><ul><li>在业务开发中经常存在很多重复的方法代码，他们前后的代码形式是一样的</li><li>只有中间部分代码有差别！！这种时候代码冗余读很高</li><li>有没有一种方法可以直接省略前后重复的代码就可以完成功能，这时候用动态代理。</li></ul><p>开发步骤：</p><ul><li>必须有接口。</li><li>实现类要实现接口，定义自己的业务功能代码。</li><li>为业务功能做代理对象（动态代理，难点）</li></ul><blockquote><ul><li>动态代理非常的灵活，可以为任意的接口实现类对象做代理</li><li>动态代理可以为被代理对象的所有接口的所有方法做代理，</li><li>动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，</li><li>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</li><li>动态代理同时也提高了开发效率。</li><li>缺点：只能针对接口或者接口的实现类对象做代理对象，普通类是不能做代理对象的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 做一个被代理的业务对象返回!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         参数一：类加载器:负责加载到时候做好的业务代理对象！</span><br><span class="hljs-comment">         参数二：被代理业务对象的全部实现的接口，以便代理对象可以知道要为哪些方法做代理。</span><br><span class="hljs-comment">         参数三：代理真正的执行方法，也就是代理的处理逻辑！</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(obj.getClass().getClassLoader(),<br>                obj.getClass().getInterfaces(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] params)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                        <span class="hljs-comment">// proxy : 业务代理对象本身。用不到</span><br>                        <span class="hljs-comment">// method: 代表当前正在被代理执行的方法！！</span><br>                        <span class="hljs-comment">// params: 代表的是执行方法的参数，数组的形式!</span><br>                        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>                        <span class="hljs-comment">// 真正触发真实的方法执行</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> method.invoke(obj,params);<br><br>                        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                        System.out.println(method.getName()+<span class="hljs-string">&quot;方法耗时：&quot;</span>+(endTime - startTime)/<span class="hljs-number">1000.0</span>+<span class="hljs-string">&quot;s&quot;</span>);<br>                        <span class="hljs-keyword">return</span> rs; <span class="hljs-comment">// 返回方法执行的结果！！</span><br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="day13-XML和Dom4j、装饰模式、工厂模式、commons-io工具包"><a href="#day13-XML和Dom4j、装饰模式、工厂模式、commons-io工具包" class="headerlink" title="day13-XML和Dom4j、装饰模式、工厂模式、commons-io工具包"></a>day13-XML和Dom4j、装饰模式、工厂模式、commons-io工具包</h1><h2 id="第一章-Dom4j"><a href="#第一章-Dom4j" class="headerlink" title="第一章 Dom4j"></a>第一章 Dom4j</h2><h3 id="Dom4j获取Document对象和根元素"><a href="#Dom4j获取Document对象和根元素" class="headerlink" title="Dom4j获取Document对象和根元素"></a>Dom4j获取Document对象和根元素</h3><p>dom4j属于第三方技术，必须导入该框架！！</p><p>dom4j安装步骤：</p><ul><li>去dom4j官网下载dom4j的框架：都是一些jar包。</li><li>把dom4j的核心jar包导入到当前项目中去。</li><li>在项目中创建一个文件夹：lib</li><li>将dom4j-2.1.1.jar文件复制到 lib 文件夹</li><li>在jar文件上点右键，选择 Add as Library -&gt; 点击OK</li><li>在类中导包使用</li></ul><p>Java提供了Class下的一个方法：</p><p><code>public InputStream getResourceAsStream(String path)</code></p><p> 用于加载文件成为一个字节输入流返回！！</p><p>Document文档：<br><code>Element getRootElement()</code>：获取根元素。</p><blockquote><ul><li>先导入dom4j框架</li><li>创建一个dom4j的解析对象：SAXReader</li><li>通过解析对象把xml文件解析成Document文档对象。</li><li>从Document文档对象中获取我们想要的xml信息。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span><br><span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br><span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br><span class="hljs-comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span><br><span class="hljs-comment">//Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));</span><br><br><span class="hljs-comment">// 3.第二种方式（代码多点）先把xml文件读成一个字节输入流</span><br><span class="hljs-comment">// 这里的“/”是直接去src类路径下寻找文件。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="hljs-string">&quot;/books.xml&quot;</span>);<br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br><br>System.out.println(document);<br><br><span class="hljs-comment">// 4.从document文档树对象中提取根元素对象</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>System.out.println(root.getName());<br></code></pre></td></tr></table></figure><p>Element元素的API:</p><ul><li><code>String getName()</code>:取元素的名称。</li><li><code>List&lt;Element&gt; elements()</code>:获取当前元素下的全部子元素（一级）</li><li><code>List&lt;Element&gt; elements(String name)</code>:获取当前元素下的指定名称的全部子元素（一级）</li><li><code>Element element(String name)</code>:获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span><br><span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br><span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br><span class="hljs-comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>));<br><br><span class="hljs-comment">// 3.获取根元素对象</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>System.out.println(root.getName());<br><br><span class="hljs-comment">// 4.获取根元素下的全部子元素</span><br>List&lt;Element&gt; sonElements = root.elements();<br><span class="hljs-keyword">for</span> (Element sonElement : sonElements) &#123;<br>    System.out.println(sonElement.getName());<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br><span class="hljs-comment">// 5.获取根源下的全部book子元素</span><br>List&lt;Element&gt; sonElements1 = root.elements(<span class="hljs-string">&quot;book&quot;</span>);<br><span class="hljs-keyword">for</span> (Element sonElement : sonElements1) &#123;<br>    System.out.println(sonElement.getName());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br><span class="hljs-comment">// 6.获取根源下的指定的某个元素</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">son</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;user&quot;</span>);<br>System.out.println(son.getName());<br><br><span class="hljs-comment">// 默认会提取第一个名称一样的子元素对象返回！</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">son1</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;book&quot;</span>);<br>System.out.println(son1.attributeValue(<span class="hljs-string">&quot;id&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="Dom4j获取属性信息"><a href="#Dom4j获取属性信息" class="headerlink" title="Dom4j获取属性信息"></a>Dom4j获取属性信息</h3><p>Element元素的API:</p><ul><li><code>List&lt;Attribute&gt; attributes()</code>: 获取元素的全部属性对象。</li><li><code>Attribute attribute(String name)</code>:根据名称获取某个元素的属性对象。</li><li><code>String attributeValue(String var1)</code>:直接获取某个元素的某个属性名称的值。</li></ul><p>Attribute对象的API:</p><ul><li><code>String getName()</code>:  获取属性名称。</li><li><code>String getValue()</code>: 获取属性值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br><span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br><span class="hljs-comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;day13/src/books.xml&quot;</span>));<br><br><span class="hljs-comment">// 3.获取根元素对象。</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br><br><span class="hljs-comment">// 4.获取book子元素</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">bookEle</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;book&quot;</span>);<br><br><span class="hljs-comment">// 5.获取book元素的全部属性对象</span><br>List&lt;Attribute&gt; attributes = bookEle.attributes();<br><span class="hljs-keyword">for</span> (Attribute attribute : attributes) &#123;<br>    System.out.println(attribute.getName()+<span class="hljs-string">&quot;=&gt;&quot;</span>+attribute.getValue());<br>&#125;<br><br><span class="hljs-comment">// 6.获取Book元素的某个属性对象</span><br><span class="hljs-type">Attribute</span> <span class="hljs-variable">descAttr</span> <span class="hljs-operator">=</span> bookEle.attribute(<span class="hljs-string">&quot;desc&quot;</span>);<br>System.out.println(descAttr.getName()+<span class="hljs-string">&quot;---&gt;&quot;</span>+descAttr.getValue());<br><br><span class="hljs-comment">// 7.可以直接获取元素的属性值</span><br>System.out.println(bookEle.attributeValue(<span class="hljs-string">&quot;id&quot;</span>));<br>System.out.println(bookEle.attributeValue(<span class="hljs-string">&quot;desc&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="Dom4j获取XML文本"><a href="#Dom4j获取XML文本" class="headerlink" title="Dom4j获取XML文本"></a>Dom4j获取XML文本</h3><ul><li><code>String elementText(String name)</code>: 可以直接获取当前元素的子元素的文本内容</li><li><code>String elementTextTrim(String name)</code>: 去前后空格,直接获取当前元素的子元素的文本内容</li><li><code>String getText()</code>:直接获取当前元素的文本内容。</li><li><code>String getTextTrim()</code>:去前后空格,直接获取当前元素的文本内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br><span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br><span class="hljs-comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>));<br><br><span class="hljs-comment">// 3.获取根元素对象。</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br><br><span class="hljs-comment">// 4.得到第一个子元素book</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">bookEle</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;book&quot;</span>);<br><br><span class="hljs-comment">// 5.直接拿到当前book元素下的子元素文本值</span><br>System.out.println(bookEle.elementText(<span class="hljs-string">&quot;name&quot;</span>));<br>System.out.println(bookEle.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// 去前后空格</span><br>System.out.println(bookEle.elementText(<span class="hljs-string">&quot;author&quot;</span>));<br>System.out.println(bookEle.elementTextTrim(<span class="hljs-string">&quot;author&quot;</span>)); <span class="hljs-comment">// 去前后空格</span><br>System.out.println(bookEle.elementText(<span class="hljs-string">&quot;sale&quot;</span>));<br>System.out.println(bookEle.elementTextTrim(<span class="hljs-string">&quot;sale&quot;</span>)); <span class="hljs-comment">// 去前后空格</span><br><br><span class="hljs-comment">// 6.先获取到子元素对象，再获取该文本值</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">bookNameEle</span> <span class="hljs-operator">=</span> bookEle.element(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(bookNameEle.getText());<br>System.out.println(bookNameEle.getTextTrim());<span class="hljs-comment">// 去前后空格</span><br></code></pre></td></tr></table></figure><h3 id="Dom4j解析案例"><a href="#Dom4j解析案例" class="headerlink" title="Dom4j解析案例"></a>Dom4j解析案例</h3><p>Contacts.xml 解析成&#x3D;&#x3D;&#x3D;&gt;<code> List&lt;Contact&gt;</code></p><p>首先定义一个<code>Contact</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> &lt;contact id=&quot;1&quot; vip=&quot;true&quot;&gt;</span><br><span class="hljs-comment">     &lt;name&gt;潘金莲&lt;/name&gt;</span><br><span class="hljs-comment">     &lt;gender&gt;女&lt;/gender&gt;</span><br><span class="hljs-comment">     &lt;email&gt;panpan@itcast.cn&lt;/email&gt;</span><br><span class="hljs-comment"> &lt;/contact&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Contact</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> vip;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex ;<br>    <span class="hljs-keyword">private</span> String email ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Contact</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Contact</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">boolean</span> vip, String name, <span class="hljs-type">char</span> sex, String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.vip = vip;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> vip</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVip</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vip;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> vip</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVip</span><span class="hljs-params">(<span class="hljs-type">boolean</span> vip)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vip = vip;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> name</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> sex</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sex</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> email</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> email;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> email</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmail</span><span class="hljs-params">(String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Contact&#123;id = &quot;</span> + id + <span class="hljs-string">&quot;, vip = &quot;</span> + vip + <span class="hljs-string">&quot;, name = &quot;</span> + name + <span class="hljs-string">&quot;, sex = &quot;</span> + sex + <span class="hljs-string">&quot;, email = &quot;</span> + email + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br><span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br><span class="hljs-comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;day13/src/Contacts.xml&quot;</span>));<br><br><span class="hljs-comment">// 3.获取根元素对象。</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br><br><span class="hljs-comment">// 4.获取根元素下的全部子元素</span><br>List&lt;Element&gt; sonElements = root.elements();<br><br><span class="hljs-comment">// 5.遍历子元素 封装成List集合对象</span><br>List&lt;Contact&gt; contactList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">if</span>(sonElements != <span class="hljs-literal">null</span> &amp;&amp; sonElements.size() &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">for</span> (Element sonElement : sonElements) &#123;<br>        <span class="hljs-type">Contact</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>();<br>        contact.setId(Integer.valueOf(sonElement.attributeValue(<span class="hljs-string">&quot;id&quot;</span>)));<br>        contact.setVip(Boolean.valueOf(sonElement.attributeValue(<span class="hljs-string">&quot;vip&quot;</span>)));<br>        contact.setName(sonElement.elementText(<span class="hljs-string">&quot;name&quot;</span>));<br>        contact.setSex(sonElement.elementText(<span class="hljs-string">&quot;gender&quot;</span>).charAt(<span class="hljs-number">0</span>));<br>        contact.setEmail(sonElement.elementText(<span class="hljs-string">&quot;email&quot;</span>));<br>        contactList.add(contact);<br>    &#125;<br>&#125;<br>System.out.println(contactList);<br></code></pre></td></tr></table></figure><h3 id="Xpath表达式"><a href="#Xpath表达式" class="headerlink" title="Xpath表达式"></a>Xpath表达式</h3><p>用于检索XML中的某些信息</p><p>XPath使用步骤：</p><ol><li>导入dom4j框架。（XPath依赖于Dom4j技术,必须先倒入dom4j框架！）</li><li>导入XPath独有的框架包。jaxen-1.1.2.jar</li></ol><p>XPath常用API:</p><ul><li><code>List&lt;Node&gt; selectNodes(String var1)</code>：检索出一批节点集合。</li><li><code>Node selectSingleNode(String var1)</code>：检索出一个节点返回。</li></ul><p>XPath提供的四种检索数据的写法：</p><ol><li>绝对路径</li><li>相对路径</li><li>全文搜索</li><li>属性查找</li></ol><blockquote><ol><li>绝对路径： &#x2F;根元素&#x2F;子元素&#x2F;子元素。</li><li>相对路径： .&#x2F;子元素&#x2F;子元素。 (.代表了当前元素)</li><li>全文搜索：<br><code>//元素</code>  在全文找这个元素<br><code>//元素1/元素2</code>  在全文找元素1下面的一级元素2<br><code>//元素1//元素2  </code>在全文找元素1下面的全部元素2</li><li>属性查找。<br><code>//@属性名称</code>  在全文检索属性对象。<br><code>//元素[@属性名称]</code>  在全文检索包含该属性的元素对象。<br><code>//元素[@属性名称=值]</code>  在全文检索包含该属性的元素且属性值为该值的元素对象。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XPathDemo</span> &#123;<br><br>    <span class="hljs-comment">//  1.绝对路径： /根元素/子元素/子元素。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">path01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br>        <span class="hljs-comment">// 2.第二种方式（代码多点）先把xml文件读成一个字节输入流</span><br>        <span class="hljs-comment">// 这里的“/”是直接去src类路径下寻找文件。</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="hljs-string">&quot;/Contact.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br>        <span class="hljs-comment">// 3.使用绝对路径定位全部的name名称</span><br>        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="hljs-string">&quot;/contactList/contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            System.out.println(nameNode.getText());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">path02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br>        <span class="hljs-comment">// 2.第二种方式（代码多点）先把xml文件读成一个字节输入流</span><br>        <span class="hljs-comment">// 这里的“/”是直接去src类路径下寻找文件。</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="hljs-string">&quot;/Contact.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br><br>        <span class="hljs-comment">// 3.得到根元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br><br>        <span class="hljs-comment">// 4.从根元素开始检索</span><br>        <span class="hljs-comment">// .代表当前根元素对象路径！直接找其下的contact下的name</span><br>        List&lt;Node&gt; nameNodes = root.selectNodes(<span class="hljs-string">&quot;./contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            System.out.println(nameNode.getText());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.全文搜索：</span><br>    <span class="hljs-comment">//                &quot;//元素&quot;  在全文找这个元素</span><br>    <span class="hljs-comment">//                &quot;//元素1/元素2&quot;  在全文找元素1下面的一级元素2</span><br>    <span class="hljs-comment">//                &quot;//元素1//元素2&quot;  在全文找元素1下面的全部元素2</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">path03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br>        <span class="hljs-comment">// 2.第二种方式（代码多点）先把xml文件读成一个字节输入流</span><br>        <span class="hljs-comment">// 这里的“/”是直接去src类路径下寻找文件。</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="hljs-string">&quot;/Contact.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br><br>        <span class="hljs-comment">// 3.//name是指在整个xml文件中检索name节点！</span><br>        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="hljs-string">&quot;//name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            System.out.println(nameNode.getText());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>        <span class="hljs-comment">// 4.在全文中检索所有contact下的直接name节点</span><br>        List&lt;Node&gt; nameNodes1 = document.selectNodes(<span class="hljs-string">&quot;//contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes1) &#123;<br>            System.out.println(nameNode.getText());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>        <span class="hljs-comment">// 5.在全文中检索所有contact下的所有name节点</span><br>        List&lt;Node&gt; nameNodes2 = document.selectNodes(<span class="hljs-string">&quot;//contact//name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes2) &#123;<br>            System.out.println(nameNode.getText());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//   4.属性查找。</span><br>    <span class="hljs-comment">//         //@属性名称  在全文检索属性对象。</span><br>    <span class="hljs-comment">//          //元素[@属性名称]  在全文检索包含该属性的元素对象。</span><br>    <span class="hljs-comment">//          //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">path04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br>        <span class="hljs-comment">// 2.第二种方式（代码多点）先把xml文件读成一个字节输入流</span><br>        <span class="hljs-comment">// 这里的“/”是直接去src类路径下寻找文件。</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="hljs-string">&quot;/Contact.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br><br>        <span class="hljs-comment">// 3.检索全部属性对象</span><br>        List&lt;Node&gt; attributs = document.selectNodes(<span class="hljs-string">&quot;//@id&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node attribut : attributs) &#123;<br>            <span class="hljs-type">Attribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> (Attribute) attribut;<br>            System.out.println(attr.getName() + <span class="hljs-string">&quot;---&gt;&quot;</span>+attr.getValue());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;---------------&quot;</span>);<br>        <span class="hljs-comment">// 4.//元素[@属性名称]  在全文检索包含该属性的元素对象</span><br>        List&lt;Node&gt; nodeEles = document.selectNodes(<span class="hljs-string">&quot;//contact[@id]&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nodeEle : nodeEles) &#123;<br>            System.out.println(nodeEle.getName());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;---------------&quot;</span>);<br>        <span class="hljs-comment">// 5. //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">nodeEle</span> <span class="hljs-operator">=</span> document.selectSingleNode(<span class="hljs-string">&quot;//contact[@id=2]&quot;</span>);<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) nodeEle;<br>        System.out.println(ele.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解析Mybatis的核心配置文件信息"><a href="#解析Mybatis的核心配置文件信息" class="headerlink" title="解析Mybatis的核心配置文件信息"></a>解析Mybatis的核心配置文件信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseXMLConfig</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseXML</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建一个解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// 2.加载类路径下的xml文件成为一个document文档对象。</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(ParseXMLConfig.class.getResourceAsStream(<span class="hljs-string">&quot;/sqlMapConfig.xml&quot;</span>));<br>        <span class="hljs-comment">// 3.得到根元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// 4.获取子元素environments</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">environments</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;environments&quot;</span>);<br>        <span class="hljs-comment">// 5.获取子元素environment</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> environments.element(<span class="hljs-string">&quot;environment&quot;</span>);<br>        <span class="hljs-comment">// 6.获取子元素dataSource</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> environment.element(<span class="hljs-string">&quot;dataSource&quot;</span>);<br>        <span class="hljs-comment">// 7.获取 dataSource下的全部子元素</span><br>        List&lt;Element&gt;  properties = dataSource.elements();<br>        <span class="hljs-comment">// 8.遍历他们</span><br>        <span class="hljs-keyword">for</span> (Element property : properties) &#123;<br>            System.out.println(property.attributeValue(<span class="hljs-string">&quot;name&quot;</span>)<br>                    +<span class="hljs-string">&quot;==&gt;&quot;</span>+property.attributeValue(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章-设计模式"><a href="#第二章-设计模式" class="headerlink" title="第二章 设计模式"></a>第二章 设计模式</h2><h3 id="工厂设计模型"><a href="#工厂设计模型" class="headerlink" title="工厂设计模型"></a>工厂设计模型</h3><p>什么是工厂设计模式？</p><ul><li>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一</li><li>这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式</li><li>之前我们创建类对象时, 都是使用<code>new</code>对象的形式创建, 除<code>new</code>对象方式以外，工厂模式也可以创建对象</li></ul><p>工厂设计模式的作用：</p><ul><li>对象通过工厂的方法创建返回，工厂的方法可以为该对象进行加工和数据注入。</li><li>可以实现类与类之间的<strong>解耦操作</strong></li></ul><blockquote><ul><li>优点：工厂模式的存在可以改变创建对象的方式,解决类与类之间的耦合</li><li>缺点：工厂设计模式多了一个工厂类</li></ul></blockquote><p><code>FactoryPattern</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryPattern</span> &#123;<br>    <span class="hljs-comment">// 生产对象的方法：工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Animal <span class="hljs-title function_">createAniaml</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//        Dog dog = new Dog();</span><br><span class="hljs-comment">//        return dog;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建对象可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> FactoryPattern.createAniaml();<br>a.run();<br></code></pre></td></tr></table></figure><p>之后如果需要修改创建的对象，可以直接在<code>FactoryPattern</code>中修改对象创建</p><h3 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h3><p>装饰模式指的是在不改变原类, 动态地扩展一个类的功能。</p><p>思想：是创建一个新类，包装原始类，从而在新类中提升原来类的功能！！</p><blockquote><p>装饰模式可以在不改变原类的基础上对类中的方法进行扩展增强,实现原则为:</p><ol><li>定义父类</li><li>定义原始类，继承父类，定义功能。</li><li>定义装饰类，继承父类，包装原始类，增强功能！！</li></ol></blockquote><p><code>InputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileInputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取数据~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭流~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>BufferedInputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">private</span> InputStream is ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStrem</span><span class="hljs-params">(InputStream is)</span>&#123;<br>        <span class="hljs-built_in">this</span>.is = is;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开启高效缓冲读取~&quot;</span>);<br>        is.read();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        is.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Demo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStrem</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>());<br>is.read();<br>is.close();<br></code></pre></td></tr></table></figure><h2 id="第三章-Commons-io包"><a href="#第三章-Commons-io包" class="headerlink" title="第三章 Commons-io包"></a>第三章 Commons-io包</h2><p>什么是<code>Commons-io</code>包？</p><p>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以挺提高IO功能开发的效率。commons-io工具包提供了很多有关io操作的类，见下表：</p><table><thead><tr><th>包</th><th>功能描述</th></tr></thead><tbody><tr><td>org.apache.commons.io</td><td>有关Streams、Readers、Writers、Files的工具类</td></tr><tr><td>org.apache.commons.io.input</td><td>输入流相关的实现类，包含Reader和InputStream</td></tr><tr><td>org.apache.commons.io.output</td><td>输出流相关的实现类，包含Writer和OutputStream</td></tr><tr><td>org.apache.commons.io.serialization</td><td>序列化相关的类</td></tr></tbody></table><p>步骤：</p><ol><li>下载commons-io相关jar包；<a href="http://commons.apache.org/proper/commons-io/">http://commons.apache.org/proper/commons-io/</a></li><li>把commons-io-2.6.jar包复制到指定的Module的lib目录中</li><li>将commons-io-2.6.jar加入到classpath中</li></ol><blockquote><p><code>IOUtils</code>和<code>FileUtils</code>可以方便的复制文件和文件夹</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.完成文件复制！</span><br>IOUtils.copy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Day13Demo/new.xml&quot;</span>));<br><span class="hljs-comment">// 2.完成文件复制到某个文件夹下！</span><br>FileUtils.copyFileToDirectory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/itcast&quot;</span>));<br><span class="hljs-comment">// 3.完成文件夹复制到某个文件夹下！</span><br>FileUtils.copyDirectoryToDirectory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast\\约吧图片服务器&quot;</span>) , <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\&quot;</span>));<br><br><span class="hljs-comment">//  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。</span><br>Files.copy(Paths.get(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>)<br>        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Day13Demo/new11.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="第四章-Base64"><a href="#第四章-Base64" class="headerlink" title="第四章 Base64"></a>第四章 Base64</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。</p><p>在Java 8中，Base64编码已经成为Java类库的标准。</p><p>Java 8 内置了 Base64 编码的编码器和解码器。</p><p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ul><li><strong>基本：</strong>输出被映射到一组字符A-Za-z0-9+&#x2F;，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+&#x2F;。</li><li><strong>URL：</strong>输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li><li><strong>MIME：</strong>输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li></ul><p><strong>内嵌类</strong></p><table><thead><tr><th align="left">序号</th><th align="left">内嵌类 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>static class Base64.Decoder</strong>该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td></tr><tr><td align="left">2</td><td align="left"><strong>static class Base64.Encoder</strong>该类实现一个编码器，使用 Base64 编码来编码字节数据</td></tr></tbody></table><p><strong>方法</strong></p><table><thead><tr><th align="left">序号</th><th align="left">方法名 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">**static Base64.Decoder getDecoder()**返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td></tr><tr><td align="left">2</td><td align="left">**static Base64.Encoder getEncoder()**返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td></tr><tr><td align="left">3</td><td align="left">**static Base64.Decoder getMimeDecoder()**返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td></tr><tr><td align="left">4</td><td align="left">**static Base64.Encoder getMimeEncoder()**返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td></tr><tr><td align="left">5</td><td align="left">**static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)**返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td></tr><tr><td align="left">6</td><td align="left">**static Base64.Decoder getUrlDecoder()**返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td></tr><tr><td align="left">7</td><td align="left">**static Base64.Encoder getUrlEncoder()**返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td></tr></tbody></table><blockquote><p><strong>注意：</strong>Base64 类的很多方法从 <strong>java.lang.Object</strong> 类继承</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 1-1.基本编码后结果。普通文本的编码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(<span class="hljs-string">&quot;黑马程序员&quot;</span>.getBytes());<br>    System.out.println(rs1); <span class="hljs-comment">// 6buR6ams56iL5bqP5ZGY</span><br><br>    <span class="hljs-comment">// 1-2.基本解码后结果。普通文本的解码</span><br>    <span class="hljs-type">byte</span>[] buffer = Base64.getDecoder().decode(rs1);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer));<br><br>    <span class="hljs-comment">// 2-1.URL编码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> Base64.getUrlEncoder().encodeToString(<span class="hljs-string">&quot;?loginName=黑马&amp;passWord=123456&quot;</span>.getBytes());<br>    System.out.println(rs2);<br>    <span class="hljs-comment">// 2-2 URL解码</span><br>    <span class="hljs-type">byte</span>[] buffer2 = Base64.getUrlDecoder().decode(rs2);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer2));<br><br>    <span class="hljs-comment">// 3-1 MIME编码</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        sb.append(UUID.randomUUID().toString());<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs3</span> <span class="hljs-operator">=</span> Base64.getMimeEncoder().encodeToString(sb.toString().getBytes());<br>    System.out.println(rs3);<br><br>    <span class="hljs-comment">// 3-2 MIME解码</span><br>    <span class="hljs-type">byte</span>[] buffer3 = Base64.getMimeDecoder().decode(rs3);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer3));<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    System.out.println(<span class="hljs-string">&quot;Error :&quot;</span> + e.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>八股文</tag>
      
      <tag>Java进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1260二维网格迁移</title>
    <link href="/2022/07/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1260.%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
    <url>/2022/07/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1260.%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode.cn/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><p>难度简单79</p><p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p><p>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/e1-1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[9,1,2],[3,4,5],[6,7,8]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/e2-1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[3,8,1,9]</span>,<span class="hljs-comment">[19,7,2,5]</span>,<span class="hljs-comment">[4,6,11,10]</span>,<span class="hljs-comment">[12,0,21,13]</span>]</span>, k = 4<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[12,0,21,13]</span>,<span class="hljs-comment">[3,8,1,9]</span>,<span class="hljs-comment">[19,7,2,5]</span>,<span class="hljs-comment">[4,6,11,10]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span>, k = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m &lt;= 50</code></li><li><code>1 &lt;= n &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接使用模拟的方式即可推断</p><p>假定矩阵<code>grid</code>的行列长度分别为<code>n, m</code>，首先对 k 进行求余操作，即 <code>k %= (m * n)</code>，然后使用模拟的方式得到迁移后的矩阵，对于迁移的元素索引为<code>i,j</code>, 该元素迁移前则在<code>i, j-k</code>位置，有以下两种情况：</p><ul><li><code>j-k&gt;=0</code>，可以直接迁移前的<code>i, j-k</code>的元素赋给迁移后的矩阵</li><li><code>j-k&lt;0</code>，那么向上一行查找，即<code>i--</code>，<code>k</code>已经迁移了<code>j+1</code>个元素，需要减去，即<code>j=m-1</code>，再判断是否<code>j-k&lt;0</code>成立，如果成立，继续这一步操作，其中，如果<code>i&lt;0</code>，则<code>i=n-1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">shiftGrid</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length, m = grid[<span class="hljs-number">0</span>].length;<br>        k %= (n * m);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tempi</span> <span class="hljs-operator">=</span> i, tempj = j, tempk = k;<br>                <span class="hljs-keyword">while</span> (tempj - tempk&lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (tempi == <span class="hljs-number">0</span>)<br>                        tempi = n-<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span><br>                        tempi--;<br>                    tempk -= (tempj + <span class="hljs-number">1</span>);<br>                    tempj = m-<span class="hljs-number">1</span>;<br>                &#125;<br>                temp.add(grid[tempi][tempj-tempk]);<br>            &#125;<br>            res.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nmk)$</li><li>空间复杂度：$O(nm)$</li></ul><p><img src="/img/post_img/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220720153625347.png" alt="image-20220720153625347"></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>数组</tag>
      
      <tag>矩阵</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>821字符的最短距离</title>
    <link href="/2022/07/19/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/821.%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/07/19/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/821.%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="821-字符的最短距离"><a href="#821-字符的最短距离" class="headerlink" title="821.字符的最短距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821.字符的最短距离</a></h1><p>难度简单253收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>s</code> 和一个字符 <code>c</code> ，且 <code>c</code> 是 <code>s</code> 中出现过的字符。</p><p>返回一个整数数组 <code>answer</code> ，其中 <code>answer.length == s.length</code> 且 <code>answer[i]</code> 是 <code>s</code> 中从下标 <code>i</code> 到离它 <strong>最近</strong> 的字符 <code>c</code> 的 <strong>距离</strong> 。</p><p>两个下标 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>abs(i - j)</code> ，其中 <code>abs</code> 是绝对值函数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;loveleetcode&quot;, c = &quot;e&quot;<br>输出：[3,2,1,0,1,0,0,1,2,2,1,0]<br>解释：字符 &#x27;e&#x27; 出现在下标 3、5、6 和<span class="hljs-number"> 11 </span>处（下标从<span class="hljs-number"> 0 </span>开始计数）。<br>距下标<span class="hljs-number"> 0 </span>最近的 &#x27;e&#x27; 出现在下标<span class="hljs-number"> 3 </span>，所以距离为 abs(0 - 3) =<span class="hljs-number"> 3 </span>。<br>距下标<span class="hljs-number"> 1 </span>最近的 &#x27;e&#x27; 出现在下标<span class="hljs-number"> 3 </span>，所以距离为 abs(1 - 3) =<span class="hljs-number"> 2 </span>。<br>对于下标<span class="hljs-number"> 4 </span>，出现在下标<span class="hljs-number"> 3 </span>和下标<span class="hljs-number"> 5 </span>处的 &#x27;e&#x27; 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) =<span class="hljs-number"> 1 </span>。<br>距下标<span class="hljs-number"> 8 </span>最近的 &#x27;e&#x27; 出现在下标<span class="hljs-number"> 6 </span>，所以距离为 abs(8 - 6) =<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaab&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span><br>输出：[<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s[i]</code> 和 <code>c</code> 均为小写英文字母</li><li>题目数据保证 <code>c</code> 在 <code>s</code> 中至少出现一次</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>思想是两次遍历：</p><ul><li>第一次遍历是从左往右遍历，查找左边最近的距离，初始出现字符设置在<code>-n</code>位置</li><li>第二次遍历是从右往左遍历，查找右边最近的距离，初始出现字符设置在<code>2*n</code>位置</li></ul><blockquote><p>注意第二次遍历的时候，需要判断当前距离和之前遍历距离的最小值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] shortestToChar(String s, <span class="hljs-type">char</span> c) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, index = -n; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == c)<br>                index = i;<br>            res[i] = i - index;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, index = <span class="hljs-number">2</span> * n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == c)<br>                index = i;<br>            <br>            res[i] = Math.min(index - i, res[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$ 不包含返回数组的情况下</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>星环科技笔试7-14</title>
    <link href="/2022/07/14/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E6%98%9F%E7%8E%AF%E7%A7%91%E6%8A%80%E7%AC%94%E8%AF%95/"/>
    <url>/2022/07/14/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E6%98%9F%E7%8E%AF%E7%A7%91%E6%8A%80%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="星环科技笔试"><a href="#星环科技笔试" class="headerlink" title="星环科技笔试"></a>星环科技笔试</h1><h2 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220714094924044.png" alt="image-20220714094924044"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xinghuan;<br><br><span class="hljs-comment">// code1</span><br> <span class="hljs-keyword">import</span> java.util.HashMap;<br> <span class="hljs-keyword">import</span> java.util.Map;<br> <span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                nums[j] = in.nextInt();<br>                nums[j] -= j;<br>            &#125;<br>            <span class="hljs-type">Solutions</span> <span class="hljs-variable">sol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solutions</span>();<br>            System.out.println(sol.calcCnt(nums));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solutions</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcCnt</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            hashMap.put(nums[i], hashMap.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : hashMap.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span> (temp &lt;= <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            cnt += temp * (temp-<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220714095915086.png" alt="image-20220714095915086"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xinghuan;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] directions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">static</span> HashMap&lt;Integer, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span>[][] nums= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                nums[i][j] = in.nextInt();<br>            &#125;<br>        &#125;<br>        dfs(nums, n-<span class="hljs-number">1</span>, n-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_steps</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">choices</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : hashMap.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">choice</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span> (max_steps &gt; step) &#123;<br>                max_steps = step;<br>                choices = choice;<br>            &#125;<br>        &#125;<br>        System.out.println(max_steps);<br>        System.out.println(choices);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> cnt)</span> &#123;<br>        <span class="hljs-comment">// reach termial</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>            hashMap.put(cnt, hashMap.getOrDefault(cnt, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">// not reachable</span><br>        <span class="hljs-keyword">if</span> (i &gt;= n || i &lt; <span class="hljs-number">0</span> || j &gt;= n || j &lt; <span class="hljs-number">0</span> || nums[i][j] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">// other way</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) &#123;<br>            nums[i][j] = <span class="hljs-number">0</span>;<br>            dfs(nums, i + directions[d][<span class="hljs-number">0</span>], j + directions[d][<span class="hljs-number">1</span>], cnt+<span class="hljs-number">1</span>);<br>            nums[i][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h2><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220714102649779.png" alt="image-20220714102649779"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220714102704504.png" alt="image-20220714102704504"></p><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220714102715504.png" alt="image-20220714102715504"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>第一个是数组加hashMap的去重</li><li>第二个是回溯剪枝加hashMap</li><li>第三个是后缀表达式加强版</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蔚来提前批7-13</title>
    <link href="/2022/07/14/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E8%94%9A%E6%9D%A5%E6%8F%90%E5%89%8D%E6%89%B97-13/"/>
    <url>/2022/07/14/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/%E8%94%9A%E6%9D%A5%E6%8F%90%E5%89%8D%E6%89%B97-13/</url>
    
    <content type="html"><![CDATA[<h1 id="蔚来汽车提前批2022年7月13日"><a href="#蔚来汽车提前批2022年7月13日" class="headerlink" title="蔚来汽车提前批2022年7月13日"></a>蔚来汽车提前批2022年7月13日</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p>选择题有15道</p><ul><li>计算机网络网关</li><li>递归</li><li>概率计算</li><li>哈希散列</li><li>二叉树前序后序查找</li></ul><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="编程题1-最大子方针"><a href="#编程题1-最大子方针" class="headerlink" title="编程题1-最大子方针"></a>编程题1-最大子方针</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220713202315387.png" alt="image-20220713202315387"></p><p><strong>思路</strong></p><p>直接使用暴力方法，从行列开始，方针的大小从2开始直到边界</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n, m;<br>        n = in.nextInt();<br>        m = in.nextInt();<br>        <span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                nums[i][j] = in.nextInt();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; (i + len &lt; n &amp;&amp; j + len &lt; m); len++) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i][j] + nums[i][j + len] + nums[i + len][j] + nums[i + len][j + len];<br>                    res = Math.max(res, temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(res);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220713202532448.png" alt="image-20220713202532448"></p><blockquote><p>测试案例只通过了这么一点点，不知道还有其他什么情况没有考虑到</p></blockquote><h3 id="编程题2-小红的乘法操作"><a href="#编程题2-小红的乘法操作" class="headerlink" title="编程题2-小红的乘法操作"></a>编程题2-小红的乘法操作</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220713202221213.png" alt="image-20220713202221213"></p><p><strong>思路</strong></p><p>理解是求 b 和 a 的商，然后看这个商由x, y的多次乘法构成，先将商和x, y中最大的求商，直到商为1</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> x, y, a, b;<br><br>        x = in.nextInt();<br>        y = in.nextInt();<br>        a = in.nextInt();<br>        b = in.nextInt();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> calcCnt(x, y, a, b);<br>        System.out.println(res);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcCnt</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (b%a != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = b/a;<br>        <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x;<br>            y = x;<br>            x = y;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (res != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (res % y == <span class="hljs-number">0</span>) &#123;<br>                res /= y;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res % x == <span class="hljs-number">0</span>)&#123;<br>                res /= x;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220713202758107.png" alt="image-20220713202758107"></p><blockquote><p>还是没有通过所有测试案例，痛苦</p></blockquote><h3 id="编程题3-旅游"><a href="#编程题3-旅游" class="headerlink" title="编程题3-旅游"></a>编程题3-旅游</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220713202829731.png" alt="image-20220713202829731"></p><p><strong>思路</strong></p><p>遇到这种题还是只会暴力循环。。。这道题的通过测试案例更少，考虑问题的思路还是不够周到，这里的思路是：</p><ul><li>每次从一个城市开始，记录最大的花费和最小的花费</li><li>添加其他城市的时候查看其他城市与当前最小花费和最大花费的差值是否大于k，大于k就不添加该城市，小于就添加</li><li>然后查看每个城市开始的最大快乐值</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n, k;<br>        n = in.nextInt();<br>        k = in.nextInt();<br>        <span class="hljs-type">int</span>[][] city = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            city[i][<span class="hljs-number">0</span>] = in.nextInt();<br>            city[i][<span class="hljs-number">1</span>] = in.nextInt();<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_happy</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max_cost</span> <span class="hljs-operator">=</span> city[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min_cost</span> <span class="hljs-operator">=</span> city[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp_happy</span> <span class="hljs-operator">=</span> city[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i) &#123;<br>                    <span class="hljs-keyword">if</span> (city[j][<span class="hljs-number">0</span>] - min_cost &lt; k &amp;&amp; max_cost - city[j][<span class="hljs-number">0</span>] &lt; k) &#123;<br>                        temp_happy += city[j][<span class="hljs-number">1</span>];<br>                        min_cost = Math.min(min_cost, city[j][<span class="hljs-number">0</span>]);<br>                        max_cost = Math.max(max_cost, city[j][<span class="hljs-number">0</span>]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            max_happy = Math.max(max_happy, temp_happy);<br>        &#125;<br>        System.out.println(max_happy);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E7%AC%94%E8%AF%95/imgs/image-20220713203153632.png" alt="image-20220713203153632"></p><blockquote><p>提交之后才发现，第二次循环的起始条件应该是第一次循环指针<code>i+1</code>，这样可以避免重复计算城市的组合，还是太过粗心</p></blockquote><h2 id="笔试总结"><a href="#笔试总结" class="headerlink" title="笔试总结"></a>笔试总结</h2><p>蔚来的笔试总共90分钟，15到选择题，3道编程题，时间上还是比较宽裕的</p><ul><li>基础知识掌握不牢靠，选择题全靠猜，八股文需要好好再背一背</li><li>编程题的思路有很大问题，关于动态规划的思路还是不能很快得出，需要再恶补一下<strong>动态规划</strong>的知识</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔试</tag>
      
      <tag>offer</tag>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ResNet学习笔记及代码实现</title>
    <link href="/2021/08/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ResNet%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/08/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ResNet%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ResNet学习笔记及仿真"><a href="#ResNet学习笔记及仿真" class="headerlink" title="ResNet学习笔记及仿真"></a>ResNet学习笔记及仿真</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>深度残差网络（Deep Residual Network）是cnn机器视觉史上的一件里程碑的事件，在2015年，ResNet在ImageNet和COCO数据集上获得了非常优秀的成绩。如下所示：</p><ul><li>ImageNet Classification: “Ultra-deep”<code>152-layer</code> nets</li><li>ImageNet Detection: <code>16%</code> better than 2nd</li><li>ImageNet Localization: <code>27%</code> better than 2nd</li><li>COCO Detection: <code>11%</code> better than 2nd</li><li>COCO Segmentation: <code>12%</code> better than 2nd</li></ul><p>ResNet获得了五项第一，再一次的刷新了CNN模型在ImageNet上的历史<a href="#ref-1"><sup>[1]</sup></a>，而论文的作者<a href="http://kaiminghe.com/">何凯明</a>也获得了CVPR2016最佳论文奖<a href="#ref-2"><sup>[2]</sup></a>。以下是记录了解ResNet的一些笔记，主要是来自于15年和16年何凯明所在的微软研究院发表的论文。</p><h2 id="深度网络退化问题（degradation-problem-of-deep-network）"><a href="#深度网络退化问题（degradation-problem-of-deep-network）" class="headerlink" title="深度网络退化问题（degradation problem of deep network）"></a>深度网络退化问题（degradation problem of deep network）</h2><p>从<code>AlexNet</code>到<code>GoogLeNet</code>，看起来好像是网络越深越好，但是直接秉持着<code>We need go deeper</code>的思想构建神经网络，到最后会发现，随着网络越来越深，会出现<strong>梯度消失（vanishing gradients）</strong>和<strong>梯度爆炸（exploding gradients）</strong>以及<strong>网络退化（network degradation）</strong>：</p><ul><li><strong>梯度消失和爆炸（vanishing&#x2F;exploding gradients）</strong>：网络层数太深引发的梯度方向传播中的连乘效应引起</li><li><strong>网络退化（network degradation）</strong>：较深的模型可以看作是较浅模型的超空间，理论上较深的模型可以看作是较浅模型的恒等映射，但是实际上较深模型后面添加的不是恒等映射，而是一些非线性层<a href="#ref-3"><sup>[3]</sup></a></li></ul><p>对于梯度消失和爆炸的应对方法如下：</p><ul><li><strong>改换激活函数</strong>: 使用<code>relu</code>、<code>LeakyRelu</code>、<code>ELU</code>等激活函数可以改善梯度消散或爆炸问题。<code>relu</code>导数的正数部分恒等于1，所以不会产生梯度消失和梯度爆炸</li><li><strong>BatchNormalization</strong>: 对每一层的输入做scale和shift方法，将每层神经元的输入分布强行拉回均值为0、方差为1的标准正态分布，这就使得激活层输入值落入在非线性函数对输入值比较敏感的区域，使得输入的小变化会导致损失函数较大的变化，使得梯度变大，训练速度加快，且避免梯度消失问题</li><li><strong>梯度剪切</strong>: 该方法主要是针对梯度爆炸提出。其思想是设置一个梯度剪切阈值，更新梯度时，如果梯度超过这个阈值，那么限制其在这个范围之内</li></ul><p>但是随着网络的加深，可以看到的是训练误差和测试误差都开始增加，这自然不是过拟合引起的，而是网络出现退化<a href="#ref-4"><sup>[4]</sup></a>，如<a href="#fig-1">figure1</a>所示：</p><div id="fig-1"></div><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig1.png" style="zoom: 80%;" /><p>网络退化表明了并非所有系统都同样容易优化。考虑一个较深的网络和一个较浅的网络，更深的网络对应更浅的网络相当于是增加了更多的层，添加的层可以是恒等映射（identity mapping），而其他的层是相当于是更浅的模型中直接复制的，这种构造容易得到，较深的模型不会产生比较浅的模型更高的训练误差，但是实验表明，简单地加深网络模型会出现网络退化的问题。</p><h2 id="残差块（Residual-block）"><a href="#残差块（Residual-block）" class="headerlink" title="残差块（Residual block）"></a>残差块（Residual block）</h2><div id="fig-2"></div><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig2.png"></p><p>网络退化出现的原因就是<strong>现有的网络无法实现恒等映射</strong>，将想要得到的恒等映射函数表示为 $H(x)&#x3D;x$，残差块网络设计为 $H(x)&#x3D;F(x)+x$，即直接将恒等映射作为网络的一部分，就可以将问题转化为学习一个残差函数 $F(x)&#x3D;H(x)-x$，那么只要 $F(x)&#x3D;0$，就可以构成一个恒等映射 $H(x)&#x3D;x$，拟合残差比拟合恒等映射容易的多<a href="#ref-5"><sup>[5]</sup></a>。从数学上更加详细地描述残差结构，可以是：</p><div id="eqn-1"></div><p>$$<br>y&#x3D;F(x, W_i)+x<br>$$</p><p>其中 $x$ 和 $y$ 表示的分别是所考虑的层的输入和输出向量，函数 $F(x, W_i)$ 表示要学习的残差映射，操作 $F(x, W_i)+x$ 是通过跳接实现，在<a href="#eqn-1">方程1</a>中 $x$ 和 $F$ 的维度必须相同，否则，需要对跳接进行线性投影 $W_s$ 来匹配维度：</p><div id="eqn-2"></div><p>$$<br>y&#x3D;F(x, W_i)+W_s x<br>$$</p><ul><li><p>$F(x)+x$ 的公式可以通过具有跳接（shortcut connections）的前馈神经网络来实现，跳接可以是跳过一层或者多层的连接，通过跳接在激活函数前，将上一层或几层的输出与本层输出相加，将求和结果输入到激活函数作为本层的输出，残差块示例如<a href="#fig-2">figure2</a>所示</p></li><li><p>跳接只是执行<strong>恒等映射</strong>，他们的输出被添加到堆叠层的输出中，这不会增加额外的参数，也不会增加计算复杂性</p></li><li><p>添加了残差网络，可以给神经网络一个多的选择，例如<strong>学习到的一层的参数是冗余的，那么就可以直接走跳接路线，跳过这个冗余层</strong>，而不用去拟合参数使得输出 $H(x)&#x3D;x$</p></li><li><p><strong>学习残差的计算量比学习输出等于输入小</strong>：例如普通网络为A，残差网络为B，输入为2，输出为2，那么普通网络就是$A(2)&#x3D;2$，而残差网络就是$B(2)&#x3D;F(2)+2&#x3D;2$，即残差网络中$F(2)&#x3D;0$。一般网络会将<strong>权重初始化为0附近的数</strong>，所以让$F(2)$拟合0会比$A(2)&#x3D;2$容易</p></li><li><p><strong>ReLU能够将负数激活为0</strong>，正数等于输出，这相当于过滤了负数的线性变化，让$F(x)&#x3D;0$变的更加容易</p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/ReLU.png" style="zoom:50%;" /></li><li><p>对残差网络$H(x)&#x3D;F(x)+x$求梯度，即反向传播时，得到$H’(x)&#x3D;F’(x)+1$，<strong>残差结构的这个常数1能够保证求梯度的时候梯度不会消失</strong></p></li><li><p>这种结构不仅适用于全连接层，还<strong>适用于卷积层，逐通道地对两个特征图执行元素相加</strong></p></li></ul><h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><div id="fig3"></div><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig3.png"></p><p>网络结构如<a href="#fig3">figure3</a>所示，从左到右分别是VGG-19（196亿次浮点运算）、34层不带残差的plain net（36亿次浮点运算）、34层的残差网络（36亿次浮点运算）</p><h4 id="plain-network"><a href="#plain-network" class="headerlink" title="plain network"></a>plain network</h4><ul><li>主要受到VGGNet的启发，遵循两个简单设计规则：<ul><li>对于相同的输出特征图大小，层具有相同数量的滤波器</li><li>如果特征图大小减半，则过滤器的数量加倍</li></ul></li><li>步长为2的卷积层直接执行下采样</li><li>网络结尾是一个整体平均池化层和一个1000路的全连接层和softmax函数</li><li>总体的带权重的层是34层</li><li>该模型比VGGNet相比具有更少的滤波器和更低的复杂度，plain net 有36亿次浮点运算，而VGG-19有196亿次浮点运算，前者是后者的18%</li></ul><h4 id="Residual-Network"><a href="#Residual-Network" class="headerlink" title="Residual Network"></a>Residual Network</h4><ul><li>在plain net网络中引入了<strong>跳接（shortcut conncetions）</strong>，将其转换为了对应的残差版本</li><li>跳接引入有两种形式：<ul><li>实线：跳接引入的输入和输出维度相同，可以直接相加，如<a href="#eqn-1">公式1</a></li><li>虚线：引入的维度增加时，可以有两种方式<ul><li>跳接仍然执行恒等映射，<strong>填充零</strong>元素保证维度相同</li><li>利用<a href="#eqn-2">公式2</a>对跳接进行<strong>投影</strong>来匹配维度</li></ul></li></ul></li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li>遵循AlexNet数据预处理的方法，对图像进行裁剪和水平翻转得到224 x 224的图像，然后减去每个像素的平均值<a href="#ref-6"><sup>[6]</sup></a></li><li>每次卷积之后和激活函数之前采用批处理标准化（batch normalization, BN）</li><li>批大小（mini-batch ）为256</li><li>学习率（learning rate） 从 0.1 开始，当误差平稳时，学习率除以10，模型训练了 $60 \times 10^4$ 次迭代</li><li>权重衰减（weight decay）0.0001，动量（momentum）为 0.9</li><li>网络中没有使用到dropout</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="ImageNet分类结果"><a href="#ImageNet分类结果" class="headerlink" title="ImageNet分类结果"></a>ImageNet分类结果</h3><p>对比了18层和34层的plain net以及对应的ResNet，可以看到如<a href="#fig-4">figure4</a>所示，<strong>残差结果确实解决了退化问题</strong></p><div id="fig-4"></div><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig4.png"></p><p>对比了ImageNet数据集的测试结果汇总如<a href="#table-3">表3</a>所示</p><div id="table-3"></div><img src=" https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/table3.png" style="zoom:80%;" /><h2 id="基于cifar10数据集的ResNet实现-7"><a href="#基于cifar10数据集的ResNet实现-7" class="headerlink" title="基于cifar10数据集的ResNet实现[7]"></a>基于cifar10数据集的ResNet实现<a href="#ref-7"><sup>[7]</sup></a></h2><h3 id="导入基本模块"><a href="#导入基本模块" class="headerlink" title="导入基本模块"></a>导入基本模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></td></tr></table></figure><h3 id="torchvision下载cifar10数据集"><a href="#torchvision下载cifar10数据集" class="headerlink" title="torchvision下载cifar10数据集"></a>torchvision下载cifar10数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">transform = transforms.Compose([<br>    transforms.RandomHorizontalFlip(),<br>    transforms.ToTensor(),<br>    transforms.Normalize((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)),<br>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">train_set = torchvision.datasets.CIFAR10(<span class="hljs-string">&#x27;../data&#x27;</span>, train=<span class="hljs-literal">True</span>, <br>                                         download=<span class="hljs-literal">True</span>, transform=transform)<br>test_set = torchvision.datasets.CIFAR10(<span class="hljs-string">&#x27;../data&#x27;</span>, train=<span class="hljs-literal">False</span>, <br>                                        download=<span class="hljs-literal">True</span>, transform=transform)<br>train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="hljs-number">128</span>, <br>                                           shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">4</span>)<br>test_loader = torch.utils.data.DataLoader(test_set, batch_size=<span class="hljs-number">100</span>, <br>                                          shuffle=<span class="hljs-literal">False</span>, num_workers=<span class="hljs-number">4</span>)<br>classes = (<span class="hljs-string">&#x27;plane&#x27;</span>, <span class="hljs-string">&#x27;car&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;deer&#x27;</span>,<br>           <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;frog&#x27;</span>, <span class="hljs-string">&#x27;horse&#x27;</span>, <span class="hljs-string">&#x27;ship&#x27;</span>, <span class="hljs-string">&#x27;truck&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Using downloaded and verified file: ../data\cifar-10-python.tar.gzExtracting ../data\cifar-10-python.tar.gz to ../dataFiles already downloaded and verified</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">imshow</span>(<span class="hljs-params">img</span>):<br>    img = img / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span><br>    plt.imshow(np.transpose(img.numpy(), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))<br>    plt.show()<br>image_iter = <span class="hljs-built_in">iter</span>(train_loader)<br>images, _ = image_iter.<span class="hljs-built_in">next</span>()<br>imshow(torchvision.utils.make_grid(images[:<span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/ResNet_4_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">device = <span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span><br>device<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;cuda&#39;</code></pre><h3 id="BasicBlock"><a href="#BasicBlock" class="headerlink" title="BasicBlock"></a>BasicBlock</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig2.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    对于浅层网络，我们使用基本的Block</span><br><span class="hljs-string">    基础块没有维度压缩，所以expansion=1</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    expansion = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, stride=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(BasicBlock, self).__init__()<br>        self.features = nn.Sequential(<br>            nn.Conv2d(in_channels, out_channels, kernel_size=<span class="hljs-number">3</span>, stride=stride, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(out_channels),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Conv2d(out_channels, out_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(out_channels)<br>        )<br><br>        <span class="hljs-comment"># 如果输入输出维度不等，则使用1x1卷积层来改变维度</span><br>        self.shortcut = nn.Sequential()<br>        <span class="hljs-keyword">if</span> stride != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> in_channels != self.expansion * out_channels:<br>            self.shortcut = nn.Sequential(<br>                nn.Conv2d(in_channels, self.expansion * out_channels, kernel_size=<span class="hljs-number">1</span>, stride=stride, bias=<span class="hljs-literal">False</span>),<br>                nn.BatchNorm2d(self.expansion * out_channels),<br>            )<br><br>            <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        out = self.features(x)<br>        out += self.shortcut(x)<br>        out = torch.relu(out)<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试</span><br>basic_block = BasicBlock(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>)<br><span class="hljs-built_in">print</span>(basic_block)<br>x = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">64</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)<br>y = basic_block(x)<br><span class="hljs-built_in">print</span>(y.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">BasicBlock(  (features): Sequential(    (0): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)    (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)    (2): ReLU(inplace=True)    (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)    (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)  )  (shortcut): Sequential(    (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)    (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)  ))torch.Size([2, 128, 32, 32])</code></pre><h3 id="Bottleneck-Block"><a href="#Bottleneck-Block" class="headerlink" title="Bottleneck Block"></a>Bottleneck Block</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig5.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottleneck</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    对于深层网络，我们使用BottleNeck，论文中提出其拥有近似的计算复杂度，但能节省很多资源</span><br><span class="hljs-string">    zip_channels: 压缩后的维数，最后输出的维数是 expansion * zip_channels</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    expansion = <span class="hljs-number">4</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_channels, zip_channels, stride=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(Bottleneck, self).__init__()<br>        out_channels = self.expansion * zip_channels<br>        self.features = nn.Sequential(<br>            nn.Conv2d(in_channels, zip_channels, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(zip_channels),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Conv2d(zip_channels, zip_channels, kernel_size=<span class="hljs-number">3</span>, stride=stride, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(zip_channels),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Conv2d(zip_channels, out_channels, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(out_channels)<br>        )<br>        self.shortcut = nn.Sequential()<br>        <span class="hljs-keyword">if</span> stride != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> in_channels != out_channels:<br>            self.shortcut = nn.Sequential(<br>                nn.Conv2d(in_channels, out_channels, kernel_size=<span class="hljs-number">1</span>, stride=stride, bias=<span class="hljs-literal">False</span>),<br>                nn.BatchNorm2d(out_channels)<br>            )<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        out = self.features(x)<br>        out += self.shortcut(x)<br>        out = torch.relu(out)<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试</span><br>bottleneck = Bottleneck(<span class="hljs-number">256</span>, <span class="hljs-number">128</span>)<br><span class="hljs-built_in">print</span>(bottleneck)<br>x = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">256</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)<br>y = bottleneck(x)<br><span class="hljs-built_in">print</span>(y.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Bottleneck(  (features): Sequential(    (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)    (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)    (2): ReLU(inplace=True)    (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)    (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)    (5): ReLU(inplace=True)    (6): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)    (7): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)  )  (shortcut): Sequential(    (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)    (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)  ))torch.Size([2, 512, 32, 32])</code></pre><h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/fig3.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResNet</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    不同的ResNet架构都是统一的一层特征提取、四层残差，不同点在于每层残差的深度。</span><br><span class="hljs-string">    对于cifar10，feature map size的变化如下：</span><br><span class="hljs-string">    (32, 32, 3) -&gt; [Conv2d] -&gt; (32, 32, 64) -&gt; [Res1] -&gt; (32, 32, 64) -&gt; [Res2] </span><br><span class="hljs-string"> -&gt; (16, 16, 128) -&gt; [Res3] -&gt; (8, 8, 256) -&gt;[Res4] -&gt; (4, 4, 512) -&gt; [AvgPool] </span><br><span class="hljs-string"> -&gt; (1, 1, 512) -&gt; [Reshape] -&gt; (512) -&gt; [Linear] -&gt; (10)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, block, num_blocks, num_classes=<span class="hljs-number">10</span></span>):<br>        <span class="hljs-built_in">super</span>(ResNet, self).__init__()<br>        self.in_channels = <span class="hljs-number">64</span><br>        self.features = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        )<br><br>        self.layer1 = self._make_layer(block, <span class="hljs-number">64</span>, num_blocks[<span class="hljs-number">0</span>], stride=<span class="hljs-number">1</span>)<br>        self.layer2 = self._make_layer(block, <span class="hljs-number">128</span>, num_blocks[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br>        self.layer3 = self._make_layer(block, <span class="hljs-number">256</span>, num_blocks[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br>        self.layer4 = self._make_layer(block, <span class="hljs-number">512</span>, num_blocks[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># cifar10经过上述结构后，到这里的feature map size是 4 x 4 x 512 x expansion</span><br>        <span class="hljs-comment"># 所以这里用了 4 x 4 的平均池化</span><br>        self.avg_pool = nn.AvgPool2d(kernel_size=<span class="hljs-number">4</span>)<br>        self.classifer = nn.Linear(<span class="hljs-number">512</span> * block.expansion, num_classes)<br><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_layer</span>(<span class="hljs-params">self, block, out_channels, num_blocks, stride</span>):<br>        <span class="hljs-comment"># 第一个block要进行降采样</span><br>        strides = [stride] + [<span class="hljs-number">1</span>] * (num_blocks - <span class="hljs-number">1</span>)<br>        layers = []<br>        <span class="hljs-keyword">for</span> stride <span class="hljs-keyword">in</span> strides:<br>            layers.append(block(self.in_channels, out_channels, stride))<br>            <span class="hljs-comment"># 如果是Bottleneck Block的话需要对每层输入的维度进行压缩，压缩后再增加维数</span><br>            <span class="hljs-comment"># 所以每层的输入维数也要跟着变</span><br>            self.in_channels = out_channels * block.expansion<br>        <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br><br>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        out = self.features(x)<br>        out = self.layer1(out)<br>        out = self.layer2(out)<br>        out = self.layer3(out)<br>        out = self.layer4(out)<br>        out = self.avg_pool(out)<br>        out = out.view(out.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)<br>        out = self.classifer(out)<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResNet18</span>():<br>    <span class="hljs-keyword">return</span> ResNet(BasicBlock, [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResNet34</span>():<br>    <span class="hljs-keyword">return</span> ResNet(BasicBlock, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResNet50</span>():<br>    <span class="hljs-keyword">return</span> ResNet(Bottleneck, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResNet101</span>():<br>    <span class="hljs-keyword">return</span> ResNet(Bottleneck, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">23</span>,<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResNet152</span>():<br>    <span class="hljs-keyword">return</span> ResNet(Bottleneck, [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">36</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">net = ResNet34().to(device)<br><span class="hljs-built_in">print</span>(net)<br><span class="hljs-keyword">if</span> device == <span class="hljs-string">&#x27;cuda&#x27;</span>:<br>    net = nn.DataParallel(net)<br>    <span class="hljs-comment"># 当计算图不会改变的时候（每次输入形状相同，模型不改变）的情况下可以提高性能，反之则降低性能</span><br>    torch.backends.cudnn.benchmark = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">ResNet(  (features): Sequential(    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)    (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)    (2): ReLU(inplace=True)  )  (layer1): Sequential(    (0): BasicBlock(      (features): Sequential(        (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (1): BasicBlock(      (features): Sequential(        (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (2): BasicBlock(      (features): Sequential(        (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )  )  (layer2): Sequential(    (0): BasicBlock(      (features): Sequential(        (0): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential(        (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False)        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )    )    (1): BasicBlock(      (features): Sequential(        (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (2): BasicBlock(      (features): Sequential(        (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (3): BasicBlock(      (features): Sequential(        (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )  )  (layer3): Sequential(    (0): BasicBlock(      (features): Sequential(        (0): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential(        (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )    )    (1): BasicBlock(      (features): Sequential(        (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (2): BasicBlock(      (features): Sequential(        (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (3): BasicBlock(      (features): Sequential(        (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (4): BasicBlock(      (features): Sequential(        (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (5): BasicBlock(      (features): Sequential(        (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )  )  (layer4): Sequential(    (0): BasicBlock(      (features): Sequential(        (0): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential(        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )    )    (1): BasicBlock(      (features): Sequential(        (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )    (2): BasicBlock(      (features): Sequential(        (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)        (2): ReLU(inplace=True)        (3): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)        (4): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)      )      (shortcut): Sequential()    )  )  (avg_pool): AvgPool2d(kernel_size=4, stride=4, padding=0)  (classifer): Linear(in_features=512, out_features=10, bias=True))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试</span><br>x = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>).to(device)<br>y = net(x)<br><span class="hljs-built_in">print</span>(y.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">torch.Size([2, 10])</code></pre><h3 id="train-model"><a href="#train-model" class="headerlink" title="train model"></a>train model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lr = <span class="hljs-number">1e-1</span><br>momentum = <span class="hljs-number">0.9</span><br>weight_decay = <span class="hljs-number">5e-4</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = optim.SGD(net.parameters(), lr=lr, momentum=momentum, weight_decay=weight_decay)<br>scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, threshold=<span class="hljs-number">0.1</span>, patience=<span class="hljs-number">3</span>, verbose=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Training</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">epoch</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nEpoch: %d&#x27;</span> % (epoch))<br>    net.train()<br>    train_loss = <span class="hljs-number">0</span><br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> batch_idx, (inputs, targets) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        inputs, targets = inputs.to(device), targets.to(device)<br>        optimizer.zero_grad()<br>        outputs = net(inputs)<br>        loss = criterion(outputs, targets)<br>        loss.backward()<br>        optimizer.step()<br>        train_loss += loss.item()<br>        _, predicted = outputs.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)<br>        total += targets.size(<span class="hljs-number">0</span>)<br>        correct += predicted.eq(targets).<span class="hljs-built_in">sum</span>().item()<br>        <span class="hljs-keyword">if</span> batch_idx % <span class="hljs-number">100</span> == <span class="hljs-number">99</span>:    <span class="hljs-comment"># print every 100 mini-batches</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[%d, %5d] loss: %.6f |  Acc: %.3f%% (%d/%d)&#x27;</span> %<br>                  (epoch + <span class="hljs-number">1</span>, batch_idx + <span class="hljs-number">1</span>, train_loss, <span class="hljs-number">100.</span>*correct/total, correct, total))<br>    <span class="hljs-keyword">return</span> train_loss<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">load_model = <span class="hljs-literal">False</span><br><span class="hljs-keyword">if</span> load_model:<br>    checkpoint = torch.load(<span class="hljs-string">&#x27;./checkpoint/res18.ckpt&#x27;</span>)<br>    net.load_state_dict(checkpoint[<span class="hljs-string">&#x27;net&#x27;</span>])<br>    start_epoch = checkpoint[<span class="hljs-string">&#x27;epoch&#x27;</span>]<br><span class="hljs-keyword">else</span>:<br>    start_epoch = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start_epoch: %s&#x27;</span> % start_epoch)<br></code></pre></td></tr></table></figure><pre><code class="hljs">start_epoch: 0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_epoch, <span class="hljs-number">50</span>):<br>    loss = train(epoch)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Total loss: %.6f&#x27;</span> % loss)<br>    start_epoch = epoch<br>    scheduler.step(loss)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 0[1,   100] loss: 118.672118 |  Acc: 56.953% (7290/12800)[1,   200] loss: 235.403772 |  Acc: 57.355% (14683/25600)[1,   300] loss: 342.972803 |  Acc: 58.721% (22549/38400)Total loss: 436.702453Epoch: 1[2,   100] loss: 95.490529 |  Acc: 65.930% (8439/12800)[2,   200] loss: 189.245391 |  Acc: 66.246% (16959/25600)[2,   300] loss: 279.333860 |  Acc: 66.758% (25635/38400)Total loss: 357.071455Epoch: 2[3,   100] loss: 76.589579 |  Acc: 73.203% (9370/12800)[3,   200] loss: 151.513288 |  Acc: 73.492% (18814/25600)[3,   300] loss: 224.068864 |  Acc: 73.836% (28353/38400)Total loss: 286.139592Epoch: 3[4,   100] loss: 62.455524 |  Acc: 78.664% (10069/12800)[4,   200] loss: 125.946750 |  Acc: 78.246% (20031/25600)[4,   300] loss: 186.423765 |  Acc: 78.414% (30111/38400)Total loss: 240.281207Epoch: 4[5,   100] loss: 54.547970 |  Acc: 81.414% (10421/12800)[5,   200] loss: 110.654127 |  Acc: 80.898% (20710/25600)[5,   300] loss: 166.249208 |  Acc: 80.919% (31073/38400)Total loss: 215.950420Epoch: 5[6,   100] loss: 48.104260 |  Acc: 83.109% (10638/12800)[6,   200] loss: 99.401246 |  Acc: 82.734% (21180/25600)[6,   300] loss: 148.791911 |  Acc: 82.807% (31798/38400)Total loss: 194.453984Epoch: 6[7,   100] loss: 44.256123 |  Acc: 85.352% (10925/12800)[7,   200] loss: 90.796863 |  Acc: 84.582% (21653/25600)[7,   300] loss: 138.052944 |  Acc: 84.396% (32408/38400)Total loss: 181.198413Epoch: 7[8,   100] loss: 40.750996 |  Acc: 85.906% (10996/12800)[8,   200] loss: 84.440442 |  Acc: 85.539% (21898/25600)[8,   300] loss: 127.751372 |  Acc: 85.430% (32805/38400)Total loss: 168.756287Epoch: 8[9,   100] loss: 40.119882 |  Acc: 86.266% (11042/12800)[9,   200] loss: 79.863018 |  Acc: 86.211% (22070/25600)[9,   300] loss: 120.620995 |  Acc: 86.188% (33096/38400)Total loss: 158.876436Epoch: 9[10,   100] loss: 35.623312 |  Acc: 87.477% (11197/12800)[10,   200] loss: 75.740778 |  Acc: 86.777% (22215/25600)[10,   300] loss: 115.162053 |  Acc: 86.703% (33294/38400)Total loss: 151.007361Epoch: 10[11,   100] loss: 34.881428 |  Acc: 88.039% (11269/12800)[11,   200] loss: 71.926582 |  Acc: 87.699% (22451/25600)[11,   300] loss: 109.965547 |  Acc: 87.375% (33552/38400)Total loss: 145.488317Epoch: 11[12,   100] loss: 32.708189 |  Acc: 88.977% (11389/12800)[12,   200] loss: 66.790455 |  Acc: 88.594% (22680/25600)[12,   300] loss: 103.832237 |  Acc: 88.125% (33840/38400)Total loss: 137.913376Epoch: 12[13,   100] loss: 31.950675 |  Acc: 89.242% (11423/12800)[13,   200] loss: 65.730325 |  Acc: 88.820% (22738/25600)[13,   300] loss: 101.885522 |  Acc: 88.430% (33957/38400)Total loss: 135.173613Epoch: 13[14,   100] loss: 29.611200 |  Acc: 89.805% (11495/12800)[14,   200] loss: 62.823584 |  Acc: 89.129% (22817/25600)[14,   300] loss: 97.116191 |  Acc: 88.849% (34118/38400)Total loss: 129.670478Epoch: 14[15,   100] loss: 29.925015 |  Acc: 89.875% (11504/12800)[15,   200] loss: 62.226747 |  Acc: 89.516% (22916/25600)[15,   300] loss: 95.177161 |  Acc: 89.206% (34255/38400)Total loss: 126.196716Epoch: 15[16,   100] loss: 28.724815 |  Acc: 90.039% (11525/12800)[16,   200] loss: 60.983424 |  Acc: 89.551% (22925/25600)[16,   300] loss: 93.304751 |  Acc: 89.354% (34312/38400)Total loss: 123.906554Epoch: 16[17,   100] loss: 27.764434 |  Acc: 90.305% (11559/12800)[17,   200] loss: 57.115116 |  Acc: 90.148% (23078/25600)[17,   300] loss: 89.535789 |  Acc: 89.685% (34439/38400)Total loss: 118.733271Epoch: 17[18,   100] loss: 26.901688 |  Acc: 90.781% (11620/12800)[18,   200] loss: 56.244663 |  Acc: 90.316% (23121/25600)[18,   300] loss: 87.834935 |  Acc: 89.872% (34511/38400)Total loss: 116.597480Epoch: 18[19,   100] loss: 27.289408 |  Acc: 90.633% (11601/12800)[19,   200] loss: 57.436502 |  Acc: 90.137% (23075/25600)[19,   300] loss: 88.500381 |  Acc: 89.846% (34501/38400)Total loss: 115.314192Epoch: 19[20,   100] loss: 24.068543 |  Acc: 91.852% (11757/12800)[20,   200] loss: 53.208921 |  Acc: 90.828% (23252/25600)[20,   300] loss: 84.727040 |  Acc: 90.203% (34638/38400)Total loss: 112.072869Epoch    21: reducing learning rate of group 0 to 1.0000e-02.Epoch: 20[21,   100] loss: 17.140250 |  Acc: 94.570% (12105/12800)[21,   200] loss: 30.638147 |  Acc: 95.156% (24360/25600)[21,   300] loss: 41.904663 |  Acc: 95.573% (36700/38400)Total loss: 51.213734Epoch: 21[22,   100] loss: 7.424102 |  Acc: 97.984% (12542/12800)[22,   200] loss: 14.609958 |  Acc: 97.918% (25067/25600)[22,   300] loss: 21.400117 |  Acc: 97.964% (37618/38400)Total loss: 27.305064Epoch: 22[23,   100] loss: 5.123270 |  Acc: 98.586% (12619/12800)[23,   200] loss: 9.734514 |  Acc: 98.684% (25263/25600)[23,   300] loss: 14.615595 |  Acc: 98.648% (37881/38400)Total loss: 19.189702Epoch: 23[24,   100] loss: 3.460799 |  Acc: 99.172% (12694/12800)[24,   200] loss: 6.807557 |  Acc: 99.203% (25396/25600)[24,   300] loss: 10.049018 |  Acc: 99.211% (38097/38400)Total loss: 13.315432Epoch: 24[25,   100] loss: 2.478284 |  Acc: 99.469% (12732/12800)[25,   200] loss: 4.640014 |  Acc: 99.492% (25470/25600)[25,   300] loss: 6.763096 |  Acc: 99.505% (38210/38400)Total loss: 9.023635Epoch: 25[26,   100] loss: 1.528404 |  Acc: 99.680% (12759/12800)[26,   200] loss: 2.968595 |  Acc: 99.711% (25526/25600)[26,   300] loss: 4.535004 |  Acc: 99.706% (38287/38400)Total loss: 5.932488Epoch: 26[27,   100] loss: 1.165903 |  Acc: 99.852% (12781/12800)[27,   200] loss: 2.107836 |  Acc: 99.867% (25566/25600)[27,   300] loss: 3.091869 |  Acc: 99.875% (38352/38400)Total loss: 4.153865Epoch: 27[28,   100] loss: 0.732892 |  Acc: 99.945% (12793/12800)[28,   200] loss: 1.651403 |  Acc: 99.883% (25570/25600)[28,   300] loss: 2.452116 |  Acc: 99.888% (38357/38400)Total loss: 3.153302Epoch: 28[29,   100] loss: 0.618112 |  Acc: 99.945% (12793/12800)[29,   200] loss: 1.297444 |  Acc: 99.941% (25585/25600)[29,   300] loss: 1.891233 |  Acc: 99.943% (38378/38400)Total loss: 2.471666Epoch: 29[30,   100] loss: 0.548403 |  Acc: 99.945% (12793/12800)[30,   200] loss: 1.019150 |  Acc: 99.953% (25588/25600)[30,   300] loss: 1.501457 |  Acc: 99.958% (38384/38400)Total loss: 1.972135Epoch: 30[31,   100] loss: 0.435647 |  Acc: 99.969% (12796/12800)[31,   200] loss: 0.805838 |  Acc: 99.977% (25594/25600)[31,   300] loss: 1.260185 |  Acc: 99.971% (38389/38400)Total loss: 1.586358Epoch: 31[32,   100] loss: 0.347193 |  Acc: 99.992% (12799/12800)[32,   200] loss: 0.633916 |  Acc: 99.992% (25598/25600)[32,   300] loss: 0.942637 |  Acc: 99.995% (38398/38400)Total loss: 1.342172Epoch: 32[33,   100] loss: 0.301421 |  Acc: 99.984% (12798/12800)[33,   200] loss: 0.628001 |  Acc: 99.980% (25595/25600)[33,   300] loss: 0.972346 |  Acc: 99.982% (38393/38400)Total loss: 1.273002Epoch: 33[34,   100] loss: 0.271426 |  Acc: 100.000% (12800/12800)[34,   200] loss: 0.522611 |  Acc: 100.000% (25600/25600)[34,   300] loss: 0.791412 |  Acc: 99.997% (38399/38400)Total loss: 1.069014Epoch: 34[35,   100] loss: 0.272007 |  Acc: 100.000% (12800/12800)[35,   200] loss: 0.500229 |  Acc: 100.000% (25600/25600)[35,   300] loss: 0.741914 |  Acc: 99.997% (38399/38400)Total loss: 0.962418Epoch: 35[36,   100] loss: 0.200861 |  Acc: 100.000% (12800/12800)[36,   200] loss: 0.421179 |  Acc: 100.000% (25600/25600)[36,   300] loss: 0.637626 |  Acc: 100.000% (38400/38400)Total loss: 0.835531Epoch: 36[37,   100] loss: 0.200766 |  Acc: 100.000% (12800/12800)[37,   200] loss: 0.397603 |  Acc: 100.000% (25600/25600)[37,   300] loss: 0.606028 |  Acc: 99.995% (38398/38400)Total loss: 0.800073Epoch: 37[38,   100] loss: 0.178643 |  Acc: 100.000% (12800/12800)[38,   200] loss: 0.374064 |  Acc: 100.000% (25600/25600)[38,   300] loss: 0.577130 |  Acc: 100.000% (38400/38400)Total loss: 0.768444Epoch: 38[39,   100] loss: 0.192881 |  Acc: 100.000% (12800/12800)[39,   200] loss: 0.412415 |  Acc: 99.996% (25599/25600)[39,   300] loss: 0.607835 |  Acc: 99.997% (38399/38400)Total loss: 0.769075Epoch: 39[40,   100] loss: 0.174156 |  Acc: 100.000% (12800/12800)[40,   200] loss: 0.356172 |  Acc: 100.000% (25600/25600)[40,   300] loss: 0.544260 |  Acc: 100.000% (38400/38400)Total loss: 0.711841Epoch: 40[41,   100] loss: 0.197980 |  Acc: 99.992% (12799/12800)[41,   200] loss: 0.405721 |  Acc: 99.996% (25599/25600)[41,   300] loss: 0.596260 |  Acc: 99.997% (38399/38400)Total loss: 0.783890Epoch: 41[42,   100] loss: 0.195553 |  Acc: 99.992% (12799/12800)[42,   200] loss: 0.377932 |  Acc: 99.996% (25599/25600)[42,   300] loss: 0.565132 |  Acc: 99.997% (38399/38400)Total loss: 0.740863Epoch: 42[43,   100] loss: 0.184922 |  Acc: 100.000% (12800/12800)[43,   200] loss: 0.370228 |  Acc: 99.996% (25599/25600)[43,   300] loss: 0.563876 |  Acc: 99.997% (38399/38400)Total loss: 0.738950Epoch: 43[44,   100] loss: 0.188086 |  Acc: 100.000% (12800/12800)[44,   200] loss: 0.363090 |  Acc: 100.000% (25600/25600)[44,   300] loss: 0.529876 |  Acc: 100.000% (38400/38400)Total loss: 0.684271Epoch    45: reducing learning rate of group 0 to 1.0000e-03.Epoch: 44[45,   100] loss: 0.180676 |  Acc: 99.992% (12799/12800)[45,   200] loss: 0.349191 |  Acc: 99.996% (25599/25600)[45,   300] loss: 0.512983 |  Acc: 99.997% (38399/38400)Total loss: 0.664923Epoch: 45[46,   100] loss: 0.166781 |  Acc: 100.000% (12800/12800)[46,   200] loss: 0.320780 |  Acc: 100.000% (25600/25600)[46,   300] loss: 0.477024 |  Acc: 100.000% (38400/38400)Total loss: 0.632136Epoch: 46[47,   100] loss: 0.153178 |  Acc: 100.000% (12800/12800)[47,   200] loss: 0.315739 |  Acc: 100.000% (25600/25600)[47,   300] loss: 0.473674 |  Acc: 100.000% (38400/38400)Total loss: 0.619973Epoch: 47[48,   100] loss: 0.163760 |  Acc: 100.000% (12800/12800)[48,   200] loss: 0.322436 |  Acc: 100.000% (25600/25600)[48,   300] loss: 0.487261 |  Acc: 100.000% (38400/38400)Total loss: 0.619886Epoch: 48[49,   100] loss: 0.160341 |  Acc: 100.000% (12800/12800)[49,   200] loss: 0.328375 |  Acc: 100.000% (25600/25600)[49,   300] loss: 0.497179 |  Acc: 100.000% (38400/38400)Total loss: 0.643087Epoch: 49[50,   100] loss: 0.156791 |  Acc: 100.000% (12800/12800)[50,   200] loss: 0.309782 |  Acc: 100.000% (25600/25600)[50,   300] loss: 0.466129 |  Acc: 100.000% (38400/38400)Total loss: 0.606150Epoch    51: reducing learning rate of group 0 to 1.0000e-04.</code></pre><h3 id="save-model"><a href="#save-model" class="headerlink" title="save model"></a>save model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">save_model = <span class="hljs-literal">True</span><br><span class="hljs-keyword">if</span> save_model:<br>    state = &#123;<br>        <span class="hljs-string">&#x27;net&#x27;</span>: net.state_dict(),<br>        <span class="hljs-string">&#x27;epoch&#x27;</span>: epoch,<br>    &#125;<br>    os.makedirs(<span class="hljs-string">&#x27;checkpoint&#x27;</span>, exist_ok=<span class="hljs-literal">True</span>)<br>    torch.save(state, <span class="hljs-string">&#x27;./checkpoint/res18.ckpt&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="evaluate"><a href="#evaluate" class="headerlink" title="evaluate"></a>evaluate</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python">dataiter = <span class="hljs-built_in">iter</span>(test_loader)<br>images, labels = dataiter.<span class="hljs-built_in">next</span>()<br>images = images[:<span class="hljs-number">4</span>]<br>labels = labels[:<span class="hljs-number">4</span>]<br><span class="hljs-comment"># print images</span><br>imshow(torchvision.utils.make_grid(images))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;GroundTruth: &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-string">&#x27;%5s&#x27;</span> % classes[labels[j]] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)))<br><br>outputs = net(images.to(device))<br>_, predicted = torch.<span class="hljs-built_in">max</span>(outputs.cpu(), <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Predicted: &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-string">&#x27;%5s&#x27;</span> % classes[predicted[j]]<br>                              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)))<br>correct = <span class="hljs-number">0</span><br>total = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_loader:<br>        images, labels = data<br>        images, labels = images.to(device), labels.to(device)<br>        outputs = net(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>().item()<br><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of the network on the 10000 test images: %d %%&#x27;</span> % (<br>    <span class="hljs-number">100</span> * correct / total))<br><br><br><br>class_correct = <span class="hljs-built_in">list</span>(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br>class_total = <span class="hljs-built_in">list</span>(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_loader:<br>        images, labels = data<br>        images, labels = images.to(device), labels.to(device)<br>        outputs = net(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs, <span class="hljs-number">1</span>)<br>        c = (predicted == labels).squeeze()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            label = labels[i]<br>            class_correct[label] += c[i].item()<br>            class_total[label] += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of %5s : %2d %%&#x27;</span> % (<br>        classes[i], <span class="hljs-number">100</span> * class_correct[i] / class_total[i]))<br></code></pre></td></tr></table></figure><p><img src="https://madao33-static.oss-cn-hangzhou.aliyuncs.com/madao33blog/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/resnet/ResNet_22_0.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">GroundTruth:    cat  ship  ship plane<br>Predicted:    cat  ship   car plane<br>Accuracy of the network on the 10000 test images: 90 %<br>Accuracy of plane : 90 %<br>Accuracy of   car : 100 %<br>Accuracy of  bird : 81 %<br>Accuracy of   cat : 72 %<br>Accuracy of  deer : 89 %<br>Accuracy of   dog : 87 %<br>Accuracy of  frog : 94 %<br>Accuracy of horse : 93 %<br>Accuracy of  ship : 95 %<br>Accuracy of truck : 96 %<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="ref-1"></div><ul><li>[1] <a href="https://zhuanlan.zhihu.com/p/31852747/">知乎文章：你必须要知道CNN模型：ResNet</a></li></ul><div id="ref-2"></div><ul><li>[2] <a href="http://kaiminghe.com/">何凯明个人主页</a></li></ul><div id="ref-3"></div><ul><li>[3] <a href="https://blog.csdn.net/c2250645962/article/details/102838830">csdn博客：网络退化、过拟合、梯度消散&#x2F;爆炸</a></li></ul><div id="ref-4"></div><ul><li>[4] <a href="https://arxiv.org/pdf/1512.03385.pdf">He K ,  Zhang X ,  Ren S , et al. Deep Residual Learning for Image Recognition[J]. 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.</a></li></ul><div id="ref-5"></div><ul><li>[5] <a href="https://zhuanlan.zhihu.com/p/106764370">知乎文章：CVPR2016:ResNet 从根本上解决深度网络退化问题</a></li></ul><div id="ref-6"></div><ul><li>[6] <a href="https://proceedings.neurips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">Krizhevsky A , Sutskever I , Hinton G . ImageNet Classification with Deep Convolutional Neural Networks[J]. Advances in neural information processing systems, 2012, 25(2).</a></li></ul><div id="ref-7"></div><ul><li>[7] <a href="https://github.com/Bingmang/pytorch-cifar10-notebook">Bingmang&#x2F;pytorch-cifar10-notebook</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ResNet</tag>
      
      <tag>深度学习</tag>
      
      <tag>cnn</tag>
      
      <tag>python</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
